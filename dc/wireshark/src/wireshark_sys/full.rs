/* automatically generated by rust-bindgen 0.71.1 */

// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
// SPDX-License-Identifier: Apache-2.0

#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage> {
    storage: Storage,
}
impl<Storage> __BindgenBitfieldUnit<Storage> {
    #[inline]
    pub const fn new(storage: Storage) -> Self {
        Self { storage }
    }
}
impl<Storage> __BindgenBitfieldUnit<Storage>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    fn extract_bit(byte: u8, index: usize) -> bool {
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        byte & mask == mask
    }
    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];
        Self::extract_bit(byte, index)
    }
    #[inline]
    pub unsafe fn raw_get_bit(this: *const Self, index: usize) -> bool {
        debug_assert!(index / 8 < core::mem::size_of::<Storage>());
        let byte_index = index / 8;
        let byte = *(core::ptr::addr_of!((*this).storage) as *const u8).offset(byte_index as isize);
        Self::extract_bit(byte, index)
    }
    #[inline]
    fn change_bit(byte: u8, index: usize, val: bool) -> u8 {
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        if val {
            byte | mask
        } else {
            byte & !mask
        }
    }
    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];
        *byte = Self::change_bit(*byte, index, val);
    }
    #[inline]
    pub unsafe fn raw_set_bit(this: *mut Self, index: usize, val: bool) {
        debug_assert!(index / 8 < core::mem::size_of::<Storage>());
        let byte_index = index / 8;
        let byte =
            (core::ptr::addr_of_mut!((*this).storage) as *mut u8).offset(byte_index as isize);
        *byte = Self::change_bit(*byte, index, val);
    }
    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub unsafe fn raw_get(this: *const Self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < core::mem::size_of::<Storage>());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= core::mem::size_of::<Storage>());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if Self::raw_get_bit(this, i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            self.set_bit(index + bit_offset, val_bit_is_set);
        }
    }
    #[inline]
    pub unsafe fn raw_set(this: *mut Self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < core::mem::size_of::<Storage>());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= core::mem::size_of::<Storage>());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            Self::raw_set_bit(this, index + bit_offset, val_bit_is_set);
        }
    }
}
#[doc = r" If Bindgen could only determine the size and alignment of a"]
#[doc = r" type, it is represented like this."]
#[derive(PartialEq, Copy, Clone, Debug, Hash)]
#[repr(C)]
pub struct __BindgenOpaqueArray<T: Copy, const N: usize>(pub [T; N]);
impl<T: Copy + Default, const N: usize> Default for __BindgenOpaqueArray<T, N> {
    fn default() -> Self {
        Self([<T as Default>::default(); N])
    }
}
pub const DESEGMENT_ONE_MORE_SEGMENT: u32 = 268435455;
pub const DESEGMENT_UNTIL_FIN: u32 = 268435454;
pub const ENC_BIG_ENDIAN: u32 = 0;
pub type __time_t = ::std::os::raw::c_long;
pub type guint8 = ::std::os::raw::c_uchar;
pub type gint16 = ::std::os::raw::c_short;
pub type guint16 = ::std::os::raw::c_ushort;
pub type gint32 = ::std::os::raw::c_int;
pub type guint32 = ::std::os::raw::c_uint;
pub type gint64 = ::std::os::raw::c_long;
pub type guint64 = ::std::os::raw::c_ulong;
pub type time_t = __time_t;
pub type gchar = ::std::os::raw::c_char;
pub type gint = ::std::os::raw::c_int;
pub type gboolean = gint;
pub type guint = ::std::os::raw::c_uint;
pub type gfloat = f32;
pub type gdouble = f64;
pub type gpointer = *mut ::std::os::raw::c_void;
pub type GByteArray = _GByteArray;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GByteArray {
    pub data: *mut guint8,
    pub len: guint,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GByteArray"][::std::mem::size_of::<_GByteArray>() - 16usize];
    ["Alignment of _GByteArray"][::std::mem::align_of::<_GByteArray>() - 8usize];
    ["Offset of field: _GByteArray::data"][::std::mem::offset_of!(_GByteArray, data) - 0usize];
    ["Offset of field: _GByteArray::len"][::std::mem::offset_of!(_GByteArray, len) - 8usize];
};
pub type va_list = __builtin_va_list;
pub type GHashTable = u8;
pub type GSList = __BindgenOpaqueArray<u64, 2usize>;
#[doc = " @defgroup wmem Wireshark Memory Manager\n\n Wmem is a memory management framework for Wireshark that makes it simple to\n write dissectors (and other 'user-space' code) that doesn't leak memory. The\n core module provides basic functions like malloc, realloc and free, but\n many other functions are available (see the \"Modules\" list at the top of\n the generated doxygen HTML).\n\n Any wmem functions which allocate memory are guaranteed to either succeed or\n abort the program. However, they *can* still legally return NULL when the\n amount of requested memory is zero.\n\n @{"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _wmem_allocator_t {
    _unused: [u8; 0],
}
#[doc = " A public opaque type representing one wmem allocation pool."]
pub type wmem_allocator_t = _wmem_allocator_t;
#[doc = " @addtogroup wmem\n  @{\n    @defgroup wmem-list Doubly-Linked List\n\n    A doubly-linked list implementation on top of wmem.\n\n    @{"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _wmem_list_t {
    _unused: [u8; 0],
}
pub type wmem_list_t = _wmem_list_t;
#[doc = " @addtogroup wmem\n  @{\n    @defgroup wmem-map Hash Map\n\n    A hash map implementation on top of wmem. Provides insertion, deletion and\n    lookup in expected amortized constant time. Uses universal hashing to map\n    keys into buckets, and provides a generic strong hash function that makes\n    it secure against algorithmic complexity attacks, and suitable for use\n    even with untrusted data.\n\n    @{"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _wmem_map_t {
    _unused: [u8; 0],
}
pub type wmem_map_t = _wmem_map_t;
#[doc = " @addtogroup wmem\n  @{\n    @defgroup wmem-tree Red/Black Tree\n\n    Binary trees are a well-known and popular device in computer science to\n    handle storage of objects based on a search key or identity. The\n    particular binary tree style implemented here is the red/black tree, which\n    has the nice property of being self-balancing. This guarantees O(log(n))\n    time for lookups, compared to linked lists that are O(n). This means\n    red/black trees scale very well when many objects are being stored.\n\n    @{"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _wmem_tree_t {
    _unused: [u8; 0],
}
pub type wmem_tree_t = _wmem_tree_t;
#[doc = " data structure to hold time values with nanosecond resolution"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nstime_t {
    pub secs: time_t,
    pub nsecs: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of nstime_t"][::std::mem::size_of::<nstime_t>() - 16usize];
    ["Alignment of nstime_t"][::std::mem::align_of::<nstime_t>() - 8usize];
    ["Offset of field: nstime_t::secs"][::std::mem::offset_of!(nstime_t, secs) - 0usize];
    ["Offset of field: nstime_t::nsecs"][::std::mem::offset_of!(nstime_t, nsecs) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wtap_rec {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct epan_session {
    _unused: [u8; 0],
}
pub type frame_data = __BindgenOpaqueArray<u64, 13usize>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _e_guid_t {
    pub data1: guint32,
    pub data2: guint16,
    pub data3: guint16,
    pub data4: [guint8; 8usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _e_guid_t"][::std::mem::size_of::<_e_guid_t>() - 16usize];
    ["Alignment of _e_guid_t"][::std::mem::align_of::<_e_guid_t>() - 4usize];
    ["Offset of field: _e_guid_t::data1"][::std::mem::offset_of!(_e_guid_t, data1) - 0usize];
    ["Offset of field: _e_guid_t::data2"][::std::mem::offset_of!(_e_guid_t, data2) - 4usize];
    ["Offset of field: _e_guid_t::data3"][::std::mem::offset_of!(_e_guid_t, data3) - 6usize];
    ["Offset of field: _e_guid_t::data4"][::std::mem::offset_of!(_e_guid_t, data4) - 8usize];
};
pub type e_guid_t = _e_guid_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct e_in6_addr {
    pub bytes: [u8; 16usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of e_in6_addr"][::std::mem::size_of::<e_in6_addr>() - 16usize];
    ["Alignment of e_in6_addr"][::std::mem::align_of::<e_in6_addr>() - 1usize];
    ["Offset of field: e_in6_addr::bytes"][::std::mem::offset_of!(e_in6_addr, bytes) - 0usize];
};
pub type ws_in6_addr = e_in6_addr;
#[doc = " \"testy, virtual(-izable) buffer\".  They are testy in that they get mad when\n an attempt is made to access data beyond the bounds of their array. In that\n case, they throw an exception.\n\n They are virtualizable in that new tvbuff's can be made from other tvbuffs,\n while only the original tvbuff may have data. That is, the new tvbuff has\n virtual data."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tvbuff {
    _unused: [u8; 0],
}
pub type tvbuff_t = u8;
extern "C" {
    pub fn tvb_reported_length(tvb: *const tvbuff_t) -> guint;
}
extern "C" {
    #[doc = " Returns target for convenience. Does not suffer from possible\n expense of tvb_get_ptr(), since this routine is smart enough\n to copy data in chunks if the request range actually exists in\n different \"real\" tvbuffs. This function assumes that the target\n memory is already allocated; it does not allocate or free the\n target memory."]
    pub fn tvb_memcpy(
        tvb: *mut tvbuff_t,
        target: *mut ::std::os::raw::c_void,
        offset: gint,
        length: usize,
    ) -> *mut ::std::os::raw::c_void;
}
pub type address = __BindgenOpaqueArray<u64, 3usize>;
pub const port_type_PT_NONE: port_type = 0;
pub const port_type_PT_SCTP: port_type = 1;
pub const port_type_PT_TCP: port_type = 2;
pub const port_type_PT_UDP: port_type = 3;
pub const port_type_PT_DCCP: port_type = 4;
pub const port_type_PT_IPX: port_type = 5;
pub const port_type_PT_DDP: port_type = 6;
pub const port_type_PT_IDP: port_type = 7;
pub const port_type_PT_USB: port_type = 8;
pub const port_type_PT_I2C: port_type = 9;
pub const port_type_PT_IBQP: port_type = 10;
pub const port_type_PT_BLUETOOTH: port_type = 11;
pub const port_type_PT_IWARP_MPA: port_type = 12;
pub const port_type_PT_MCTP: port_type = 13;
pub type port_type = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _packet_info {
    #[doc = "< name of protocol currently being dissected"]
    pub current_proto: *const ::std::os::raw::c_char,
    #[doc = "< Column formatting information"]
    pub cinfo: *mut epan_column_info,
    #[doc = "< Presence flags for some items"]
    pub presence_flags: guint32,
    #[doc = "< Frame number"]
    pub num: guint32,
    #[doc = "< Packet absolute time stamp"]
    pub abs_ts: nstime_t,
    #[doc = "< Relative timestamp (yes, it can be negative)"]
    pub rel_ts: nstime_t,
    #[doc = "< Relative timestamp from capture start (might be negative for broken files)"]
    pub rel_cap_ts: nstime_t,
    #[doc = "< Relative timestamp from capture start valid"]
    pub rel_cap_ts_present: gboolean,
    pub fd: *mut frame_data,
    pub pseudo_header: *mut wtap_pseudo_header,
    #[doc = "< Record metadata"]
    pub rec: *mut wtap_rec,
    #[doc = "< Frame data sources"]
    pub data_src: *mut GSList,
    #[doc = "< link-layer source address"]
    pub dl_src: address,
    #[doc = "< link-layer destination address"]
    pub dl_dst: address,
    #[doc = "< network-layer source address"]
    pub net_src: address,
    #[doc = "< network-layer destination address"]
    pub net_dst: address,
    #[doc = "< source address (net if present, DL otherwise )"]
    pub src: address,
    #[doc = "< destination address (net if present, DL otherwise )"]
    pub dst: address,
    #[doc = "< First encountered VLAN Id if present otherwise 0"]
    pub vlan_id: guint32,
    #[doc = "< reason why reassembly wasn't done, if any"]
    pub noreassembly_reason: *const ::std::os::raw::c_char,
    #[doc = "< TRUE if the protocol is only a fragment"]
    pub fragmented: gboolean,
    pub flags: _packet_info__bindgen_ty_1,
    #[doc = "< type of the following two port numbers"]
    pub ptype: port_type,
    #[doc = "< source port"]
    pub srcport: guint32,
    #[doc = "< destination port"]
    pub destport: guint32,
    #[doc = "< matched uint for calling subdissector from table"]
    pub match_uint: guint32,
    #[doc = "< matched string for calling subdissector from table"]
    pub match_string: *const ::std::os::raw::c_char,
    #[doc = "< TRUE if address/port endpoints member should be used for conversations"]
    pub use_conv_addr_port_endpoints: gboolean,
    #[doc = "< Data that can be used for address+port conversations, including wildcarding"]
    pub conv_addr_port_endpoints: *mut conversation_addr_port_endpoints,
    #[doc = "< Arbritrary conversation identifier; can't be wildcarded"]
    pub conv_elements: *mut conversation_element,
    #[doc = "< >0 if this segment could be desegmented.\nA dissector that can offer this API (e.g.\nTCP) sets can_desegment=2, then\ncan_desegment is decremented by 1 each time\nwe pass to the next subdissector. Thus only\nthe dissector immediately above the\nprotocol which sets the flag can use it"]
    pub can_desegment: guint16,
    #[doc = "< Value of can_desegment before current\ndissector was called.  Supplied so that\ndissectors for proxy protocols such as\nSOCKS can restore it, allowing the\ndissectors that they call to use the\nTCP dissector's desegmentation (SOCKS\njust retransmits TCP segments once it's\nfinished setting things up, so the TCP\ndesegmentor can desegment its payload)."]
    pub saved_can_desegment: guint16,
    #[doc = "< offset to stuff needing desegmentation"]
    pub desegment_offset: ::std::os::raw::c_int,
    #[doc = "< requested desegmentation additional length\nor\nDESEGMENT_ONE_MORE_SEGMENT:\nDesegment one more full segment\n(warning! only partially implemented)\nDESEGMENT_UNTIL_FIN:\nDesgment all data for this tcp session\nuntil the FIN segment."]
    pub desegment_len: guint32,
    #[doc = "< >0 if the subdissector has specified\na value in 'bytes_until_next_pdu'.\nWhen a dissector detects that the next PDU\nwill start beyond the start of the next\nsegment, it can set this value to 2\nand 'bytes_until_next_pdu' to the number of\nbytes beyond the next segment where the\nnext PDU starts.\n\nIf the protocol dissector below this\none is capable of PDU tracking it can\nuse this hint to detect PDUs that starts\nunaligned to the segment boundaries.\nThe TCP dissector is using this hint from\n(some) protocols to detect when a new PDU\nstarts in the middle of a tcp segment.\n\nThere is intelligence in the glue between\ndissector layers to make sure that this\nrequest is only passed down to the protocol\nimmediately below the current one and not\nany further."]
    pub want_pdu_tracking: guint16,
    pub bytes_until_next_pdu: guint32,
    #[doc = "< Packet was captured as an\noutbound (P2P_DIR_SENT)\ninbound (P2P_DIR_RECV)\nunknown (P2P_DIR_UNKNOWN)"]
    pub p2p_dir: ::std::os::raw::c_int,
    #[doc = "< a hash table passed from one dissector to another"]
    pub private_table: *mut GHashTable,
    #[doc = "< layers of each protocol"]
    pub layers: *mut wmem_list_t,
    pub proto_layers: *mut wmem_map_t,
    #[doc = "< The current \"depth\" or layer number in the current frame"]
    pub curr_layer_num: guint8,
    #[doc = "< The current \"depth\" or layer number for this dissector in the current frame"]
    pub curr_proto_layer_num: guint8,
    pub link_number: guint16,
    #[doc = "< clnp/cotp source reference (can't use srcport, this would confuse tpkt)"]
    pub clnp_srcref: guint16,
    #[doc = "< clnp/cotp destination reference (can't use dstport, this would confuse tpkt)"]
    pub clnp_dstref: guint16,
    #[doc = "< 3GPP messages are sometime different UP link(UL) or Downlink(DL)"]
    pub link_dir: ::std::os::raw::c_int,
    #[doc = "< Rcv.Wind.Shift src applies when sending segments; -1 unknown; -2 disabled"]
    pub src_win_scale: gint16,
    #[doc = "< Rcv.Wind.Shift dst applies when sending segments; -1 unknown; -2 disabled"]
    pub dst_win_scale: gint16,
    #[doc = "< Per packet proto data"]
    pub proto_data: *mut GSList,
    pub frame_end_routines: *mut GSList,
    #[doc = "< Memory pool scoped to the pinfo struct"]
    pub pool: *mut wmem_allocator_t,
    pub epan: *mut epan_session,
    #[doc = "< name of heur list if this packet is being heuristically dissected"]
    pub heur_list_name: *const gchar,
    #[doc = "< The current \"depth\" or layer number in the current frame"]
    pub dissection_depth: ::std::os::raw::c_int,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct _packet_info__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: [u8; 3usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _packet_info__bindgen_ty_1"]
        [::std::mem::size_of::<_packet_info__bindgen_ty_1>() - 4usize];
    ["Alignment of _packet_info__bindgen_ty_1"]
        [::std::mem::align_of::<_packet_info__bindgen_ty_1>() - 4usize];
};
impl _packet_info__bindgen_ty_1 {
    #[inline]
    pub fn in_error_pkt(&self) -> guint32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_in_error_pkt(&mut self, val: guint32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn in_error_pkt_raw(this: *const Self) -> guint32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_in_error_pkt_raw(this: *mut Self, val: guint32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn in_gre_pkt(&self) -> guint32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_in_gre_pkt(&mut self, val: guint32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn in_gre_pkt_raw(this: *const Self) -> guint32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_in_gre_pkt_raw(this: *mut Self, val: guint32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        in_error_pkt: guint32,
        in_gre_pkt: guint32,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let in_error_pkt: u32 = unsafe { ::std::mem::transmute(in_error_pkt) };
            in_error_pkt as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let in_gre_pkt: u32 = unsafe { ::std::mem::transmute(in_gre_pkt) };
            in_gre_pkt as u64
        });
        __bindgen_bitfield_unit
    }
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _packet_info"][::std::mem::size_of::<_packet_info>() - 440usize];
    ["Alignment of _packet_info"][::std::mem::align_of::<_packet_info>() - 8usize];
    ["Offset of field: _packet_info::current_proto"]
        [::std::mem::offset_of!(_packet_info, current_proto) - 0usize];
    ["Offset of field: _packet_info::cinfo"][::std::mem::offset_of!(_packet_info, cinfo) - 8usize];
    ["Offset of field: _packet_info::presence_flags"]
        [::std::mem::offset_of!(_packet_info, presence_flags) - 16usize];
    ["Offset of field: _packet_info::num"][::std::mem::offset_of!(_packet_info, num) - 20usize];
    ["Offset of field: _packet_info::abs_ts"]
        [::std::mem::offset_of!(_packet_info, abs_ts) - 24usize];
    ["Offset of field: _packet_info::rel_ts"]
        [::std::mem::offset_of!(_packet_info, rel_ts) - 40usize];
    ["Offset of field: _packet_info::rel_cap_ts"]
        [::std::mem::offset_of!(_packet_info, rel_cap_ts) - 56usize];
    ["Offset of field: _packet_info::rel_cap_ts_present"]
        [::std::mem::offset_of!(_packet_info, rel_cap_ts_present) - 72usize];
    ["Offset of field: _packet_info::fd"][::std::mem::offset_of!(_packet_info, fd) - 80usize];
    ["Offset of field: _packet_info::pseudo_header"]
        [::std::mem::offset_of!(_packet_info, pseudo_header) - 88usize];
    ["Offset of field: _packet_info::rec"][::std::mem::offset_of!(_packet_info, rec) - 96usize];
    ["Offset of field: _packet_info::data_src"]
        [::std::mem::offset_of!(_packet_info, data_src) - 104usize];
    ["Offset of field: _packet_info::dl_src"]
        [::std::mem::offset_of!(_packet_info, dl_src) - 112usize];
    ["Offset of field: _packet_info::dl_dst"]
        [::std::mem::offset_of!(_packet_info, dl_dst) - 136usize];
    ["Offset of field: _packet_info::net_src"]
        [::std::mem::offset_of!(_packet_info, net_src) - 160usize];
    ["Offset of field: _packet_info::net_dst"]
        [::std::mem::offset_of!(_packet_info, net_dst) - 184usize];
    ["Offset of field: _packet_info::src"][::std::mem::offset_of!(_packet_info, src) - 208usize];
    ["Offset of field: _packet_info::dst"][::std::mem::offset_of!(_packet_info, dst) - 232usize];
    ["Offset of field: _packet_info::vlan_id"]
        [::std::mem::offset_of!(_packet_info, vlan_id) - 256usize];
    ["Offset of field: _packet_info::noreassembly_reason"]
        [::std::mem::offset_of!(_packet_info, noreassembly_reason) - 264usize];
    ["Offset of field: _packet_info::fragmented"]
        [::std::mem::offset_of!(_packet_info, fragmented) - 272usize];
    ["Offset of field: _packet_info::flags"]
        [::std::mem::offset_of!(_packet_info, flags) - 276usize];
    ["Offset of field: _packet_info::ptype"]
        [::std::mem::offset_of!(_packet_info, ptype) - 280usize];
    ["Offset of field: _packet_info::srcport"]
        [::std::mem::offset_of!(_packet_info, srcport) - 284usize];
    ["Offset of field: _packet_info::destport"]
        [::std::mem::offset_of!(_packet_info, destport) - 288usize];
    ["Offset of field: _packet_info::match_uint"]
        [::std::mem::offset_of!(_packet_info, match_uint) - 292usize];
    ["Offset of field: _packet_info::match_string"]
        [::std::mem::offset_of!(_packet_info, match_string) - 296usize];
    ["Offset of field: _packet_info::use_conv_addr_port_endpoints"]
        [::std::mem::offset_of!(_packet_info, use_conv_addr_port_endpoints) - 304usize];
    ["Offset of field: _packet_info::conv_addr_port_endpoints"]
        [::std::mem::offset_of!(_packet_info, conv_addr_port_endpoints) - 312usize];
    ["Offset of field: _packet_info::conv_elements"]
        [::std::mem::offset_of!(_packet_info, conv_elements) - 320usize];
    ["Offset of field: _packet_info::can_desegment"]
        [::std::mem::offset_of!(_packet_info, can_desegment) - 328usize];
    ["Offset of field: _packet_info::saved_can_desegment"]
        [::std::mem::offset_of!(_packet_info, saved_can_desegment) - 330usize];
    ["Offset of field: _packet_info::desegment_offset"]
        [::std::mem::offset_of!(_packet_info, desegment_offset) - 332usize];
    ["Offset of field: _packet_info::desegment_len"]
        [::std::mem::offset_of!(_packet_info, desegment_len) - 336usize];
    ["Offset of field: _packet_info::want_pdu_tracking"]
        [::std::mem::offset_of!(_packet_info, want_pdu_tracking) - 340usize];
    ["Offset of field: _packet_info::bytes_until_next_pdu"]
        [::std::mem::offset_of!(_packet_info, bytes_until_next_pdu) - 344usize];
    ["Offset of field: _packet_info::p2p_dir"]
        [::std::mem::offset_of!(_packet_info, p2p_dir) - 348usize];
    ["Offset of field: _packet_info::private_table"]
        [::std::mem::offset_of!(_packet_info, private_table) - 352usize];
    ["Offset of field: _packet_info::layers"]
        [::std::mem::offset_of!(_packet_info, layers) - 360usize];
    ["Offset of field: _packet_info::proto_layers"]
        [::std::mem::offset_of!(_packet_info, proto_layers) - 368usize];
    ["Offset of field: _packet_info::curr_layer_num"]
        [::std::mem::offset_of!(_packet_info, curr_layer_num) - 376usize];
    ["Offset of field: _packet_info::curr_proto_layer_num"]
        [::std::mem::offset_of!(_packet_info, curr_proto_layer_num) - 377usize];
    ["Offset of field: _packet_info::link_number"]
        [::std::mem::offset_of!(_packet_info, link_number) - 378usize];
    ["Offset of field: _packet_info::clnp_srcref"]
        [::std::mem::offset_of!(_packet_info, clnp_srcref) - 380usize];
    ["Offset of field: _packet_info::clnp_dstref"]
        [::std::mem::offset_of!(_packet_info, clnp_dstref) - 382usize];
    ["Offset of field: _packet_info::link_dir"]
        [::std::mem::offset_of!(_packet_info, link_dir) - 384usize];
    ["Offset of field: _packet_info::src_win_scale"]
        [::std::mem::offset_of!(_packet_info, src_win_scale) - 388usize];
    ["Offset of field: _packet_info::dst_win_scale"]
        [::std::mem::offset_of!(_packet_info, dst_win_scale) - 390usize];
    ["Offset of field: _packet_info::proto_data"]
        [::std::mem::offset_of!(_packet_info, proto_data) - 392usize];
    ["Offset of field: _packet_info::frame_end_routines"]
        [::std::mem::offset_of!(_packet_info, frame_end_routines) - 400usize];
    ["Offset of field: _packet_info::pool"][::std::mem::offset_of!(_packet_info, pool) - 408usize];
    ["Offset of field: _packet_info::epan"][::std::mem::offset_of!(_packet_info, epan) - 416usize];
    ["Offset of field: _packet_info::heur_list_name"]
        [::std::mem::offset_of!(_packet_info, heur_list_name) - 424usize];
    ["Offset of field: _packet_info::dissection_depth"]
        [::std::mem::offset_of!(_packet_info, dissection_depth) - 432usize];
};
pub type packet_info = _packet_info;
pub type ws_in4_addr = u32;
pub const ftenum_FT_NONE: ftenum = 0;
pub const ftenum_FT_PROTOCOL: ftenum = 1;
pub const ftenum_FT_BOOLEAN: ftenum = 2;
pub const ftenum_FT_CHAR: ftenum = 3;
pub const ftenum_FT_UINT8: ftenum = 4;
pub const ftenum_FT_UINT16: ftenum = 5;
pub const ftenum_FT_UINT24: ftenum = 6;
pub const ftenum_FT_UINT32: ftenum = 7;
pub const ftenum_FT_UINT40: ftenum = 8;
pub const ftenum_FT_UINT48: ftenum = 9;
pub const ftenum_FT_UINT56: ftenum = 10;
pub const ftenum_FT_UINT64: ftenum = 11;
pub const ftenum_FT_INT8: ftenum = 12;
pub const ftenum_FT_INT16: ftenum = 13;
pub const ftenum_FT_INT24: ftenum = 14;
pub const ftenum_FT_INT32: ftenum = 15;
pub const ftenum_FT_INT40: ftenum = 16;
pub const ftenum_FT_INT48: ftenum = 17;
pub const ftenum_FT_INT56: ftenum = 18;
pub const ftenum_FT_INT64: ftenum = 19;
pub const ftenum_FT_IEEE_11073_SFLOAT: ftenum = 20;
pub const ftenum_FT_IEEE_11073_FLOAT: ftenum = 21;
pub const ftenum_FT_FLOAT: ftenum = 22;
pub const ftenum_FT_DOUBLE: ftenum = 23;
pub const ftenum_FT_ABSOLUTE_TIME: ftenum = 24;
pub const ftenum_FT_RELATIVE_TIME: ftenum = 25;
pub const ftenum_FT_STRING: ftenum = 26;
pub const ftenum_FT_STRINGZ: ftenum = 27;
pub const ftenum_FT_UINT_STRING: ftenum = 28;
pub const ftenum_FT_ETHER: ftenum = 29;
pub const ftenum_FT_BYTES: ftenum = 30;
pub const ftenum_FT_UINT_BYTES: ftenum = 31;
pub const ftenum_FT_IPv4: ftenum = 32;
pub const ftenum_FT_IPv6: ftenum = 33;
pub const ftenum_FT_IPXNET: ftenum = 34;
pub const ftenum_FT_FRAMENUM: ftenum = 35;
pub const ftenum_FT_GUID: ftenum = 36;
pub const ftenum_FT_OID: ftenum = 37;
pub const ftenum_FT_EUI64: ftenum = 38;
pub const ftenum_FT_AX25: ftenum = 39;
pub const ftenum_FT_VINES: ftenum = 40;
pub const ftenum_FT_REL_OID: ftenum = 41;
pub const ftenum_FT_SYSTEM_ID: ftenum = 42;
pub const ftenum_FT_STRINGZPAD: ftenum = 43;
pub const ftenum_FT_FCWWN: ftenum = 44;
pub const ftenum_FT_STRINGZTRUNC: ftenum = 45;
pub const ftenum_FT_NUM_TYPES: ftenum = 46;
pub type ftenum = ::std::os::raw::c_uint;
pub use self::ftenum as ftenum_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _fvalue_t {
    _unused: [u8; 0],
}
pub type fvalue_t = _fvalue_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct expert_field {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _protocol {
    _unused: [u8; 0],
}
#[doc = " Structure for information about a protocol"]
pub type protocol_t = _protocol;
#[doc = "< none"]
pub const field_display_e_BASE_NONE: field_display_e = 0;
#[doc = "< decimal [integer, float]"]
pub const field_display_e_BASE_DEC: field_display_e = 1;
#[doc = "< hexadecimal [integer, float]"]
pub const field_display_e_BASE_HEX: field_display_e = 2;
#[doc = "< octal [integer]"]
pub const field_display_e_BASE_OCT: field_display_e = 3;
#[doc = "< decimal (hexadecimal) [integer]"]
pub const field_display_e_BASE_DEC_HEX: field_display_e = 4;
#[doc = "< hexadecimal (decimal) [integer]"]
pub const field_display_e_BASE_HEX_DEC: field_display_e = 5;
#[doc = "< call custom routine to format [integer, float]"]
pub const field_display_e_BASE_CUSTOM: field_display_e = 6;
#[doc = "< exponential [float]"]
pub const field_display_e_BASE_EXP: field_display_e = 7;
#[doc = "< hexadecimal bytes with a period (.) between each byte"]
pub const field_display_e_SEP_DOT: field_display_e = 8;
#[doc = "< hexadecimal bytes with a dash (-) between each byte"]
pub const field_display_e_SEP_DASH: field_display_e = 9;
#[doc = "< hexadecimal bytes with a colon (:) between each byte"]
pub const field_display_e_SEP_COLON: field_display_e = 10;
#[doc = "< hexadecimal bytes with a space between each byte"]
pub const field_display_e_SEP_SPACE: field_display_e = 11;
#[doc = "< Used for IPv4 address that shouldn't be resolved (like for netmasks)"]
pub const field_display_e_BASE_NETMASK: field_display_e = 12;
#[doc = "< UDP port"]
pub const field_display_e_BASE_PT_UDP: field_display_e = 13;
#[doc = "< TCP port"]
pub const field_display_e_BASE_PT_TCP: field_display_e = 14;
#[doc = "< DCCP port"]
pub const field_display_e_BASE_PT_DCCP: field_display_e = 15;
#[doc = "< SCTP port"]
pub const field_display_e_BASE_PT_SCTP: field_display_e = 16;
#[doc = "< OUI resolution"]
pub const field_display_e_BASE_OUI: field_display_e = 17;
#[doc = "< local time in our time zone, with month and day"]
pub const field_display_e_ABSOLUTE_TIME_LOCAL: field_display_e = 18;
#[doc = "< UTC, with month and day"]
pub const field_display_e_ABSOLUTE_TIME_UTC: field_display_e = 19;
#[doc = "< UTC, with 1-origin day-of-year"]
pub const field_display_e_ABSOLUTE_TIME_DOY_UTC: field_display_e = 20;
#[doc = "< UTC, with \"NULL\" when timestamp is all zeros"]
pub const field_display_e_ABSOLUTE_TIME_NTP_UTC: field_display_e = 21;
#[doc = "< Unix time"]
pub const field_display_e_ABSOLUTE_TIME_UNIX: field_display_e = 22;
#[doc = "< Replace all whitespace characters (newline, formfeed, etc) with \"space\"."]
pub const field_display_e_BASE_STR_WSP: field_display_e = 23;
pub type field_display_e = ::std::os::raw::c_uint;
#[doc = "< Field is not referenced"]
pub const hf_ref_type_HF_REF_TYPE_NONE: hf_ref_type = 0;
#[doc = "< Field is indirectly referenced (only applicable for FT_PROTOCOL) via. its child"]
pub const hf_ref_type_HF_REF_TYPE_INDIRECT: hf_ref_type = 1;
#[doc = "< Field is directly referenced"]
pub const hf_ref_type_HF_REF_TYPE_DIRECT: hf_ref_type = 2;
pub type hf_ref_type = ::std::os::raw::c_uint;
#[doc = " information describing a header field"]
pub type header_field_info = _header_field_info;
#[doc = " information describing a header field"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _header_field_info {
    #[doc = "< [FIELDNAME] full name of this field"]
    pub name: *const ::std::os::raw::c_char,
    #[doc = "< [FIELDFILTERNAME] filter name of this field"]
    pub abbrev: *const ::std::os::raw::c_char,
    #[doc = "< [FIELDTYPE] field type, one of FT_ (from ftypes.h)"]
    pub type_: ftenum,
    #[doc = "< [FIELDDISPLAY] one of BASE_, or field bit-width if FT_BOOLEAN and non-zero bitmask"]
    pub display: ::std::os::raw::c_int,
    #[doc = "< [FIELDCONVERT] value_string, val64_string, range_string or true_false_string,\ntypically converted by VALS(), RVALS() or TFS().\nIf this is an FT_PROTOCOL or BASE_PROTOCOL_INFO then it points to the\nassociated protocol_t structure"]
    pub strings: *const ::std::os::raw::c_void,
    #[doc = "< [BITMASK] bitmask of interesting bits"]
    pub bitmask: guint64,
    #[doc = "< [FIELDDESCR] Brief description of field"]
    pub blurb: *const ::std::os::raw::c_char,
    #[doc = "< Field ID"]
    pub id: ::std::os::raw::c_int,
    #[doc = "< parent protocol tree"]
    pub parent: ::std::os::raw::c_int,
    #[doc = "< is this field referenced by a filter"]
    pub ref_type: hf_ref_type,
    #[doc = "< ID of previous hfinfo with same abbrev"]
    pub same_name_prev_id: ::std::os::raw::c_int,
    #[doc = "< Link to next hfinfo with same abbrev"]
    pub same_name_next: *mut header_field_info,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _header_field_info"][::std::mem::size_of::<_header_field_info>() - 72usize];
    ["Alignment of _header_field_info"][::std::mem::align_of::<_header_field_info>() - 8usize];
    ["Offset of field: _header_field_info::name"]
        [::std::mem::offset_of!(_header_field_info, name) - 0usize];
    ["Offset of field: _header_field_info::abbrev"]
        [::std::mem::offset_of!(_header_field_info, abbrev) - 8usize];
    ["Offset of field: _header_field_info::type_"]
        [::std::mem::offset_of!(_header_field_info, type_) - 16usize];
    ["Offset of field: _header_field_info::display"]
        [::std::mem::offset_of!(_header_field_info, display) - 20usize];
    ["Offset of field: _header_field_info::strings"]
        [::std::mem::offset_of!(_header_field_info, strings) - 24usize];
    ["Offset of field: _header_field_info::bitmask"]
        [::std::mem::offset_of!(_header_field_info, bitmask) - 32usize];
    ["Offset of field: _header_field_info::blurb"]
        [::std::mem::offset_of!(_header_field_info, blurb) - 40usize];
    ["Offset of field: _header_field_info::id"]
        [::std::mem::offset_of!(_header_field_info, id) - 48usize];
    ["Offset of field: _header_field_info::parent"]
        [::std::mem::offset_of!(_header_field_info, parent) - 52usize];
    ["Offset of field: _header_field_info::ref_type"]
        [::std::mem::offset_of!(_header_field_info, ref_type) - 56usize];
    ["Offset of field: _header_field_info::same_name_prev_id"]
        [::std::mem::offset_of!(_header_field_info, same_name_prev_id) - 60usize];
    ["Offset of field: _header_field_info::same_name_next"]
        [::std::mem::offset_of!(_header_field_info, same_name_next) - 64usize];
};
#[doc = " Used when registering many fields at once, using proto_register_field_array()"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hf_register_info {
    #[doc = "< written to by register() function"]
    pub p_id: *mut ::std::os::raw::c_int,
    #[doc = "< the field info to be registered"]
    pub hfinfo: header_field_info,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of hf_register_info"][::std::mem::size_of::<hf_register_info>() - 80usize];
    ["Alignment of hf_register_info"][::std::mem::align_of::<hf_register_info>() - 8usize];
    ["Offset of field: hf_register_info::p_id"]
        [::std::mem::offset_of!(hf_register_info, p_id) - 0usize];
    ["Offset of field: hf_register_info::hfinfo"]
        [::std::mem::offset_of!(hf_register_info, hfinfo) - 8usize];
};
#[doc = " string representation, if one of the proto_tree_add_..._format() functions used"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _item_label_t {
    pub representation: [::std::os::raw::c_char; 240usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _item_label_t"][::std::mem::size_of::<_item_label_t>() - 240usize];
    ["Alignment of _item_label_t"][::std::mem::align_of::<_item_label_t>() - 1usize];
    ["Offset of field: _item_label_t::representation"]
        [::std::mem::offset_of!(_item_label_t, representation) - 0usize];
};
#[doc = " string representation, if one of the proto_tree_add_..._format() functions used"]
pub type item_label_t = _item_label_t;
#[doc = " Contains the field information for the proto_item."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct field_info {
    #[doc = "< pointer to registered field information"]
    pub hfinfo: *mut header_field_info,
    #[doc = "< current start of data in field_info.ds_tvb"]
    pub start: gint,
    #[doc = "< current data length of item in field_info.ds_tvb"]
    pub length: gint,
    #[doc = "< start of appendix data"]
    pub appendix_start: gint,
    #[doc = "< length of appendix data"]
    pub appendix_length: gint,
    #[doc = "< one of ETT_ or -1"]
    pub tree_type: gint,
    #[doc = "< bitfield like FI_GENERATED, ..."]
    pub flags: guint32,
    #[doc = "< string for GUI tree"]
    pub rep: *mut item_label_t,
    #[doc = "< data source tvbuff"]
    pub ds_tvb: *mut tvbuff_t,
    pub value: *mut fvalue_t,
    #[doc = "< Hierarchical layer number, for all protocols in the tree."]
    pub total_layer_num: ::std::os::raw::c_int,
    #[doc = "< Protocol layer number, so 1st, 2nd, 3rd, ... for protocol X."]
    pub proto_layer_num: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of field_info"][::std::mem::size_of::<field_info>() - 64usize];
    ["Alignment of field_info"][::std::mem::align_of::<field_info>() - 8usize];
    ["Offset of field: field_info::hfinfo"][::std::mem::offset_of!(field_info, hfinfo) - 0usize];
    ["Offset of field: field_info::start"][::std::mem::offset_of!(field_info, start) - 8usize];
    ["Offset of field: field_info::length"][::std::mem::offset_of!(field_info, length) - 12usize];
    ["Offset of field: field_info::appendix_start"]
        [::std::mem::offset_of!(field_info, appendix_start) - 16usize];
    ["Offset of field: field_info::appendix_length"]
        [::std::mem::offset_of!(field_info, appendix_length) - 20usize];
    ["Offset of field: field_info::tree_type"]
        [::std::mem::offset_of!(field_info, tree_type) - 24usize];
    ["Offset of field: field_info::flags"][::std::mem::offset_of!(field_info, flags) - 28usize];
    ["Offset of field: field_info::rep"][::std::mem::offset_of!(field_info, rep) - 32usize];
    ["Offset of field: field_info::ds_tvb"][::std::mem::offset_of!(field_info, ds_tvb) - 40usize];
    ["Offset of field: field_info::value"][::std::mem::offset_of!(field_info, value) - 48usize];
    ["Offset of field: field_info::total_layer_num"]
        [::std::mem::offset_of!(field_info, total_layer_num) - 56usize];
    ["Offset of field: field_info::proto_layer_num"]
        [::std::mem::offset_of!(field_info, proto_layer_num) - 60usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct crumb_spec_t {
    pub crumb_bit_offset: guint,
    pub crumb_bit_length: guint8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of crumb_spec_t"][::std::mem::size_of::<crumb_spec_t>() - 8usize];
    ["Alignment of crumb_spec_t"][::std::mem::align_of::<crumb_spec_t>() - 4usize];
    ["Offset of field: crumb_spec_t::crumb_bit_offset"]
        [::std::mem::offset_of!(crumb_spec_t, crumb_bit_offset) - 0usize];
    ["Offset of field: crumb_spec_t::crumb_bit_length"]
        [::std::mem::offset_of!(crumb_spec_t, crumb_bit_length) - 4usize];
};
#[doc = " Each proto_tree, proto_item is one of these."]
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Copy, Clone)]
pub struct _proto_node {
    pub _bindgen_opaque_blob: [u64; 6usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _proto_node"][::std::mem::size_of::<_proto_node>() - 48usize];
    ["Alignment of _proto_node"][::std::mem::align_of::<_proto_node>() - 8usize];
};
#[doc = " Each proto_tree, proto_item is one of these."]
pub type proto_node = _proto_node;
#[doc = " A protocol tree element."]
pub type proto_tree = proto_node;
#[doc = " A protocol item element."]
pub type proto_item = proto_node;
pub type proto_tree_foreach_func =
    ::std::option::Option<unsafe extern "C" fn(arg1: *mut proto_node, arg2: gpointer)>;
extern "C" {
    pub fn proto_tree_children_foreach(
        tree: *mut proto_tree,
        func: proto_tree_foreach_func,
        data: gpointer,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct proto_plugin {
    pub register_protoinfo: ::std::option::Option<unsafe extern "C" fn()>,
    pub register_handoff: ::std::option::Option<unsafe extern "C" fn()>,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of proto_plugin"][::std::mem::size_of::<proto_plugin>() - 16usize];
    ["Alignment of proto_plugin"][::std::mem::align_of::<proto_plugin>() - 8usize];
    ["Offset of field: proto_plugin::register_protoinfo"]
        [::std::mem::offset_of!(proto_plugin, register_protoinfo) - 0usize];
    ["Offset of field: proto_plugin::register_handoff"]
        [::std::mem::offset_of!(proto_plugin, register_handoff) - 8usize];
};
extern "C" {
    #[doc = " Register dissector plugin with the plugin system."]
    pub fn proto_register_plugin(plugin: *const proto_plugin);
}
extern "C" {
    #[doc = " Create a subtree under an existing item.\n@param pi the parent item of the new subtree\n@param idx one of the ett_ array elements registered with proto_register_subtree_array()\n@return the new subtree"]
    pub fn proto_item_add_subtree(pi: *mut proto_item, idx: gint) -> *mut proto_tree;
}
extern "C" {
    #[doc = " Get an existing subtree under an item.\n@param pi the parent item of the subtree\n@return the subtree or NULL"]
    pub fn proto_item_get_subtree(pi: *mut proto_item) -> *mut proto_tree;
}
extern "C" {
    #[doc = " Get the parent of a subtree item.\n@param pi the child item in the subtree\n@return parent item or NULL"]
    pub fn proto_item_get_parent(pi: *const proto_item) -> *mut proto_item;
}
extern "C" {
    #[doc = " Get Nth generation parent item.\n@param pi the child item in the subtree\n@param gen the generation to get (using 1 here is the same as using proto_item_get_parent())\n@return parent item"]
    pub fn proto_item_get_parent_nth(
        pi: *mut proto_item,
        gen: ::std::os::raw::c_int,
    ) -> *mut proto_item;
}
extern "C" {
    #[doc = " Replace text of item after it already has been created.\n@param pi the item to set the text\n@param format printf like format string\n@param ... printf like parameters"]
    pub fn proto_item_set_text(pi: *mut proto_item, format: *const ::std::os::raw::c_char, ...);
}
extern "C" {
    #[doc = " Append to text of item after it has already been created.\n@param pi the item to append the text to\n@param format printf like format string\n@param ... printf like parameters"]
    pub fn proto_item_append_text(pi: *mut proto_item, format: *const ::std::os::raw::c_char, ...);
}
extern "C" {
    #[doc = " Prepend to text of item after it has already been created.\n@param pi the item to prepend the text to\n@param format printf like format string\n@param ... printf like parameters"]
    pub fn proto_item_prepend_text(pi: *mut proto_item, format: *const ::std::os::raw::c_char, ...);
}
extern "C" {
    #[doc = " Set proto_item's length inside tvb, after it has already been created.\n@param pi the item to set the length\n@param length the new length of the item"]
    pub fn proto_item_set_len(pi: *mut proto_item, length: gint);
}
extern "C" {
    #[doc = " Sets the length of the item based on its start and on the specified\n offset, which is the offset past the end of the item; as the start\n in the item is relative to the beginning of the data source tvbuff,\n we need to pass in a tvbuff.\n\n Given an item created as:\n      ti = proto_tree_add_item(*, *, tvb, offset, -1, *);\n then\n      proto_item_set_end(ti, tvb, end);\n is equivalent to\n      proto_item_set_len(ti, end - offset);\n\n@param pi the item to set the length\n@param tvb end is relative to this tvbuff\n@param end this end offset is relative to the beginning of tvb\n@todo make usage clearer, I don't understand it!"]
    pub fn proto_item_set_end(pi: *mut proto_item, tvb: *mut tvbuff_t, end: gint);
}
extern "C" {
    #[doc = " Get length of a proto_item. Useful after using proto_tree_add_item()\n to add a variable-length field (e.g., FT_UINT_STRING).\n@param pi the item to get the length from\n@return the current length"]
    pub fn proto_item_get_len(pi: *const proto_item) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Set the bit offset and length for the specified proto_item.\n @param ti The item to set.\n @param bits_offset The number of bits from the beginning of the field.\n @param bits_len The new length in bits."]
    pub fn proto_item_set_bits_offset_len(
        ti: *mut proto_item,
        bits_offset: ::std::os::raw::c_int,
        bits_len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " Get the display representation of a proto_item.\n Can be used, for example, to append that to the parent item of\n that item.\n@param scope the wmem scope to use to allocate the string\n@param pi the item from which to get the display representation\n@return the display representation"]
    pub fn proto_item_get_display_repr(
        scope: *mut wmem_allocator_t,
        pi: *mut proto_item,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Creates a new proto_tree root.\n@return the new tree root"]
    pub fn proto_tree_create_root(pinfo: *mut _packet_info) -> *mut proto_tree;
}
extern "C" {
    pub fn proto_tree_reset(tree: *mut proto_tree);
}
extern "C" {
    #[doc = " Clear memory for entry proto_tree. Clears proto_tree struct also.\n@param tree the tree to free"]
    pub fn proto_tree_free(tree: *mut proto_tree);
}
extern "C" {
    #[doc = " Set the tree visible or invisible.\nIs the parsing being done for a visible proto_tree or an invisible one?\nBy setting this correctly, the proto_tree creation is sped up by not\nhaving to call vsnprintf and copy strings around.\n@param tree the tree to be set\n@param visible ... or not\n@return the old value"]
    pub fn proto_tree_set_visible(tree: *mut proto_tree, visible: gboolean) -> gboolean;
}
extern "C" {
    #[doc = " Indicate whether we should fake protocols during dissection (default = TRUE)\n@param tree the tree to be set\n@param fake_protocols TRUE if we should fake protocols"]
    pub fn proto_tree_set_fake_protocols(tree: *mut proto_tree, fake_protocols: gboolean);
}
extern "C" {
    #[doc = " Mark a field/protocol ID as \"interesting\".\n@param tree the tree to be set (currently ignored)\n@param hfid the interesting field id\n@todo what *does* interesting mean?"]
    pub fn proto_tree_prime_with_hfid(tree: *mut proto_tree, hfid: ::std::os::raw::c_int);
}
extern "C" {
    #[doc = " Get a parent item of a subtree.\n@param tree the tree to get the parent from\n@return parent item"]
    pub fn proto_tree_get_parent(tree: *mut proto_tree) -> *mut proto_item;
}
extern "C" {
    #[doc = " Get the parent tree of a subtree.\n@param tree the tree to get the parent from\n@return parent tree"]
    pub fn proto_tree_get_parent_tree(tree: *mut proto_tree) -> *mut proto_tree;
}
extern "C" {
    #[doc = " Get the root tree from any subtree.\n@param tree the tree to get the root from\n@return root tree"]
    pub fn proto_tree_get_root(tree: *mut proto_tree) -> *mut proto_tree;
}
extern "C" {
    #[doc = " Move an existing item behind another existing item.\n@param tree the tree to which both items belong\n@param fixed_item the item which keeps its position\n@param item_to_move the item which will be moved"]
    pub fn proto_tree_move_item(
        tree: *mut proto_tree,
        fixed_item: *mut proto_item,
        item_to_move: *mut proto_item,
    );
}
extern "C" {
    #[doc = " Set start and length of an appendix for a proto_tree.\n@param tree the tree to set the appendix start and length\n@param tvb the tv buffer of the current data\n@param start the start offset of the appendix\n@param length the length of the appendix"]
    pub fn proto_tree_set_appendix(
        tree: *mut proto_tree,
        tvb: *mut tvbuff_t,
        start: gint,
        length: gint,
    );
}
extern "C" {
    #[doc = " Add an item to a proto_tree, using the text label registered to that item.\nThe item is extracted from the tvbuff handed to it.\n@param tree the tree to append this item to\n@param hfinfo field\n@param tvb the tv buffer of the current data\n@param start start of data in tvb\n@param length length of data in tvb\n@param encoding data encoding\n@return the newly created item"]
    pub fn proto_tree_add_item_new(
        tree: *mut proto_tree,
        hfinfo: *mut header_field_info,
        tvb: *mut tvbuff_t,
        start: gint,
        length: gint,
        encoding: guint,
    ) -> *mut proto_item;
}
extern "C" {
    pub fn proto_tree_add_item(
        tree: *mut proto_tree,
        hfindex: ::std::os::raw::c_int,
        tvb: *mut tvbuff_t,
        start: gint,
        length: gint,
        encoding: guint,
    ) -> *mut proto_item;
}
extern "C" {
    #[doc = " Add an item to a proto_tree, using the text label registered to that item.\nThe item is extracted from the tvbuff handed to it.\n\nReturn the length of the item through the pointer.\n@param tree the tree to append this item to\n@param hfinfo field\n@param tvb the tv buffer of the current data\n@param start start of data in tvb\n@param length length of data in tvb\n@param encoding data encoding\n@param[out] lenretval points to a gint that will be set to the item length\n@return the newly created item, and *lenretval is set to the item length"]
    pub fn proto_tree_add_item_new_ret_length(
        tree: *mut proto_tree,
        hfinfo: *mut header_field_info,
        tvb: *mut tvbuff_t,
        start: gint,
        length: gint,
        encoding: guint,
        lenretval: *mut gint,
    ) -> *mut proto_item;
}
extern "C" {
    pub fn proto_tree_add_item_ret_length(
        tree: *mut proto_tree,
        hfindex: ::std::os::raw::c_int,
        tvb: *mut tvbuff_t,
        start: gint,
        length: gint,
        encoding: guint,
        lenretval: *mut gint,
    ) -> *mut proto_item;
}
extern "C" {
    #[doc = " Add an integer data item to a proto_tree, using the text label registered to that item.\nThe item is extracted from the tvbuff handed to it, and the retrieved\nvalue is also set to *retval so the caller gets it back for other uses.\n\nThis function retrieves the value even if the passed-in tree param is NULL,\nso that it can be used by dissectors at all times to both get the value\nand set the tree item to it.\n\nLike other proto_tree_add functions, if there is a tree and the value cannot\nbe decoded from the tvbuff, then an expert info error is reported.\n\nThis function accepts ENC_LITTLE_ENDIAN and ENC_BIG_ENDIAN for native number\nencoding in the tvbuff\n\nThe length argument must\nbe set to the appropriate size of the native type as in other proto_add routines.\n\nIntegers of 8, 16, 24 and 32 bits can be retrieved with the _ret_int and\nret_uint functions; integers of 40, 48, 56, and 64 bits can be retrieved\nwith the _ret_uint64 function; Boolean values of 8, 16, 24, 32, 40, 48,\n56, and 64 bits can be retrieved with the _ret_boolean function.\n\n@param tree the tree to append this item to\n@param hfindex field\n@param tvb the tv buffer of the current data\n@param start start of data in tvb (cannot be negative)\n@param length length of data in tvb (for strings can be -1 for remaining)\n@param encoding data encoding (e.g, ENC_LITTLE_ENDIAN, ENC_BIG_ENDIAN, ENC_ASCII|ENC_STRING, etc.)\n@param[out] retval points to a gint32 or guint32 which will be set to the value\n@return the newly created item, and *retval is set to the decoded value masked/shifted according to bitmask"]
    pub fn proto_tree_add_item_ret_int(
        tree: *mut proto_tree,
        hfindex: ::std::os::raw::c_int,
        tvb: *mut tvbuff_t,
        start: gint,
        length: gint,
        encoding: guint,
        retval: *mut gint32,
    ) -> *mut proto_item;
}
extern "C" {
    pub fn proto_tree_add_item_ret_int64(
        tree: *mut proto_tree,
        hfindex: ::std::os::raw::c_int,
        tvb: *mut tvbuff_t,
        start: gint,
        length: gint,
        encoding: guint,
        retval: *mut gint64,
    ) -> *mut proto_item;
}
extern "C" {
    pub fn proto_tree_add_item_ret_uint(
        tree: *mut proto_tree,
        hfindex: ::std::os::raw::c_int,
        tvb: *mut tvbuff_t,
        start: gint,
        length: gint,
        encoding: guint,
        retval: *mut guint32,
    ) -> *mut proto_item;
}
extern "C" {
    pub fn proto_tree_add_item_ret_uint64(
        tree: *mut proto_tree,
        hfindex: ::std::os::raw::c_int,
        tvb: *mut tvbuff_t,
        start: gint,
        length: gint,
        encoding: guint,
        retval: *mut guint64,
    ) -> *mut proto_item;
}
extern "C" {
    pub fn proto_tree_add_item_ret_varint(
        tree: *mut proto_tree,
        hfindex: ::std::os::raw::c_int,
        tvb: *mut tvbuff_t,
        start: gint,
        length: gint,
        encoding: guint,
        retval: *mut guint64,
        lenretval: *mut gint,
    ) -> *mut proto_item;
}
extern "C" {
    pub fn proto_tree_add_item_ret_boolean(
        tree: *mut proto_tree,
        hfindex: ::std::os::raw::c_int,
        tvb: *mut tvbuff_t,
        start: gint,
        length: gint,
        encoding: guint,
        retval: *mut gboolean,
    ) -> *mut proto_item;
}
extern "C" {
    pub fn proto_tree_add_item_ret_ipv4(
        tree: *mut proto_tree,
        hfindex: ::std::os::raw::c_int,
        tvb: *mut tvbuff_t,
        start: gint,
        length: gint,
        encoding: guint,
        retval: *mut ws_in4_addr,
    ) -> *mut proto_item;
}
extern "C" {
    #[doc = " @brief Parse an ipv6 address from the buffer and add it to the tree,\n writing the value to the pointer specified by the caller. The pointer\n must not be null.\n\n @param tree the tree\n @param hfindex the field\n @param tvb the tv buffer\n @param start the start index of data in tvb\n @param length the length of data. calls REPORT_DISSECTOR_BUG if not equal to FT_IPv6_LEN\n @param encoding encodings not yet supported. calls REPORT_DISSECTOR_BUG if not equal to 0\n @param retval where the address should be written, must not be null\n @return the newly created item"]
    pub fn proto_tree_add_item_ret_ipv6(
        tree: *mut proto_tree,
        hfindex: ::std::os::raw::c_int,
        tvb: *mut tvbuff_t,
        start: gint,
        length: gint,
        encoding: guint,
        retval: *mut ws_in6_addr,
    ) -> *mut proto_item;
}
extern "C" {
    #[doc = " @brief Parse an ethernet address from the buffer and add it to the tree,\n writing the value to the pointer specified by the caller. The pointer\n must not be null.\n\n @param tree the tree\n @param hfindex the field\n @param tvb the tv buffer\n @param start the start index of data in tvb\n @param length the length of data. calls REPORT_DISSECTOR_BUG if not equal to FT_ETHER_LEN\n @param encoding encodings not yet supported. calls REPORT_DISSECTOR_BUG if not equal to 0\n @param retval a buffer of at least FT_ETHER_LEN bytes for the address, must not be null\n @return the newly created item"]
    pub fn proto_tree_add_item_ret_ether(
        tree: *mut proto_tree,
        hfindex: ::std::os::raw::c_int,
        tvb: *mut tvbuff_t,
        start: gint,
        length: gint,
        encoding: guint,
        retval: *mut guint8,
    ) -> *mut proto_item;
}
extern "C" {
    #[doc = " @brief Parse a float from the buffer and add it to the tree,\n returning the item added and the parsed value via retval.\n\n @param tree the tree\n @param hfindex the field\n @param tvb the tv buffer\n @param start start index of data in tvb\n @param length the length of data. calls REPORT_DISSECTOR_BUG if not equal to 4\n @param encoding ENC_LITTLE_ENDIAN or ENC_BIG_ENDIAN\n @param[out] retval for the decoded value\n @return the newly created item"]
    pub fn proto_tree_add_item_ret_float(
        tree: *mut proto_tree,
        hfindex: ::std::os::raw::c_int,
        tvb: *mut tvbuff_t,
        start: gint,
        length: gint,
        encoding: guint,
        retval: *mut gfloat,
    ) -> *mut proto_item;
}
extern "C" {
    #[doc = " @brief Parse a double from the buffer and add it to the tree,\n returning the item added and the parsed value via retval\n\n @param tree the tree\n @param hfindex the field\n @param tvb the tv buffer\n @param start start index of data in tvb\n @param length length of data. calls REPORT_DISSECTOR_BUG if not equal to 8\n @param encoding ENC_LITTLE_ENDIAN or ENC_BIG_ENDIAN\n @param[out] retval for the decoded value\n @return the newly created item and retval is set to the decoded value"]
    pub fn proto_tree_add_item_ret_double(
        tree: *mut proto_tree,
        hfindex: ::std::os::raw::c_int,
        tvb: *mut tvbuff_t,
        start: gint,
        length: gint,
        encoding: guint,
        retval: *mut gdouble,
    ) -> *mut proto_item;
}
extern "C" {
    #[doc = " Add an string item to a proto_tree, using the text label registered to\nthat item.\n\nThe item is extracted from the tvbuff handed to it, and the retrieved\nvalue and its length are returned through pointers so the caller can use\nthem.  The value is allocated using the wmem scope passed in.\n\nThis function retrieves the value and length even if the passed-in tree\nparam is NULL, so that then can be used by dissectors at all times to\nboth get the value and set the tree item to it.\n\nLike other proto_tree_add functions, if there is a tree and the value cannot\nbe decoded from the tvbuff, then an expert info error is reported.\n\nThis function accepts string encodings.\n\n@param scope the wmem scope to use to allocate the string\n@param tree the tree to append this item to\n@param hfindex field\n@param tvb the tv buffer of the current data\n@param start start of data in tvb (cannot be negative)\n@param length length of data in tvb (for strings can be -1 for remaining)\n@param encoding data encoding (e.g, ENC_ASCII, ENC_UTF_8, etc.)\n@param[out] retval points to a guint8 * that will be set to point to the\nstring value\n@param[out] lenretval points to a gint that will be set to the item length\n@return the newly created item, *retval is set to the decoded value,\nand *lenretval is set to the item length"]
    pub fn proto_tree_add_item_ret_string_and_length(
        tree: *mut proto_tree,
        hfindex: ::std::os::raw::c_int,
        tvb: *mut tvbuff_t,
        start: gint,
        length: gint,
        encoding: guint,
        scope: *mut wmem_allocator_t,
        retval: *mut *const guint8,
        lenretval: *mut gint,
    ) -> *mut proto_item;
}
extern "C" {
    #[doc = " Add an string item to a proto_tree, using the text label registered to\nthat item.\n\nThe item is extracted from the tvbuff handed to it, and the retrieved\nvalue is returned through a pointer so the caller can use it.  The value\nis allocated using the wmem scope passed in.\n\nThis function retrieves the value even if the passed-in tree param is NULL,\nso that it can be used by dissectors at all times to both get the value\nand set the tree item to it.\n\nLike other proto_tree_add functions, if there is a tree and the value cannot\nbe decoded from the tvbuff, then an expert info error is reported.\n\nThis function accepts string encodings.\n\n@param scope the wmem scope to use to allocate the string\n@param tree the tree to append this item to\n@param hfindex field\n@param tvb the tv buffer of the current data\n@param start start of data in tvb (cannot be negative)\n@param length length of data in tvb (for strings can be -1 for remaining)\n@param encoding data encoding (e.g, ENC_ASCII, ENC_UTF_8, etc.)\n@param[out] retval points to a guint8 * that will be set to point to the\nstring value\n@return the newly created item, and *retval is set to the decoded value"]
    pub fn proto_tree_add_item_ret_string(
        tree: *mut proto_tree,
        hfindex: ::std::os::raw::c_int,
        tvb: *mut tvbuff_t,
        start: gint,
        length: gint,
        encoding: guint,
        scope: *mut wmem_allocator_t,
        retval: *mut *const guint8,
    ) -> *mut proto_item;
}
extern "C" {
    #[doc = " Add an string or byte array item to a proto_tree, using the\ntext label registered to that item.\n\nThis provides a string that is a display representation of the value,\nand the length of the item, similar to what\nproto_tree_add_item_ret_string_and_length() does.\n\n@param scope the wmem scope to use to allocate the string\n@param tree the tree to append this item to\n@param hfindex field\n@param tvb the tv buffer of the current data\n@param start start of data in tvb (cannot be negative)\n@param length length of data in tvb (for strings can be -1 for remaining)\n@param encoding data encoding (e.g, ENC_ASCII, ENC_UTF_8, etc.)\n@param[out] retval points to a guint8 * that will be set to point to the\nstring value\n@param[out] lenretval points to a gint that will be set to the item length\n@return the newly created item, *retval is set to the display string,\nand *lenretval is set to the item length"]
    pub fn proto_tree_add_item_ret_display_string_and_length(
        tree: *mut proto_tree,
        hfindex: ::std::os::raw::c_int,
        tvb: *mut tvbuff_t,
        start: gint,
        length: gint,
        encoding: guint,
        scope: *mut wmem_allocator_t,
        retval: *mut *mut ::std::os::raw::c_char,
        lenretval: *mut gint,
    ) -> *mut proto_item;
}
extern "C" {
    #[doc = " Add an string or byte array item to a proto_tree, using the\ntext label registered to that item.\n\nThis provides a string that is a display representation of the value,\nsimilar to what proto_tree_add_item_ret_string() does.\n\n@param tree the tree to append this item to\n@param hfindex field\n@param tvb the tv buffer of the current data\n@param start start of data in tvb (cannot be negative)\n@param length length of data in tvb (for strings can be -1 for remaining)\n@param encoding data encoding (e.g, ENC_ASCII, ENC_UTF_8, etc.)\n@param scope the wmem scope to use to allocate the string\n@param[out] retval points to a guint8 * that will be set to point to the\nstring value\n@return the newly created item, *retval is set to the display string"]
    pub fn proto_tree_add_item_ret_display_string(
        tree: *mut proto_tree,
        hfindex: ::std::os::raw::c_int,
        tvb: *mut tvbuff_t,
        start: gint,
        length: gint,
        encoding: guint,
        scope: *mut wmem_allocator_t,
        retval: *mut *mut ::std::os::raw::c_char,
    ) -> *mut proto_item;
}
extern "C" {
    #[doc = " Add a time item to a proto_tree, using thetext label registered to that item.\n\nThis provides a string that is a display representation of the time value\n\n@param tree the tree to append this item to\n@param hfindex field\n@param tvb the tv buffer of the current data\n@param start start of data in tvb (cannot be negative)\n@param length length of data in tvb (for strings can be -1 for remaining)\n@param encoding data encoding (e.g, ENC_ASCII, ENC_UTF_8, etc.)\n@param scope the wmem scope to use to allocate the string\n@param[out] retval points to a guint8 * that will be set to point to the\nstring value\n@return the newly created item, *retval is set to the display string"]
    pub fn proto_tree_add_item_ret_time_string(
        tree: *mut proto_tree,
        hfindex: ::std::os::raw::c_int,
        tvb: *mut tvbuff_t,
        start: gint,
        length: gint,
        encoding: guint,
        scope: *mut wmem_allocator_t,
        retval: *mut *mut ::std::os::raw::c_char,
    ) -> *mut proto_item;
}
extern "C" {
    #[doc = " (INTERNAL USE ONLY) Add a text-only node to a proto_tree.\n@param tree the tree to append this item to\n@param tvb the tv buffer of the current data\n@param start start of data in tvb\n@param length length of data in tvb\n@param format printf like format string\n@param ... printf like parameters\n@return the newly created item"]
    pub fn proto_tree_add_text_internal(
        tree: *mut proto_tree,
        tvb: *mut tvbuff_t,
        start: gint,
        length: gint,
        format: *const ::std::os::raw::c_char,
        ...
    ) -> *mut proto_item;
}
extern "C" {
    #[doc = " (INTERNAL USE ONLY) Add a text-only node to a proto_tree using a variable argument list.\n@param tree the tree to append this item to\n@param tvb the tv buffer of the current data\n@param start start of data in tvb\n@param length length of data in tvb\n@param format printf like format string\n@param ap variable argument list\n@return the newly created item"]
    pub fn proto_tree_add_text_valist_internal(
        tree: *mut proto_tree,
        tvb: *mut tvbuff_t,
        start: gint,
        length: gint,
        format: *const ::std::os::raw::c_char,
        ap: *mut __va_list_tag,
    ) -> *mut proto_item;
}
extern "C" {
    #[doc = " Add a text-only node that creates a subtree underneath.\n@param tree the tree to append this item to\n@param tvb the tv buffer of the current data\n@param start start of data in tvb\n@param length length of data in tvb\n@param idx one of the ett_ array elements registered with proto_register_subtree_array()\n@param tree_item item returned with tree creation. Can be NULL if going to be unused\n@param text label for the tree\n@return the newly created tree"]
    pub fn proto_tree_add_subtree(
        tree: *mut proto_tree,
        tvb: *mut tvbuff_t,
        start: gint,
        length: gint,
        idx: gint,
        tree_item: *mut *mut proto_item,
        text: *const ::std::os::raw::c_char,
    ) -> *mut proto_tree;
}
extern "C" {
    #[doc = " Add a text-only node that creates a subtree underneath.\n@param tree the tree to append this item to\n@param tvb the tv buffer of the current data\n@param start start of data in tvb\n@param length length of data in tvb\n@param idx one of the ett_ array elements registered with proto_register_subtree_array()\n@param tree_item item returned with tree creation. Can be NULL if going to be unused\n@param format printf like format string\n@param ... printf like parameters\n@return the newly created tree"]
    pub fn proto_tree_add_subtree_format(
        tree: *mut proto_tree,
        tvb: *mut tvbuff_t,
        start: gint,
        length: gint,
        idx: gint,
        tree_item: *mut *mut proto_item,
        format: *const ::std::os::raw::c_char,
        ...
    ) -> *mut proto_tree;
}
extern "C" {
    #[doc = " Add a text-only node to a proto_tree with tvb_format_text() string."]
    pub fn proto_tree_add_format_text(
        tree: *mut proto_tree,
        tvb: *mut tvbuff_t,
        start: gint,
        length: gint,
    ) -> *mut proto_item;
}
extern "C" {
    #[doc = " Add a text-only node to a proto_tree with tvb_format_text_wsp() string."]
    pub fn proto_tree_add_format_wsp_text(
        tree: *mut proto_tree,
        tvb: *mut tvbuff_t,
        start: gint,
        length: gint,
    ) -> *mut proto_item;
}
extern "C" {
    #[doc = " Add a FT_NONE field to a proto_tree.\n@param tree the tree to append this item to\n@param hfindex field index\n@param tvb the tv buffer of the current data\n@param start start of data in tvb\n@param length length of data in tvb\n@param format printf like format string\n@param ... printf like parameters\n@return the newly created item"]
    pub fn proto_tree_add_none_format(
        tree: *mut proto_tree,
        hfindex: ::std::os::raw::c_int,
        tvb: *mut tvbuff_t,
        start: gint,
        length: gint,
        format: *const ::std::os::raw::c_char,
        ...
    ) -> *mut proto_item;
}
extern "C" {
    #[doc = " Add a FT_PROTOCOL to a proto_tree.\n@param tree the tree to append this item to\n@param hfindex field index\n@param tvb the tv buffer of the current data\n@param start start of data in tvb\n@param length length of data in tvb\n@param format printf like format string\n@param ... printf like parameters\n@return the newly created item"]
    pub fn proto_tree_add_protocol_format(
        tree: *mut proto_tree,
        hfindex: ::std::os::raw::c_int,
        tvb: *mut tvbuff_t,
        start: gint,
        length: gint,
        format: *const ::std::os::raw::c_char,
        ...
    ) -> *mut proto_item;
}
extern "C" {
    #[doc = " Add a FT_BYTES to a proto_tree.\n@param tree the tree to append this item to\n@param hfindex field index\n@param tvb the tv buffer of the current data\n@param start start of data in tvb\n@param length length of data in tvb\n@param start_ptr pointer to the data to display\n@return the newly created item"]
    pub fn proto_tree_add_bytes(
        tree: *mut proto_tree,
        hfindex: ::std::os::raw::c_int,
        tvb: *mut tvbuff_t,
        start: gint,
        length: gint,
        start_ptr: *const guint8,
    ) -> *mut proto_item;
}
extern "C" {
    #[doc = " Add a FT_BYTES to a proto_tree like proto_tree_add_bytes,\nbut used when the tvb data length does not match the bytes length.\n@param tree the tree to append this item to\n@param hfindex field index\n@param tvb the tv buffer of the current data\n@param start start of data in tvb\n@param length length of data in tvb\n@param start_ptr pointer to the data to display\n@param ptr_length length of data in start_ptr\n@return the newly created item"]
    pub fn proto_tree_add_bytes_with_length(
        tree: *mut proto_tree,
        hfindex: ::std::os::raw::c_int,
        tvb: *mut tvbuff_t,
        start: gint,
        length: gint,
        start_ptr: *const guint8,
        ptr_length: gint,
    ) -> *mut proto_item;
}
extern "C" {
    #[doc = " Get and add a byte-array-based FT_* to a proto_tree.\n\nSupported: FT_BYTES, FT_UINT_BYTES, FT_OID, FT_REL_OID, and FT_SYSTEM_ID.\n\nThe item is extracted from the tvbuff handed to it, based on the ENC_* passed\nin for the encoding, and the retrieved byte array is also set to *retval so the\ncaller gets it back for other uses.\n\nThis function retrieves the value even if the passed-in tree param is NULL,\nso that it can be used by dissectors at all times to both get the value\nand set the tree item to it.\n\nLike other proto_tree_add functions, if there is a tree and the value cannot\nbe decoded from the tvbuff, then an expert info error is reported. For string\nencoding, this means that a failure to decode the hex value from the string\nresults in an expert info error being added to the tree.\n\nIf encoding is string-based, it will convert using tvb_get_string_bytes(); see\nthat function's comments for details.\n\n@note The GByteArray retval must be pre-constructed using g_byte_array_new().\n\n@param tree the tree to append this item to\n@param hfindex field index\n@param tvb the tv buffer of the current data\n@param start start of data in tvb\n@param length length of data in tvb\n@param encoding data encoding (e.g, ENC_LITTLE_ENDIAN, or ENC_UTF_8|ENC_STR_HEX)\n@param[in,out] retval points to a GByteArray which will be set to the bytes from the Tvb.\n@param[in,out] endoff if not NULL, gets set to the character after those consumed.\n@param[in,out] err if not NULL, gets set to 0 if no failure, else the errno code (e.g., EINVAL).\n@return the newly created item, and retval is set to the decoded value"]
    pub fn proto_tree_add_bytes_item(
        tree: *mut proto_tree,
        hfindex: ::std::os::raw::c_int,
        tvb: *mut tvbuff_t,
        start: gint,
        length: gint,
        encoding: guint,
        retval: *mut GByteArray,
        endoff: *mut gint,
        err: *mut gint,
    ) -> *mut proto_item;
}
extern "C" {
    #[doc = " Add a formatted FT_BYTES to a proto_tree, with the format generating\nthe string for the value and with the field name being included\nautomatically.\n@param tree the tree to append this item to\n@param hfindex field index\n@param tvb the tv buffer of the current data\n@param start start of data in tvb\n@param length length of data in tvb\n@param start_ptr pointer to the data to display\n@param format printf like format string\n@param ... printf like parameters\n@return the newly created item"]
    pub fn proto_tree_add_bytes_format_value(
        tree: *mut proto_tree,
        hfindex: ::std::os::raw::c_int,
        tvb: *mut tvbuff_t,
        start: gint,
        length: gint,
        start_ptr: *const guint8,
        format: *const ::std::os::raw::c_char,
        ...
    ) -> *mut proto_item;
}
extern "C" {
    #[doc = " Add a formatted FT_BYTES to a proto_tree, with the format generating\nthe entire string for the entry, including any field name.\n@param tree the tree to append this item to\n@param hfindex field index\n@param tvb the tv buffer of the current data\n@param start start of data in tvb\n@param length length of data in tvb\n@param start_ptr pointer to the data to display\n@param format printf like format string\n@param ... printf like parameters\n@return the newly created item"]
    pub fn proto_tree_add_bytes_format(
        tree: *mut proto_tree,
        hfindex: ::std::os::raw::c_int,
        tvb: *mut tvbuff_t,
        start: gint,
        length: gint,
        start_ptr: *const guint8,
        format: *const ::std::os::raw::c_char,
        ...
    ) -> *mut proto_item;
}
extern "C" {
    #[doc = " Add a FT_ABSOLUTE_TIME or FT_RELATIVE_TIME to a proto_tree.\n@param tree the tree to append this item to\n@param hfindex field index\n@param tvb the tv buffer of the current data\n@param start start of data in tvb\n@param length length of data in tvb\n@param value_ptr pointer to the data to display\n@return the newly created item"]
    pub fn proto_tree_add_time(
        tree: *mut proto_tree,
        hfindex: ::std::os::raw::c_int,
        tvb: *mut tvbuff_t,
        start: gint,
        length: gint,
        value_ptr: *const nstime_t,
    ) -> *mut proto_item;
}
extern "C" {
    #[doc = " Get and add a FT_ABSOLUTE_TIME or FT_RELATIVE_TIME to a proto_tree.\nThe item is extracted from the tvbuff handed to it, based on the ENC_* passed\nin for the encoding, and the retrieved value is also set to *retval so the\ncaller gets it back for other uses.\n\nThis function retrieves the value even if the passed-in tree param is NULL,\nso that it can be used by dissectors at all times to both get the value\nand set the tree item to it.\n\nLike other proto_tree_add functions, if there is a tree and the value cannot\nbe decoded from the tvbuff, then an expert info error is reported. For string\nencoding, this means that a failure to decode the time value from the string\nresults in an expert info error being added to the tree.\n\nIf encoding is string-based, it will convert using tvb_get_string_time(); see\nthat function's comments for details.\n\n@note The nstime_t *retval must be pre-allocated as a nstime_t.\n\n@param tree the tree to append this item to\n@param hfindex field index\n@param tvb the tv buffer of the current data\n@param start start of data in tvb\n@param length length of data in tvb\n@param encoding data encoding (e.g, ENC_LITTLE_ENDIAN, ENC_UTF_8|ENC_ISO_8601_DATE_TIME, etc.)\n@param[in,out] retval points to a nstime_t which will be set to the value\n@param[in,out] endoff if not NULL, gets set to the character after those consumed.\n@param[in,out] err if not NULL, gets set to 0 if no failure, else EINVAL.\n@return the newly created item, and retval is set to the decoded value"]
    pub fn proto_tree_add_time_item(
        tree: *mut proto_tree,
        hfindex: ::std::os::raw::c_int,
        tvb: *mut tvbuff_t,
        start: gint,
        length: gint,
        encoding: guint,
        retval: *mut nstime_t,
        endoff: *mut gint,
        err: *mut gint,
    ) -> *mut proto_item;
}
extern "C" {
    #[doc = " Add a formatted FT_ABSOLUTE_TIME or FT_RELATIVE_TIME to a proto_tree, with\nthe format generating the string for the value and with the field name\nbeing included automatically.\n@param tree the tree to append this item to\n@param hfindex field index\n@param tvb the tv buffer of the current data\n@param start start of data in tvb\n@param length length of data in tvb\n@param value_ptr pointer to the data to display\n@param format printf like format string\n@param ... printf like parameters\n@return the newly created item"]
    pub fn proto_tree_add_time_format_value(
        tree: *mut proto_tree,
        hfindex: ::std::os::raw::c_int,
        tvb: *mut tvbuff_t,
        start: gint,
        length: gint,
        value_ptr: *mut nstime_t,
        format: *const ::std::os::raw::c_char,
        ...
    ) -> *mut proto_item;
}
extern "C" {
    #[doc = " Add a formatted FT_ABSOLUTE_TIME or FT_RELATIVE_TIME to a proto_tree, with\nthe format generating the entire string for the entry, including any field\nname.\n@param tree the tree to append this item to\n@param hfindex field index\n@param tvb the tv buffer of the current data\n@param start start of data in tvb\n@param length length of data in tvb\n@param value_ptr pointer to the data to display\n@param format printf like format string\n@param ... printf like parameters\n@return the newly created item"]
    pub fn proto_tree_add_time_format(
        tree: *mut proto_tree,
        hfindex: ::std::os::raw::c_int,
        tvb: *mut tvbuff_t,
        start: gint,
        length: gint,
        value_ptr: *mut nstime_t,
        format: *const ::std::os::raw::c_char,
        ...
    ) -> *mut proto_item;
}
extern "C" {
    #[doc = " Add a FT_IPXNET to a proto_tree.\n@param tree the tree to append this item to\n@param hfindex field index\n@param tvb the tv buffer of the current data\n@param start start of data in tvb\n@param length length of data in tvb\n@param value data to display\n@return the newly created item"]
    pub fn proto_tree_add_ipxnet(
        tree: *mut proto_tree,
        hfindex: ::std::os::raw::c_int,
        tvb: *mut tvbuff_t,
        start: gint,
        length: gint,
        value: guint32,
    ) -> *mut proto_item;
}
extern "C" {
    #[doc = " Add a formatted FT_IPXNET to a proto_tree, with the format generating\nthe string for the value and with the field name being included\nautomatically.\n@param tree the tree to append this item to\n@param hfindex field index\n@param tvb the tv buffer of the current data\n@param start start of data in tvb\n@param length length of data in tvb\n@param value data to display\n@param format printf like format string\n@param ... printf like parameters\n@return the newly created item"]
    pub fn proto_tree_add_ipxnet_format_value(
        tree: *mut proto_tree,
        hfindex: ::std::os::raw::c_int,
        tvb: *mut tvbuff_t,
        start: gint,
        length: gint,
        value: guint32,
        format: *const ::std::os::raw::c_char,
        ...
    ) -> *mut proto_item;
}
extern "C" {
    #[doc = " Add a formatted FT_IPXNET to a proto_tree, with the format generating\nthe entire string for the entry, including any field name.\n@param tree the tree to append this item to\n@param hfindex field index\n@param tvb the tv buffer of the current data\n@param start start of data in tvb\n@param length length of data in tvb\n@param value data to display\n@param format printf like format string\n@param ... printf like parameters\n@return the newly created item"]
    pub fn proto_tree_add_ipxnet_format(
        tree: *mut proto_tree,
        hfindex: ::std::os::raw::c_int,
        tvb: *mut tvbuff_t,
        start: gint,
        length: gint,
        value: guint32,
        format: *const ::std::os::raw::c_char,
        ...
    ) -> *mut proto_item;
}
extern "C" {
    #[doc = " Add a FT_IPv4 to a proto_tree.\n@param tree the tree to append this item to\n@param hfindex field index\n@param tvb the tv buffer of the current data\n@param start start of data in tvb\n@param length length of data in tvb\n@param value data to display\n@return the newly created item"]
    pub fn proto_tree_add_ipv4(
        tree: *mut proto_tree,
        hfindex: ::std::os::raw::c_int,
        tvb: *mut tvbuff_t,
        start: gint,
        length: gint,
        value: ws_in4_addr,
    ) -> *mut proto_item;
}
extern "C" {
    #[doc = " Add a formatted FT_IPv4 to a proto_tree, with the format generating\nthe string for the value and with the field name being included\nautomatically.\n@param tree the tree to append this item to\n@param hfindex field index\n@param tvb the tv buffer of the current data\n@param start start of data in tvb\n@param length length of data in tvb\n@param value data to display\n@param format printf like format string\n@param ... printf like parameters\n@return the newly created item"]
    pub fn proto_tree_add_ipv4_format_value(
        tree: *mut proto_tree,
        hfindex: ::std::os::raw::c_int,
        tvb: *mut tvbuff_t,
        start: gint,
        length: gint,
        value: ws_in4_addr,
        format: *const ::std::os::raw::c_char,
        ...
    ) -> *mut proto_item;
}
extern "C" {
    #[doc = " Add a formatted FT_IPv4 to a proto_tree, with the format generating\nthe entire string for the entry, including any field name.\n@param tree the tree to append this item to\n@param hfindex field index\n@param tvb the tv buffer of the current data\n@param start start of data in tvb\n@param length length of data in tvb\n@param value data to display\n@param format printf like format string\n@param ... printf like parameters\n@return the newly created item"]
    pub fn proto_tree_add_ipv4_format(
        tree: *mut proto_tree,
        hfindex: ::std::os::raw::c_int,
        tvb: *mut tvbuff_t,
        start: gint,
        length: gint,
        value: ws_in4_addr,
        format: *const ::std::os::raw::c_char,
        ...
    ) -> *mut proto_item;
}
extern "C" {
    #[doc = " Add a FT_IPv6 to a proto_tree.\n@param tree the tree to append this item to\n@param hfindex field index\n@param tvb the tv buffer of the current data\n@param start start of data in tvb\n@param length length of data in tvb\n@param value_ptr data to display\n@return the newly created item"]
    pub fn proto_tree_add_ipv6(
        tree: *mut proto_tree,
        hfindex: ::std::os::raw::c_int,
        tvb: *mut tvbuff_t,
        start: gint,
        length: gint,
        value_ptr: *const ws_in6_addr,
    ) -> *mut proto_item;
}
extern "C" {
    #[doc = " Add a formatted FT_IPv6 to a proto_tree, with the format generating\nthe string for the value and with the field name being included\nautomatically.\n@param tree the tree to append this item to\n@param hfindex field index\n@param tvb the tv buffer of the current data\n@param start start of data in tvb\n@param length length of data in tvb\n@param value_ptr data to display\n@param format printf like format string\n@param ... printf like parameters\n@return the newly created item"]
    pub fn proto_tree_add_ipv6_format_value(
        tree: *mut proto_tree,
        hfindex: ::std::os::raw::c_int,
        tvb: *mut tvbuff_t,
        start: gint,
        length: gint,
        value_ptr: *const ws_in6_addr,
        format: *const ::std::os::raw::c_char,
        ...
    ) -> *mut proto_item;
}
extern "C" {
    #[doc = " Add a formatted FT_IPv6 to a proto_tree, with the format generating\nthe entire string for the entry, including any field name.\n@param tree the tree to append this item to\n@param hfindex field index\n@param tvb the tv buffer of the current data\n@param start start of data in tvb\n@param length length of data in tvb\n@param value_ptr data to display\n@param format printf like format string\n@param ... printf like parameters\n@return the newly created item"]
    pub fn proto_tree_add_ipv6_format(
        tree: *mut proto_tree,
        hfindex: ::std::os::raw::c_int,
        tvb: *mut tvbuff_t,
        start: gint,
        length: gint,
        value_ptr: *const ws_in6_addr,
        format: *const ::std::os::raw::c_char,
        ...
    ) -> *mut proto_item;
}
extern "C" {
    #[doc = " Add a FT_ETHER to a proto_tree.\n@param tree the tree to append this item to\n@param hfindex field index\n@param tvb the tv buffer of the current data\n@param start start of data in tvb\n@param length length of data in tvb\n@param value data to display\n@return the newly created item"]
    pub fn proto_tree_add_ether(
        tree: *mut proto_tree,
        hfindex: ::std::os::raw::c_int,
        tvb: *mut tvbuff_t,
        start: gint,
        length: gint,
        value: *const guint8,
    ) -> *mut proto_item;
}
extern "C" {
    #[doc = " Add a formatted FT_ETHER to a proto_tree, with the format generating\nthe string for the value and with the field name being included\nautomatically.\n@param tree the tree to append this item to\n@param hfindex field index\n@param tvb the tv buffer of the current data\n@param start start of data in tvb\n@param length length of data in tvb\n@param value data to display\n@param format printf like format string\n@param ... printf like parameters\n@return the newly created item"]
    pub fn proto_tree_add_ether_format_value(
        tree: *mut proto_tree,
        hfindex: ::std::os::raw::c_int,
        tvb: *mut tvbuff_t,
        start: gint,
        length: gint,
        value: *const guint8,
        format: *const ::std::os::raw::c_char,
        ...
    ) -> *mut proto_item;
}
extern "C" {
    #[doc = " Add a formatted FT_ETHER to a proto_tree, with the format generating\nthe entire string for the entry, including any field name.\n@param tree the tree to append this item to\n@param hfindex field index\n@param tvb the tv buffer of the current data\n@param start start of data in tvb\n@param length length of data in tvb\n@param value data to display\n@param format printf like format string\n@param ... printf like parameters\n@return the newly created item"]
    pub fn proto_tree_add_ether_format(
        tree: *mut proto_tree,
        hfindex: ::std::os::raw::c_int,
        tvb: *mut tvbuff_t,
        start: gint,
        length: gint,
        value: *const guint8,
        format: *const ::std::os::raw::c_char,
        ...
    ) -> *mut proto_item;
}
extern "C" {
    #[doc = " Add a FT_GUID to a proto_tree.\n@param tree the tree to append this item to\n@param hfindex field index\n@param tvb the tv buffer of the current data\n@param start start of data in tvb\n@param length length of data in tvb\n@param value_ptr data to display\n@return the newly created item"]
    pub fn proto_tree_add_guid(
        tree: *mut proto_tree,
        hfindex: ::std::os::raw::c_int,
        tvb: *mut tvbuff_t,
        start: gint,
        length: gint,
        value_ptr: *const e_guid_t,
    ) -> *mut proto_item;
}
extern "C" {
    #[doc = " Add a formatted FT_GUID to a proto_tree, with the format generating\nthe string for the value and with the field name being included\nautomatically.\n@param tree the tree to append this item to\n@param hfindex field index\n@param tvb the tv buffer of the current data\n@param start start of data in tvb\n@param length length of data in tvb\n@param value_ptr data to display\n@param format printf like format string\n@param ... printf like parameters\n@return the newly created item"]
    pub fn proto_tree_add_guid_format_value(
        tree: *mut proto_tree,
        hfindex: ::std::os::raw::c_int,
        tvb: *mut tvbuff_t,
        start: gint,
        length: gint,
        value_ptr: *const e_guid_t,
        format: *const ::std::os::raw::c_char,
        ...
    ) -> *mut proto_item;
}
extern "C" {
    #[doc = " Add a formatted FT_GUID to a proto_tree, with the format generating\nthe entire string for the entry, including any field name.\n@param tree the tree to append this item to\n@param hfindex field index\n@param tvb the tv buffer of the current data\n@param start start of data in tvb\n@param length length of data in tvb\n@param value_ptr data to display\n@param format printf like format string\n@param ... printf like parameters\n@return the newly created item"]
    pub fn proto_tree_add_guid_format(
        tree: *mut proto_tree,
        hfindex: ::std::os::raw::c_int,
        tvb: *mut tvbuff_t,
        start: gint,
        length: gint,
        value_ptr: *const e_guid_t,
        format: *const ::std::os::raw::c_char,
        ...
    ) -> *mut proto_item;
}
extern "C" {
    #[doc = " Add a FT_OID to a proto_tree.\n@param tree the tree to append this item to\n@param hfindex field index\n@param tvb the tv buffer of the current data\n@param start start of data in tvb\n@param length length of data in tvb\n@param value_ptr data to display\n@return the newly created item"]
    pub fn proto_tree_add_oid(
        tree: *mut proto_tree,
        hfindex: ::std::os::raw::c_int,
        tvb: *mut tvbuff_t,
        start: gint,
        length: gint,
        value_ptr: *const guint8,
    ) -> *mut proto_item;
}
extern "C" {
    #[doc = " Add a formatted FT_OID to a proto_tree, with the format generating\nthe string for the value and with the field name being included\nautomatically.\n@param tree the tree to append this item to\n@param hfindex field index\n@param tvb the tv buffer of the current data\n@param start start of data in tvb\n@param length length of data in tvb\n@param value_ptr data to display\n@param format printf like format string\n@param ... printf like parameters\n@return the newly created item"]
    pub fn proto_tree_add_oid_format_value(
        tree: *mut proto_tree,
        hfindex: ::std::os::raw::c_int,
        tvb: *mut tvbuff_t,
        start: gint,
        length: gint,
        value_ptr: *const guint8,
        format: *const ::std::os::raw::c_char,
        ...
    ) -> *mut proto_item;
}
extern "C" {
    #[doc = " Add a formatted FT_OID to a proto_tree, with the format generating\nthe entire string for the entry, including any field name.\n@param tree the tree to append this item to\n@param hfindex field index\n@param tvb the tv buffer of the current data\n@param start start of data in tvb\n@param length length of data in tvb\n@param value_ptr data to display\n@param format printf like format string\n@param ... printf like parameters\n@return the newly created item"]
    pub fn proto_tree_add_oid_format(
        tree: *mut proto_tree,
        hfindex: ::std::os::raw::c_int,
        tvb: *mut tvbuff_t,
        start: gint,
        length: gint,
        value_ptr: *const guint8,
        format: *const ::std::os::raw::c_char,
        ...
    ) -> *mut proto_item;
}
extern "C" {
    #[doc = " Add an FT_STRING, FT_STRINGZ, FT_STRINGZPAD, or FT_STRINGZTRUNC to a\nproto_tree. The value passed in should be a UTF-8 encoded null terminated\nstring, such as produced by tvb_get_string_enc(), regardless of the original\npacket data.\n\nThis function is used to add a custom string *value* to the protocol tree.\nDo not format the string value for display, for example by using format_text().\nThe input string represents packet data, not a display label. Formatting\nlabels is a concern of the UI. Doing that here would change the meaning of the packet\ndata, restrict the options for formatting later and make display filtering unintuitive\nfor whitespace and other special characters.\n\n@param tree the tree to append this item to\n@param hfindex field index\n@param tvb the tv buffer of the current data\n@param start start of data in tvb\n@param length length of data in tvb\n@param value data to display\n@return the newly created item"]
    pub fn proto_tree_add_string(
        tree: *mut proto_tree,
        hfindex: ::std::os::raw::c_int,
        tvb: *mut tvbuff_t,
        start: gint,
        length: gint,
        value: *const ::std::os::raw::c_char,
    ) -> *mut proto_item;
}
extern "C" {
    #[doc = " Add a formatted FT_STRING, FT_STRINGZ, FT_STRINGZPAD, or FT_STRINGZTRUNC\nto a proto_tree, with the format generating the string for the value\nand with the field name being included automatically.\n@param tree the tree to append this item to\n@param hfindex field index\n@param tvb the tv buffer of the current data\n@param start start of data in tvb\n@param length length of data in tvb\n@param value data to display\n@param format printf like format string\n@param ... printf like parameters\n@return the newly created item"]
    pub fn proto_tree_add_string_format_value(
        tree: *mut proto_tree,
        hfindex: ::std::os::raw::c_int,
        tvb: *mut tvbuff_t,
        start: gint,
        length: gint,
        value: *const ::std::os::raw::c_char,
        format: *const ::std::os::raw::c_char,
        ...
    ) -> *mut proto_item;
}
extern "C" {
    #[doc = " Add a formatted FT_STRING, FT_STRINGZ, FT_STRINGZPAD, or FT_STRINGZTRUNC\nto a proto_tree, with the format generating the entire string for the\nentry, including any field name.\n@param tree the tree to append this item to\n@param hfindex field index\n@param tvb the tv buffer of the current data\n@param start start of data in tvb\n@param length length of data in tvb\n@param value data to display\n@param format printf like format string\n@param ... printf like parameters\n@return the newly created item"]
    pub fn proto_tree_add_string_format(
        tree: *mut proto_tree,
        hfindex: ::std::os::raw::c_int,
        tvb: *mut tvbuff_t,
        start: gint,
        length: gint,
        value: *const ::std::os::raw::c_char,
        format: *const ::std::os::raw::c_char,
        ...
    ) -> *mut proto_item;
}
extern "C" {
    #[doc = " Add a FT_BOOLEAN to a proto_tree.\n@param tree the tree to append this item to\n@param hfindex field index\n@param tvb the tv buffer of the current data\n@param start start of data in tvb\n@param length length of data in tvb\n@param value data to display\n@return the newly created item"]
    pub fn proto_tree_add_boolean(
        tree: *mut proto_tree,
        hfindex: ::std::os::raw::c_int,
        tvb: *mut tvbuff_t,
        start: gint,
        length: gint,
        value: guint32,
    ) -> *mut proto_item;
}
extern "C" {
    #[doc = " Add a formatted FT_BOOLEAN to a proto_tree, with the format generating\nthe string for the value and with the field name being included\nautomatically.\n@param tree the tree to append this item to\n@param hfindex field index\n@param tvb the tv buffer of the current data\n@param start start of data in tvb\n@param length length of data in tvb\n@param value data to display\n@param format printf like format string\n@param ... printf like parameters\n@return the newly created item"]
    pub fn proto_tree_add_boolean_format_value(
        tree: *mut proto_tree,
        hfindex: ::std::os::raw::c_int,
        tvb: *mut tvbuff_t,
        start: gint,
        length: gint,
        value: guint32,
        format: *const ::std::os::raw::c_char,
        ...
    ) -> *mut proto_item;
}
extern "C" {
    #[doc = " Add a formatted FT_BOOLEAN to a proto_tree, with the format generating\nthe entire string for the entry, including any field name.\n@param tree the tree to append this item to\n@param hfindex field index\n@param tvb the tv buffer of the current data\n@param start start of data in tvb\n@param length length of data in tvb\n@param value data to display\n@param format printf like format string\n@param ... printf like parameters\n@return the newly created item"]
    pub fn proto_tree_add_boolean_format(
        tree: *mut proto_tree,
        hfindex: ::std::os::raw::c_int,
        tvb: *mut tvbuff_t,
        start: gint,
        length: gint,
        value: guint32,
        format: *const ::std::os::raw::c_char,
        ...
    ) -> *mut proto_item;
}
extern "C" {
    #[doc = " Add a FT_FLOAT to a proto_tree.\n@param tree the tree to append this item to\n@param hfindex field index\n@param tvb the tv buffer of the current data\n@param start start of data in tvb\n@param length length of data in tvb\n@param value data to display\n@return the newly created item"]
    pub fn proto_tree_add_float(
        tree: *mut proto_tree,
        hfindex: ::std::os::raw::c_int,
        tvb: *mut tvbuff_t,
        start: gint,
        length: gint,
        value: f32,
    ) -> *mut proto_item;
}
extern "C" {
    #[doc = " Add a formatted FT_FLOAT to a proto_tree, with the format generating\nthe string for the value and with the field name being included\nautomatically.\n@param tree the tree to append this item to\n@param hfindex field index\n@param tvb the tv buffer of the current data\n@param start start of data in tvb\n@param length length of data in tvb\n@param value data to display\n@param format printf like format string\n@param ... printf like parameters\n@return the newly created item"]
    pub fn proto_tree_add_float_format_value(
        tree: *mut proto_tree,
        hfindex: ::std::os::raw::c_int,
        tvb: *mut tvbuff_t,
        start: gint,
        length: gint,
        value: f32,
        format: *const ::std::os::raw::c_char,
        ...
    ) -> *mut proto_item;
}
extern "C" {
    #[doc = " Add a formatted FT_FLOAT to a proto_tree, with the format generating\nthe entire string for the entry, including any field name.\n@param tree the tree to append this item to\n@param hfindex field index\n@param tvb the tv buffer of the current data\n@param start start of data in tvb\n@param length length of data in tvb\n@param value data to display\n@param format printf like format string\n@param ... printf like parameters\n@return the newly created item"]
    pub fn proto_tree_add_float_format(
        tree: *mut proto_tree,
        hfindex: ::std::os::raw::c_int,
        tvb: *mut tvbuff_t,
        start: gint,
        length: gint,
        value: f32,
        format: *const ::std::os::raw::c_char,
        ...
    ) -> *mut proto_item;
}
extern "C" {
    #[doc = " Add a FT_DOUBLE to a proto_tree.\n@param tree the tree to append this item to\n@param hfindex field index\n@param tvb the tv buffer of the current data\n@param start start of data in tvb\n@param length length of data in tvb\n@param value data to display\n@return the newly created item"]
    pub fn proto_tree_add_double(
        tree: *mut proto_tree,
        hfindex: ::std::os::raw::c_int,
        tvb: *mut tvbuff_t,
        start: gint,
        length: gint,
        value: f64,
    ) -> *mut proto_item;
}
extern "C" {
    #[doc = " Add a formatted FT_DOUBLE to a proto_tree, with the format generating\nthe string for the value and with the field name being included\nautomatically.\n@param tree the tree to append this item to\n@param hfindex field index\n@param tvb the tv buffer of the current data\n@param start start of data in tvb\n@param length length of data in tvb\n@param value data to display\n@param format printf like format string\n@param ... printf like parameters\n@return the newly created item"]
    pub fn proto_tree_add_double_format_value(
        tree: *mut proto_tree,
        hfindex: ::std::os::raw::c_int,
        tvb: *mut tvbuff_t,
        start: gint,
        length: gint,
        value: f64,
        format: *const ::std::os::raw::c_char,
        ...
    ) -> *mut proto_item;
}
extern "C" {
    #[doc = " Add a formatted FT_DOUBLE to a proto_tree, with the format generating\nthe entire string for the entry, including any field name.\n@param tree the tree to append this item to\n@param hfindex field index\n@param tvb the tv buffer of the current data\n@param start start of data in tvb\n@param length length of data in tvb\n@param value data to display\n@param format printf like format string\n@param ... printf like parameters\n@return the newly created item"]
    pub fn proto_tree_add_double_format(
        tree: *mut proto_tree,
        hfindex: ::std::os::raw::c_int,
        tvb: *mut tvbuff_t,
        start: gint,
        length: gint,
        value: f64,
        format: *const ::std::os::raw::c_char,
        ...
    ) -> *mut proto_item;
}
extern "C" {
    #[doc = " Add one of FT_UINT8, FT_UINT16, FT_UINT24 or FT_UINT32 to a proto_tree.\n@param tree the tree to append this item to\n@param hfindex field index\n@param tvb the tv buffer of the current data\n@param start start of data in tvb\n@param length length of data in tvb\n@param value data to display\n@return the newly created item"]
    pub fn proto_tree_add_uint(
        tree: *mut proto_tree,
        hfindex: ::std::os::raw::c_int,
        tvb: *mut tvbuff_t,
        start: gint,
        length: gint,
        value: guint32,
    ) -> *mut proto_item;
}
extern "C" {
    #[doc = " Add a formatted FT_UINT8, FT_UINT16, FT_UINT24 or FT_UINT32 to a proto_tree,\nwith the format generating the string for the value and with the field\nname being included automatically.\n@param tree the tree to append this item to\n@param hfindex field index\n@param tvb the tv buffer of the current data\n@param start start of data in tvb\n@param length length of data in tvb\n@param value data to display\n@param format printf like format string\n@param ... printf like parameters\n@return the newly created item"]
    pub fn proto_tree_add_uint_format_value(
        tree: *mut proto_tree,
        hfindex: ::std::os::raw::c_int,
        tvb: *mut tvbuff_t,
        start: gint,
        length: gint,
        value: guint32,
        format: *const ::std::os::raw::c_char,
        ...
    ) -> *mut proto_item;
}
extern "C" {
    #[doc = " Add a formatted FT_UINT8, FT_UINT16, FT_UINT24 or FT_UINT32 to a proto_tree,\nwith the format generating the entire string for the entry, including any\nfield name.\n@param tree the tree to append this item to\n@param hfindex field index\n@param tvb the tv buffer of the current data\n@param start start of data in tvb\n@param length length of data in tvb\n@param value data to display\n@param format printf like format string\n@param ... printf like parameters\n@return the newly created item"]
    pub fn proto_tree_add_uint_format(
        tree: *mut proto_tree,
        hfindex: ::std::os::raw::c_int,
        tvb: *mut tvbuff_t,
        start: gint,
        length: gint,
        value: guint32,
        format: *const ::std::os::raw::c_char,
        ...
    ) -> *mut proto_item;
}
extern "C" {
    #[doc = " Add an FT_UINT64 to a proto_tree.\n@param tree the tree to append this item to\n@param hfindex field index\n@param tvb the tv buffer of the current data\n@param start start of data in tvb\n@param length length of data in tvb\n@param value data to display\n@return the newly created item"]
    pub fn proto_tree_add_uint64(
        tree: *mut proto_tree,
        hfindex: ::std::os::raw::c_int,
        tvb: *mut tvbuff_t,
        start: gint,
        length: gint,
        value: guint64,
    ) -> *mut proto_item;
}
extern "C" {
    #[doc = " Add a formatted FT_UINT64 to a proto_tree, with the format generating\nthe string for the value and with the field name being included\nautomatically.\n@param tree the tree to append this item to\n@param hfindex field index\n@param tvb the tv buffer of the current data\n@param start start of data in tvb\n@param length length of data in tvb\n@param value data to display\n@param format printf like format string\n@param ... printf like parameters\n@return the newly created item"]
    pub fn proto_tree_add_uint64_format_value(
        tree: *mut proto_tree,
        hfindex: ::std::os::raw::c_int,
        tvb: *mut tvbuff_t,
        start: gint,
        length: gint,
        value: guint64,
        format: *const ::std::os::raw::c_char,
        ...
    ) -> *mut proto_item;
}
extern "C" {
    #[doc = " Add a formatted FT_UINT64 to a proto_tree, with the format generating\nthe entire string for the entry, including any field name.\n@param tree the tree to append this item to\n@param hfindex field index\n@param tvb the tv buffer of the current data\n@param start start of data in tvb\n@param length length of data in tvb\n@param value data to display\n@param format printf like format string\n@param ... printf like parameters\n@return the newly created item"]
    pub fn proto_tree_add_uint64_format(
        tree: *mut proto_tree,
        hfindex: ::std::os::raw::c_int,
        tvb: *mut tvbuff_t,
        start: gint,
        length: gint,
        value: guint64,
        format: *const ::std::os::raw::c_char,
        ...
    ) -> *mut proto_item;
}
extern "C" {
    #[doc = " Add one of FT_INT8, FT_INT16, FT_INT24 or FT_INT32 to a proto_tree.\n@param tree the tree to append this item to\n@param hfindex field index\n@param tvb the tv buffer of the current data\n@param start start of data in tvb\n@param length length of data in tvb\n@param value data to display\n@return the newly created item"]
    pub fn proto_tree_add_int(
        tree: *mut proto_tree,
        hfindex: ::std::os::raw::c_int,
        tvb: *mut tvbuff_t,
        start: gint,
        length: gint,
        value: gint32,
    ) -> *mut proto_item;
}
extern "C" {
    #[doc = " Add a formatted FT_INT8, FT_INT16, FT_INT24 or FT_INT32 to a proto_tree,\nwith the format generating the string for the value and with the field\nname being included automatically.\n@param tree the tree to append this item to\n@param hfindex field index\n@param tvb the tv buffer of the current data\n@param start start of data in tvb\n@param length length of data in tvb\n@param value data to display\n@param format printf like format string\n@param ... printf like parameters\n@return the newly created item"]
    pub fn proto_tree_add_int_format_value(
        tree: *mut proto_tree,
        hfindex: ::std::os::raw::c_int,
        tvb: *mut tvbuff_t,
        start: gint,
        length: gint,
        value: gint32,
        format: *const ::std::os::raw::c_char,
        ...
    ) -> *mut proto_item;
}
extern "C" {
    #[doc = " Add a formatted FT_INT8, FT_INT16, FT_INT24 or FT_INT32 to a proto_tree,\nwith the format generating the entire string for the entry, including\nany field name.\n@param tree the tree to append this item to\n@param hfindex field index\n@param tvb the tv buffer of the current data\n@param start start of data in tvb\n@param length length of data in tvb\n@param value data to display\n@param format printf like format string\n@param ... printf like parameters\n@return the newly created item"]
    pub fn proto_tree_add_int_format(
        tree: *mut proto_tree,
        hfindex: ::std::os::raw::c_int,
        tvb: *mut tvbuff_t,
        start: gint,
        length: gint,
        value: gint32,
        format: *const ::std::os::raw::c_char,
        ...
    ) -> *mut proto_item;
}
extern "C" {
    #[doc = " Add an FT_INT64 to a proto_tree.\n@param tree the tree to append this item to\n@param hfindex field index\n@param tvb the tv buffer of the current data\n@param start start of data in tvb\n@param length length of data in tvb\n@param value data to display\n@return the newly created item"]
    pub fn proto_tree_add_int64(
        tree: *mut proto_tree,
        hfindex: ::std::os::raw::c_int,
        tvb: *mut tvbuff_t,
        start: gint,
        length: gint,
        value: gint64,
    ) -> *mut proto_item;
}
extern "C" {
    #[doc = " Add a formatted FT_INT64 to a proto_tree, with the format generating\nthe string for the value and with the field name being included\nautomatically.\n@param tree the tree to append this item to\n@param hfindex field index\n@param tvb the tv buffer of the current data\n@param start start of data in tvb\n@param length length of data in tvb\n@param value data to display\n@param format printf like format string\n@param ... printf like parameters\n@return the newly created item"]
    pub fn proto_tree_add_int64_format_value(
        tree: *mut proto_tree,
        hfindex: ::std::os::raw::c_int,
        tvb: *mut tvbuff_t,
        start: gint,
        length: gint,
        value: gint64,
        format: *const ::std::os::raw::c_char,
        ...
    ) -> *mut proto_item;
}
extern "C" {
    #[doc = " Add a formatted FT_INT64 to a proto_tree, with the format generating\nthe entire string for the entry, including any field name.\n@param tree the tree to append this item to\n@param hfindex field index\n@param tvb the tv buffer of the current data\n@param start start of data in tvb\n@param length length of data in tvb\n@param value data to display\n@param format printf like format string\n@param ... printf like parameters\n@return the newly created item"]
    pub fn proto_tree_add_int64_format(
        tree: *mut proto_tree,
        hfindex: ::std::os::raw::c_int,
        tvb: *mut tvbuff_t,
        start: gint,
        length: gint,
        value: gint64,
        format: *const ::std::os::raw::c_char,
        ...
    ) -> *mut proto_item;
}
extern "C" {
    #[doc = " Add a FT_EUI64 to a proto_tree.\n@param tree the tree to append this item to\n@param hfindex field index\n@param tvb the tv buffer of the current data\n@param start start of data in tvb\n@param length length of data in tvb\n@param value data to display\n@return the newly created item"]
    pub fn proto_tree_add_eui64(
        tree: *mut proto_tree,
        hfindex: ::std::os::raw::c_int,
        tvb: *mut tvbuff_t,
        start: gint,
        length: gint,
        value: guint64,
    ) -> *mut proto_item;
}
extern "C" {
    #[doc = " Add a formatted FT_EUI64 to a proto_tree, with the format generating\nthe string for the value and with the field name being included\nautomatically.\n@param tree the tree to append this item to\n@param hfindex field index\n@param tvb the tv buffer of the current data\n@param start start of data in tvb\n@param length length of data in tvb\n@param value data to display\n@param format printf like format string\n@param ... printf like parameters\n@return the newly created item"]
    pub fn proto_tree_add_eui64_format_value(
        tree: *mut proto_tree,
        hfindex: ::std::os::raw::c_int,
        tvb: *mut tvbuff_t,
        start: gint,
        length: gint,
        value: guint64,
        format: *const ::std::os::raw::c_char,
        ...
    ) -> *mut proto_item;
}
extern "C" {
    #[doc = " Add a formatted FT_EUI64 to a proto_tree, with the format generating\nthe entire string for the entry, including any field name.\n@param tree the tree to append this item to\n@param hfindex field index\n@param tvb the tv buffer of the current data\n@param start start of data in tvb\n@param length length of data in tvb\n@param value data to display\n@param format printf like format string\n@param ... printf like parameters\n@return the newly created item"]
    pub fn proto_tree_add_eui64_format(
        tree: *mut proto_tree,
        hfindex: ::std::os::raw::c_int,
        tvb: *mut tvbuff_t,
        start: gint,
        length: gint,
        value: guint64,
        format: *const ::std::os::raw::c_char,
        ...
    ) -> *mut proto_item;
}
extern "C" {
    #[doc = " Useful for quick debugging. Also sends string to STDOUT, so don't\nleave call to this function in production code.\n@param tree the tree to append the text to\n@param format printf like format string\n@param ... printf like parameters\n@return the newly created item"]
    pub fn proto_tree_add_debug_text(
        tree: *mut proto_tree,
        format: *const ::std::os::raw::c_char,
        ...
    ) -> *mut proto_item;
}
extern "C" {
    #[doc = " Fill given label_str with a simple string representation of field.\n@param finfo the item to get the info from\n@param label_str the string to fill\n@todo think about changing the parameter profile"]
    pub fn proto_item_fill_label(finfo: *mut field_info, label_str: *mut gchar);
}
extern "C" {
    #[doc = " Fill the given display_label_str with the string representation of a field\n formatted according to its type and field display specifier.\n Used to display custom columns and packet diagram values.\n@param fi The item to get the info from\n@param display_label_str The string to fill\n@return The length of the label excluding the terminating '\\0'."]
    pub fn proto_item_fill_display_label(
        fi: *mut field_info,
        display_label_str: *mut gchar,
        label_str_size: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Register a new protocol.\n@param name the full name of the new protocol\n@param short_name abbreviated name of the new protocol\n@param filter_name protocol name used for a display filter string\n@return the new protocol handle"]
    pub fn proto_register_protocol(
        name: *const ::std::os::raw::c_char,
        short_name: *const ::std::os::raw::c_char,
        filter_name: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Register a \"helper\" protocol (pino - protocol in name only).\nThis is for dissectors that need distinguishing names and don't need the other\nfeatures (like enable/disable).  One use case is a protocol with multiple dissection\nfunctions in a single dissector table needing unique \"dissector names\" to remove\nconfusion with Decode As dialog.  Another use case is for a dissector table set\nup to handle TLVs within a single protocol (and allow \"external\" TLVs being\nregistered through the dissector table).\n@param name the full name of the new protocol\n@param short_name abbreviated name of the new protocol\n@param filter_name protocol name used for a display filter string\n@param parent_proto the \"real\" protocol for the helper.  The parent decides enable/disable\n@param field_type FT_PROTOCOL or FT_BYTES.  Allows removal of \"protocol highlighting\" (FT_BYTES)\nif pino is part of TLV.\n@return the new protocol handle"]
    pub fn proto_register_protocol_in_name_only(
        name: *const ::std::os::raw::c_char,
        short_name: *const ::std::os::raw::c_char,
        filter_name: *const ::std::os::raw::c_char,
        parent_proto: ::std::os::raw::c_int,
        field_type: ftenum,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Register a protocol alias.\nThis is for dissectors whose original name has changed, e.g. BOOTP to DHCP.\n@param proto_id protocol id returned by proto_register_protocol (0-indexed)\n@param alias_name alias for the protocol's filter name"]
    pub fn proto_register_alias(
        proto_id: ::std::os::raw::c_int,
        alias_name: *const ::std::os::raw::c_char,
    );
}
#[doc = " This type of function can be registered to get called whenever\na given field was not found but a its prefix is matched;\nIt can be used to procrastinate the hf array registration.\n@param match  what's being matched"]
pub type prefix_initializer_t =
    ::std::option::Option<unsafe extern "C" fn(match_: *const ::std::os::raw::c_char)>;
extern "C" {
    #[doc = " Register a new prefix for delayed initialization of field arrays\nNote that the initializer function MAY NOT be called before the dissector\nis first called.  That is, dissectors using this function must be prepared\nto call the initializer before beginning dissection; they should do this by\ncalling proto_registrar_get_byname() on one of the dissector's field names.\n@param prefix the prefix for the new protocol\n@param initializer function that will initialize the field array for the given prefix"]
    pub fn proto_register_prefix(
        prefix: *const ::std::os::raw::c_char,
        initializer: prefix_initializer_t,
    );
}
extern "C" {
    #[doc = " Register a header_field array.\n@param parent the protocol handle from proto_register_protocol()\n@param hf the hf_register_info array\n@param num_records the number of records in hf"]
    pub fn proto_register_field_array(
        parent: ::std::os::raw::c_int,
        hf: *mut hf_register_info,
        num_records: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " Register a protocol subtree (ett) array.\n@param indices array of ett indices\n@param num_indices the number of records in indices"]
    pub fn proto_register_subtree_array(
        indices: *const *mut gint,
        num_indices: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " This function will dissect a sequence of bytes that describe a bitmask.\n@param tree the tree to append this item to\n@param tvb the tv buffer of the current data\n@param offset start of data in tvb\n@param hf_hdr an 8/16/24/32/40/48/56/64 bit integer that describes the\nbitmask to be dissected.\nThis field will form an expansion under which the individual fields\nof the bitmask are dissected and displayed.\nThis field must be of the type FT_[U]INT{8|16|24|32|40|48|56|64}.\n@param ett subtree index\n@param fields an array of pointers to int that lists all the fields of the\nbitmask. These fields can be either of the type FT_BOOLEAN for flags\nor another integer of the same type/size as hf_hdr with a mask specified.\nThis array is terminated by a NULL entry.\nFT_BOOLEAN bits that are set to 1 will have the name added to the expansion.\nFT_integer fields that have a value_string attached will have the\nmatched string displayed on the expansion line.\n@param encoding big or little endian byte representation (ENC_BIG_ENDIAN/ENC_LITTLE_ENDIAN/ENC_HOST_ENDIAN)\n@return the newly created item"]
    pub fn proto_tree_add_bitmask(
        tree: *mut proto_tree,
        tvb: *mut tvbuff_t,
        offset: guint,
        hf_hdr: ::std::os::raw::c_int,
        ett: gint,
        fields: *const *mut ::std::os::raw::c_int,
        encoding: guint,
    ) -> *mut proto_item;
}
extern "C" {
    #[doc = " This function will dissect a sequence of bytes that describe a bitmask.\nThe value of the integer containing the bitmask is returned through\na pointer.\n@param tree the tree to append this item to\n@param tvb the tv buffer of the current data\n@param offset start of data in tvb\n@param hf_hdr an 8/16/24/32/40/48/56/64 bit integer that describes the\nbitmask to be dissected.\nThis field will form an expansion under which the individual fields\nof the bitmask are dissected and displayed.\nThis field must be of the type FT_[U]INT{8|16|24|32|40|48|56|64}.\n@param ett subtree index\n@param fields an array of pointers to int that lists all the fields of the\nbitmask. These fields can be either of the type FT_BOOLEAN for flags\nor another integer of the same type/size as hf_hdr with a mask specified.\nThis array is terminated by a NULL entry.\nFT_BOOLEAN bits that are set to 1 will have the name added to the expansion.\nFT_integer fields that have a value_string attached will have the\nmatched string displayed on the expansion line.\n@param encoding big or little endian byte representation (ENC_BIG_ENDIAN/ENC_LITTLE_ENDIAN/ENC_HOST_ENDIAN)\n@param[out] retval points to a guint64 which will be set\n@return the newly created item, and *retval is set to the decoded value masked/shifted according to bitmask"]
    pub fn proto_tree_add_bitmask_ret_uint64(
        tree: *mut proto_tree,
        tvb: *mut tvbuff_t,
        offset: guint,
        hf_hdr: ::std::os::raw::c_int,
        ett: gint,
        fields: *const *mut ::std::os::raw::c_int,
        encoding: guint,
        retval: *mut guint64,
    ) -> *mut proto_item;
}
extern "C" {
    #[doc = " This function will dissect a sequence of bytes that describe a bitmask.\nThis has \"filterable\" bitmask header functionality of proto_tree_add_bitmask\nwith the ability to control what data is appended to the header like\nproto_tree_add_bitmask_text\n@param tree the tree to append this item to\n@param tvb the tv buffer of the current data\n@param offset start of data in tvb\n@param hf_hdr an 8/16/24/32/40/48/56/64 bit integer that describes the\nbitmask to be dissected.\nThis field will form an expansion under which the individual fields\nof the bitmask are dissected and displayed.\nThis field must be of the type FT_[U]INT{8|16|24|32|40|48|56|64}.\n@param ett subtree index\n@param fields an array of pointers to int that lists all the fields of the\nbitmask. These fields can be either of the type FT_BOOLEAN for flags\nor another integer of the same type/size as hf_hdr with a mask specified.\nThis array is terminated by a NULL entry.\nFT_BOOLEAN bits that are set to 1 will have the name added to the expansion.\nFT_integer fields that have a value_string attached will have the\nmatched string displayed on the expansion line.\n@param encoding big or little endian byte representation (ENC_BIG_ENDIAN/ENC_LITTLE_ENDIAN/ENC_HOST_ENDIAN)\n@param flags bitmask field using BMT_NO_* flags to determine behavior\n@return the newly created item"]
    pub fn proto_tree_add_bitmask_with_flags(
        tree: *mut proto_tree,
        tvb: *mut tvbuff_t,
        offset: guint,
        hf_hdr: ::std::os::raw::c_int,
        ett: gint,
        fields: *const *mut ::std::os::raw::c_int,
        encoding: guint,
        flags: ::std::os::raw::c_int,
    ) -> *mut proto_item;
}
extern "C" {
    #[doc = " This function will dissect a sequence of bytes that describe a bitmask.\nThis has \"filterable\" bitmask header functionality of proto_tree_add_bitmask\nwith the ability to control what data is appended to the header like\nproto_tree_add_bitmask_text\nThe value of the integer containing the bitmask is returned through\na pointer.\n@param tree the tree to append this item to\n@param tvb the tv buffer of the current data\n@param offset start of data in tvb\n@param hf_hdr an 8/16/24/32/40/48/56/64 bit integer that describes the\nbitmask to be dissected.\nThis field will form an expansion under which the individual fields\nof the bitmask are dissected and displayed.\nThis field must be of the type FT_[U]INT{8|16|24|32|40|48|56|64}.\n@param ett subtree index\n@param fields an array of pointers to int that lists all the fields of the\nbitmask. These fields can be either of the type FT_BOOLEAN for flags\nor another integer of the same type/size as hf_hdr with a mask specified.\nThis array is terminated by a NULL entry.\nFT_BOOLEAN bits that are set to 1 will have the name added to the expansion.\nFT_integer fields that have a value_string attached will have the\nmatched string displayed on the expansion line.\n@param encoding big or little endian byte representation (ENC_BIG_ENDIAN/ENC_LITTLE_ENDIAN/ENC_HOST_ENDIAN)\n@param flags bitmask field using BMT_NO_* flags to determine behavior\n@param[out] retval points to a guint64 which will be set\n@return the newly created item, and *retval is set to the decoded value masked/shifted according to bitmask"]
    pub fn proto_tree_add_bitmask_with_flags_ret_uint64(
        tree: *mut proto_tree,
        tvb: *mut tvbuff_t,
        offset: guint,
        hf_hdr: ::std::os::raw::c_int,
        ett: gint,
        fields: *const *mut ::std::os::raw::c_int,
        encoding: guint,
        flags: ::std::os::raw::c_int,
        retval: *mut guint64,
    ) -> *mut proto_item;
}
extern "C" {
    #[doc = " This function will dissect a value that describe a bitmask. Similar to proto_tree_add_bitmask(),\nbut with a passed in value (presumably because it can't be retrieved directly from tvb)\n@param tree the tree to append this item to\n@param tvb the tv buffer of the current data\n@param offset start of data in tvb\n@param hf_hdr an 8/16/24/32/64 bit integer that describes the bitmask to be dissected.\nThis field will form an expansion under which the individual fields of the\nbitmask is dissected and displayed.\nThis field must be of the type FT_[U]INT{8|16|24|32|64}.\n@param ett subtree index\n@param fields an array of pointers to int that lists all the fields of the\nbitmask. These fields can be either of the type FT_BOOLEAN for flags\nor another integer of the same type/size as hf_hdr with a mask specified.\nThis array is terminated by a NULL entry.\nFT_BOOLEAN bits that are set to 1 will have the name added to the expansion.\nFT_integer fields that have a value_string attached will have the\nmatched string displayed on the expansion line.\n@param value bitmask value\n@return the newly created item"]
    pub fn proto_tree_add_bitmask_value(
        tree: *mut proto_tree,
        tvb: *mut tvbuff_t,
        offset: guint,
        hf_hdr: ::std::os::raw::c_int,
        ett: gint,
        fields: *const *mut ::std::os::raw::c_int,
        value: guint64,
    ) -> *mut proto_item;
}
extern "C" {
    #[doc = " This function will dissect a value that describe a bitmask. Similar to proto_tree_add_bitmask(),\nbut with a passed in value (presumably because it can't be retrieved directly from tvb)\nThis has \"filterable\" bitmask header functionality of proto_tree_add_bitmask_value\nwith the ability to control what data is appended to the header like\nproto_tree_add_bitmask_text\n@param tree the tree to append this item to\n@param tvb the tv buffer of the current data\n@param offset start of data in tvb\n@param hf_hdr an 8/16/24/32/64 bit integer that describes the bitmask to be dissected.\nThis field will form an expansion under which the individual fields of the\nbitmask is dissected and displayed.\nThis field must be of the type FT_[U]INT{8|16|24|32|64}.\n@param ett subtree index\n@param fields an array of pointers to int that lists all the fields of the\nbitmask. These fields can be either of the type FT_BOOLEAN for flags\nor another integer of the same type/size as hf_hdr with a mask specified.\nThis array is terminated by a NULL entry.\nFT_BOOLEAN bits that are set to 1 will have the name added to the expansion.\nFT_integer fields that have a value_string attached will have the\nmatched string displayed on the expansion line.\n@param value bitmask value\n@param flags bitmask field using BMT_NO_* flags to determine behavior\n@return the newly created item"]
    pub fn proto_tree_add_bitmask_value_with_flags(
        tree: *mut proto_tree,
        tvb: *mut tvbuff_t,
        offset: guint,
        hf_hdr: ::std::os::raw::c_int,
        ett: gint,
        fields: *const *mut ::std::os::raw::c_int,
        value: guint64,
        flags: ::std::os::raw::c_int,
    ) -> *mut proto_item;
}
extern "C" {
    #[doc = " This function will dissect a sequence of bytes that describe a bitmask. Similar\nto proto_tree_add_bitmask(), but with no \"header\" item to group all of the fields\n@param tree the tree to append this item to\n@param tvb the tv buffer of the current data\n@param offset start of data in tvb\n@param len number of bytes of data\n@param fields an array of pointers to int that lists all the fields of the\nbitmask. These fields can be either of the type FT_BOOLEAN for flags\nor another integer of the same type/size as hf_hdr with a mask specified.\nThis array is terminated by a NULL entry.\nFT_BOOLEAN bits that are set to 1 will have the name added to the expansion.\nFT_integer fields that have a value_string attached will have the\nmatched string displayed on the expansion line.\n@param encoding big or little endian byte representation (ENC_BIG_ENDIAN/ENC_LITTLE_ENDIAN/ENC_HOST_ENDIAN)"]
    pub fn proto_tree_add_bitmask_list(
        tree: *mut proto_tree,
        tvb: *mut tvbuff_t,
        offset: guint,
        len: ::std::os::raw::c_int,
        fields: *const *mut ::std::os::raw::c_int,
        encoding: guint,
    );
}
extern "C" {
    #[doc = " This function will dissect a value that describe a bitmask. Similar to proto_tree_add_bitmask_list(),\nbut with a return value\n@param tree the tree to append this item to\n@param tvb the tv buffer of the current data\n@param offset start of data in tvb\n@param len number of bytes of data\n@param fields an array of pointers to int that lists all the fields of the\nbitmask. These fields can be either of the type FT_BOOLEAN for flags\nor another integer of the same type/size as hf_hdr with a mask specified.\nThis array is terminated by a NULL entry.\nFT_BOOLEAN bits that are set to 1 will have the name added to the expansion.\nFT_integer fields that have a value_string attached will have the\nmatched string displayed on the expansion line.\n@param encoding big or little endian byte representation (ENC_BIG_ENDIAN/ENC_LITTLE_ENDIAN/ENC_HOST_ENDIAN)\n@param retval if a pointer is passed here the value is returned."]
    pub fn proto_tree_add_bitmask_list_ret_uint64(
        tree: *mut proto_tree,
        tvb: *mut tvbuff_t,
        offset: guint,
        len: ::std::os::raw::c_int,
        fields: *const *mut ::std::os::raw::c_int,
        encoding: guint,
        retval: *mut guint64,
    );
}
extern "C" {
    #[doc = " This function will dissect a value that describe a bitmask. Similar to proto_tree_add_bitmask_list(),\nbut with a passed in value (presumably because it can't be retrieved directly from tvb)\n@param tree the tree to append this item to\n@param tvb the tv buffer of the current data\n@param offset start of data in tvb\n@param len number of bytes of data\n@param fields an array of pointers to int that lists all the fields of the\nbitmask. These fields can be either of the type FT_BOOLEAN for flags\nor another integer of the same type/size as hf_hdr with a mask specified.\nThis array is terminated by a NULL entry.\nFT_BOOLEAN bits that are set to 1 will have the name added to the expansion.\nFT_integer fields that have a value_string attached will have the\nmatched string displayed on the expansion line.\n@param value bitmask value"]
    pub fn proto_tree_add_bitmask_list_value(
        tree: *mut proto_tree,
        tvb: *mut tvbuff_t,
        offset: guint,
        len: ::std::os::raw::c_int,
        fields: *const *mut ::std::os::raw::c_int,
        value: guint64,
    );
}
extern "C" {
    #[doc = " This function will dissect a sequence of bytes that describe a bitmask.\n@param tree the tree to append this item to\n@param tvb the tv buffer of the current data\n@param offset start of data in tvb\n@param len number of bytes of data\n@param hf_hdr an 8/16/24/32 bit integer that describes the bitmask to be dissected.\nThis field will form an expansion under which the individual fields of the\nbitmask are dissected and displayed.\nThis field must be of the type FT_[U]INT{8|16|24|32}.\n@param ett subtree index\n@param fields an array of pointers to int that lists all the fields of the\nbitmask. These fields can be either of the type FT_BOOLEAN for flags\nor another integer with a mask specified.\nThis array is terminated by a NULL entry.\nFT_BOOLEAN bits that are set to 1 will have the name added to the expansion.\nFT_integer fields that have a value_string attached will have the\nmatched string displayed on the expansion line.\n@param exp expert info field used when decodable_len < len.  This also means this function\nshould be called even when tree == NULL\n@param encoding big or little endian byte representation (ENC_BIG_ENDIAN/ENC_LITTLE_ENDIAN/ENC_HOST_ENDIAN)\n@return the newly created item"]
    pub fn proto_tree_add_bitmask_len(
        tree: *mut proto_tree,
        tvb: *mut tvbuff_t,
        offset: guint,
        len: guint,
        hf_hdr: ::std::os::raw::c_int,
        ett: gint,
        fields: *const *mut ::std::os::raw::c_int,
        exp: *mut expert_field,
        encoding: guint,
    ) -> *mut proto_item;
}
extern "C" {
    #[doc = " Add a text with a subtree of bitfields.\n@param tree the tree to append this item to\n@param tvb the tv buffer of the current data\n@param offset start of data in tvb\n@param len length of the field name\n@param name field name (NULL if bitfield contents should be used)\n@param fallback field name if none of bitfields were usable\n@param ett subtree index\n@param fields NULL-terminated array of bitfield indexes\n@param encoding big or little endian byte representation (ENC_BIG_ENDIAN/ENC_LITTLE_ENDIAN/ENC_HOST_ENDIAN)\n@param flags bitmask field\n@return the newly created item"]
    pub fn proto_tree_add_bitmask_text(
        tree: *mut proto_tree,
        tvb: *mut tvbuff_t,
        offset: guint,
        len: guint,
        name: *const ::std::os::raw::c_char,
        fallback: *const ::std::os::raw::c_char,
        ett: gint,
        fields: *const *mut ::std::os::raw::c_int,
        encoding: guint,
        flags: ::std::os::raw::c_int,
    ) -> *mut proto_item;
}
extern "C" {
    #[doc = " Add bits to a proto_tree, using the text label registered to that item.\nThe item is extracted from the tvbuff handed to it.\n@param tree the tree to append this item to\n@param hf_index field index. Fields for use with this function should have bitmask==0.\n@param tvb the tv buffer of the current data\n@param bit_offset start of data in tvb expressed in bits\n@param no_of_bits length of data in tvb expressed in bits\n@param encoding data encoding\n@return the newly created item"]
    pub fn proto_tree_add_bits_item(
        tree: *mut proto_tree,
        hf_index: ::std::os::raw::c_int,
        tvb: *mut tvbuff_t,
        bit_offset: guint,
        no_of_bits: gint,
        encoding: guint,
    ) -> *mut proto_item;
}
extern "C" {
    #[doc = " Add bits to a proto_tree, using the text label registered to that item.\n  The item is extracted from the tvbuff handed to it as a set\n  of crumbs (segments) of contiguous bits, specified by an\n  array of crumb_spec elements.  The crumbs are assembled to\n  create the value.  There may be any number of crumbs\n  specifying up to a total of 64 bits which may occur anywhere\n  within the tvb. If the span of the crumbs within the tvb is 4\n  octets or less, a bitmap of the crumbs is produced.\n@param tree the tree to append this item to\n@param hf_index field index. Fields for use with this function should have bitmask==0.\n@param tvb the tv buffer of the current data\n@param bit_offset of the first crumb in tvb expressed in bits\n@param crumb_spec pointer to crumb_spec array\n@param return_value if a pointer is passed here the value is returned.\n@return the newly created item"]
    pub fn proto_tree_add_split_bits_item_ret_val(
        tree: *mut proto_tree,
        hf_index: ::std::os::raw::c_int,
        tvb: *mut tvbuff_t,
        bit_offset: guint,
        crumb_spec: *const crumb_spec_t,
        return_value: *mut guint64,
    ) -> *mut proto_item;
}
extern "C" {
    #[doc = " Add bitmap text for a split-bits crumb to a proto_tree,\n  using the text label registered to an item. The bitmap is\n  extracted from the tvbuff handed to it as a crumb (segment)\n  of contiguous bits, specified by one of an array of\n  crumb_spec elements. This function is normally called once\n  per crumb, after the call to\nproto_tree_add_split_bits_item_ret_val\n@param tree the tree to append this item to\n@param hf_index field index. Fields for use with this function should have bitmask==0.\n@param tvb the tv buffer of the current data\n@param bit_offset of the first crumb in tvb expressed in bits\n@param crumb_spec pointer to crumb_spec array\n@param crumb_index into the crumb_spec array for this crumb"]
    pub fn proto_tree_add_split_bits_crumb(
        tree: *mut proto_tree,
        hf_index: ::std::os::raw::c_int,
        tvb: *mut tvbuff_t,
        bit_offset: guint,
        crumb_spec: *const crumb_spec_t,
        crumb_index: guint16,
    );
}
extern "C" {
    #[doc = " Add bits to a proto_tree, using the text label registered to that item.\nThe item is extracted from the tvbuff handed to it.\n@param tree the tree to append this item to\n@param hf_index field index. Fields for use with this function should have bitmask==0.\n@param tvb the tv buffer of the current data\n@param bit_offset start of data in tvb expressed in bits\n@param no_of_bits length of data in tvb expressed in bits\n@param return_value if a pointer is passed here the value is returned.\n@param encoding data encoding\n@return the newly created item"]
    pub fn proto_tree_add_bits_ret_val(
        tree: *mut proto_tree,
        hf_index: ::std::os::raw::c_int,
        tvb: *mut tvbuff_t,
        bit_offset: guint,
        no_of_bits: gint,
        return_value: *mut guint64,
        encoding: guint,
    ) -> *mut proto_item;
}
extern "C" {
    #[doc = " Add bits for a FT_UINT8, FT_UINT16, FT_UINT24 or FT_UINT32\nheader field to a proto_tree, with the format generating the\nstring for the value and with the field name being included automatically.\n@param tree the tree to append this item to\n@param hf_index field index\n@param tvb the tv buffer of the current data\n@param bit_offset start of data in tvb expressed in bits\n@param no_of_bits length of data in tvb expressed in bit\n@param value data to display\n@param encoding data encoding\n@param format printf like format string\n@return the newly created item"]
    pub fn proto_tree_add_uint_bits_format_value(
        tree: *mut proto_tree,
        hf_index: ::std::os::raw::c_int,
        tvb: *mut tvbuff_t,
        bit_offset: guint,
        no_of_bits: gint,
        value: guint32,
        encoding: guint,
        format: *const ::std::os::raw::c_char,
        ...
    ) -> *mut proto_item;
}
extern "C" {
    #[doc = " Add bits for a FT_UINT8, FT_UINT16, FT_UINT24 or FT_UINT32\nheader field to a proto_tree, with the format generating the\nstring for the value and with the field name being included automatically.\n@param tree the tree to append this item to\n@param hf_index field index\n@param tvb the tv buffer of the current data\n@param bit_offset start of data in tvb expressed in bits\n@param no_of_bits length of data in tvb expressed in bit\n@param value data to display\n@param encoding data encoding\n@param format printf like format string\n@return the newly created item"]
    pub fn proto_tree_add_uint64_bits_format_value(
        tree: *mut proto_tree,
        hf_index: ::std::os::raw::c_int,
        tvb: *mut tvbuff_t,
        bit_offset: guint,
        no_of_bits: gint,
        value: guint64,
        encoding: guint,
        format: *const ::std::os::raw::c_char,
        ...
    ) -> *mut proto_item;
}
extern "C" {
    #[doc = " Add bits for a FT_BOOLEAN header field to a proto_tree, with\nthe format generating the string for the value and with the field\nname being included automatically.\n@param tree the tree to append this item to\n@param hf_index field index\n@param tvb the tv buffer of the current data\n@param bit_offset start of data in tvb expressed in bits\n@param no_of_bits length of data in tvb expressed in bit\n@param value data to display\n@param encoding data encoding\n@param format printf like format string\n@param ... printf like parameters\n@return the newly created item"]
    pub fn proto_tree_add_boolean_bits_format_value(
        tree: *mut proto_tree,
        hf_index: ::std::os::raw::c_int,
        tvb: *mut tvbuff_t,
        bit_offset: guint,
        no_of_bits: gint,
        value: guint32,
        encoding: guint,
        format: *const ::std::os::raw::c_char,
        ...
    ) -> *mut proto_item;
}
extern "C" {
    #[doc = " Add bits for a FT_BOOLEAN header field to a proto_tree, with\nthe format generating the string for the value and with the field\nname being included automatically.\n@param tree the tree to append this item to\n@param hf_index field index\n@param tvb the tv buffer of the current data\n@param bit_offset start of data in tvb expressed in bits\n@param no_of_bits length of data in tvb expressed in bit\n@param value data to display\n@param encoding data encoding\n@param format printf like format string\n@param ... printf like parameters\n@return the newly created item"]
    pub fn proto_tree_add_boolean_bits_format_value64(
        tree: *mut proto_tree,
        hf_index: ::std::os::raw::c_int,
        tvb: *mut tvbuff_t,
        bit_offset: guint,
        no_of_bits: gint,
        value: guint64,
        encoding: guint,
        format: *const ::std::os::raw::c_char,
        ...
    ) -> *mut proto_item;
}
extern "C" {
    #[doc = " Add bits for a FT_INT8, FT_INT16, FT_INT24 or FT_INT32\nheader field to a proto_tree, with the format generating the\nstring for the value and with the field name being included automatically.\n@param tree the tree to append this item to\n@param hf_index field index\n@param tvb the tv buffer of the current data\n@param bit_offset start of data in tvb expressed in bits\n@param no_of_bits length of data in tvb expressed in bit\n@param value data to display\n@param encoding data encoding\n@param format printf like format string\n@param ... printf like parameters\n@return the newly created item"]
    pub fn proto_tree_add_int_bits_format_value(
        tree: *mut proto_tree,
        hf_index: ::std::os::raw::c_int,
        tvb: *mut tvbuff_t,
        bit_offset: guint,
        no_of_bits: gint,
        value: gint32,
        encoding: guint,
        format: *const ::std::os::raw::c_char,
        ...
    ) -> *mut proto_item;
}
extern "C" {
    #[doc = " Add bits for a FT_INT8, FT_INT16, FT_INT24 or FT_INT32\nheader field to a proto_tree, with the format generating the\nstring for the value and with the field name being included automatically.\n@param tree the tree to append this item to\n@param hf_index field index\n@param tvb the tv buffer of the current data\n@param bit_offset start of data in tvb expressed in bits\n@param no_of_bits length of data in tvb expressed in bit\n@param value data to display\n@param encoding data encoding\n@param format printf like format string\n@param ... printf like parameters\n@return the newly created item"]
    pub fn proto_tree_add_int64_bits_format_value(
        tree: *mut proto_tree,
        hf_index: ::std::os::raw::c_int,
        tvb: *mut tvbuff_t,
        bit_offset: guint,
        no_of_bits: gint,
        value: gint64,
        encoding: guint,
        format: *const ::std::os::raw::c_char,
        ...
    ) -> *mut proto_item;
}
extern "C" {
    #[doc = " Add bits for a FT_FLOAT header field to a proto_tree, with\nthe format generating the string for the value and with the field\nname being included automatically.\n@param tree the tree to append this item to\n@param hf_index field index\n@param tvb the tv buffer of the current data\n@param bit_offset start of data in tvb expressed in bits\n@param no_of_bits length of data in tvb expressed in bit\n@param value data to display\n@param encoding data encoding\n@param format printf like format string\n@param ... printf like parameters\n@return the newly created item"]
    pub fn proto_tree_add_float_bits_format_value(
        tree: *mut proto_tree,
        hf_index: ::std::os::raw::c_int,
        tvb: *mut tvbuff_t,
        bit_offset: guint,
        no_of_bits: gint,
        value: f32,
        encoding: guint,
        format: *const ::std::os::raw::c_char,
        ...
    ) -> *mut proto_item;
}
extern "C" {
    #[doc = " Add a FT_STRING with ENC_3GPP_TS_23_038_7BITS_PACKED encoding to a\nproto_tree.\n@param tree the tree to append this item to\n@param hfindex field index\n@param tvb the tv buffer of the current data\n@param bit_offset start of data in tvb expressed in bits\n@param no_of_chars number of 7bits characters to display\n@return the newly created item"]
    pub fn proto_tree_add_ts_23_038_7bits_packed_item(
        tree: *mut proto_tree,
        hfindex: ::std::os::raw::c_int,
        tvb: *mut tvbuff_t,
        bit_offset: guint,
        no_of_chars: gint,
    ) -> *mut proto_item;
}
extern "C" {
    #[doc = " Add a FT_STRING with ENC_ASCII_7BITS encoding to a proto_tree.\n@param tree the tree to append this item to\n@param hfindex field index\n@param tvb the tv buffer of the current data\n@param bit_offset start of data in tvb expressed in bits\n@param no_of_chars number of 7bits characters to display\n@return the newly created item"]
    pub fn proto_tree_add_ascii_7bits_item(
        tree: *mut proto_tree,
        hfindex: ::std::os::raw::c_int,
        tvb: *mut tvbuff_t,
        bit_offset: guint,
        no_of_chars: gint,
    ) -> *mut proto_item;
}
extern "C" {
    #[doc = " Add a checksum filed to a proto_tree.\nThis standardizes the display of a checksum field as well as any\nstatus and expert info supporting it.\n@param tree the tree to append this item to\n@param tvb the tv buffer of the current data\n@param offset start of data in tvb\n@param hf_checksum checksum field index\n@param hf_checksum_status optional checksum status field index.  If none\nexists, just pass -1\n@param bad_checksum_expert optional expert info for a bad checksum.  If\nnone exists, just pass NULL\n@param pinfo Packet info used for optional expert info.  If unused, NULL can\nbe passed\n@param computed_checksum Checksum to verify against\n@param encoding data encoding of checksum from tvb\n@param flags bitmask field of PROTO_CHECKSUM_ options\n@return the newly created item"]
    pub fn proto_tree_add_checksum(
        tree: *mut proto_tree,
        tvb: *mut tvbuff_t,
        offset: guint,
        hf_checksum: ::std::os::raw::c_int,
        hf_checksum_status: ::std::os::raw::c_int,
        bad_checksum_expert: *mut expert_field,
        pinfo: *mut packet_info,
        computed_checksum: guint32,
        encoding: guint,
        flags: guint,
    ) -> *mut proto_item;
}
extern "C" {
    #[doc = " Add a checksum bytes arry filed to a proto_tree.\nThis standardizes the display of a checksum field as well as any\nstatus and expert info supporting it.\n@param tree the tree to append this item to\n@param tvb the tv buffer of the current data\n@param offset start of data in tvb\n@param hf_checksum checksum field index\n@param hf_checksum_status optional checksum status field index.  If none\nexists, just pass -1\n@param bad_checksum_expert optional expert info for a bad checksum.  If\nnone exists, just pass NULL\n@param pinfo Packet info used for optional expert info.  If unused, NULL can\nbe passed\n@param computed_checksum Checksum as bytes array to verify against\n@param checksum_len Checksum size in bytes\n@param flags bitmask field of PROTO_CHECKSUM_ options. PROTO_CHECKSUM_IN_CKSUM is ignored\n@return the newly created item"]
    pub fn proto_tree_add_checksum_bytes(
        tree: *mut proto_tree,
        tvb: *mut tvbuff_t,
        offset: guint,
        hf_checksum: ::std::os::raw::c_int,
        hf_checksum_status: ::std::os::raw::c_int,
        bad_checksum_expert: *mut expert_field,
        pinfo: *mut packet_info,
        computed_checksum: *const u8,
        checksum_len: usize,
        flags: guint,
    ) -> *mut proto_item;
}
#[doc = "  Helper routines for column utility structures and routines."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct epan_column_info {
    _unused: [u8; 0],
}
pub type column_info = epan_column_info;
#[doc = "< 0) Absolute date, as YYYY-MM-DD, and time"]
pub const COL_ABS_YMD_TIME: _bindgen_ty_21 = 0;
#[doc = "< 1) Absolute date, as YYYY/DOY, and time"]
pub const COL_ABS_YDOY_TIME: _bindgen_ty_21 = 1;
#[doc = "< 2) Absolute time"]
pub const COL_ABS_TIME: _bindgen_ty_21 = 2;
#[doc = "< 3) Cumulative number of bytes"]
pub const COL_CUMULATIVE_BYTES: _bindgen_ty_21 = 3;
#[doc = "< 4) Custom column (any filter name's contents)"]
pub const COL_CUSTOM: _bindgen_ty_21 = 4;
#[doc = "< 5) Delta time"]
pub const COL_DELTA_TIME: _bindgen_ty_21 = 5;
#[doc = "< 6) Delta time displayed"]
pub const COL_DELTA_TIME_DIS: _bindgen_ty_21 = 6;
#[doc = "< 7) Resolved dest"]
pub const COL_RES_DST: _bindgen_ty_21 = 7;
#[doc = "< 8) Unresolved dest"]
pub const COL_UNRES_DST: _bindgen_ty_21 = 8;
#[doc = "< 9) Resolved dest port"]
pub const COL_RES_DST_PORT: _bindgen_ty_21 = 9;
#[doc = "< 10) Unresolved dest port"]
pub const COL_UNRES_DST_PORT: _bindgen_ty_21 = 10;
#[doc = "< 11) Destination address"]
pub const COL_DEF_DST: _bindgen_ty_21 = 11;
#[doc = "< 12) Destination port"]
pub const COL_DEF_DST_PORT: _bindgen_ty_21 = 12;
#[doc = "< 13) Expert Info"]
pub const COL_EXPERT: _bindgen_ty_21 = 13;
#[doc = "< 14) FW-1 monitor interface/direction"]
pub const COL_IF_DIR: _bindgen_ty_21 = 14;
#[doc = "< 15) IEEE 802.11 (and WiMax?) - Channel"]
pub const COL_FREQ_CHAN: _bindgen_ty_21 = 15;
#[doc = "< 16) Data link layer dest address"]
pub const COL_DEF_DL_DST: _bindgen_ty_21 = 16;
#[doc = "< 17) Data link layer source address"]
pub const COL_DEF_DL_SRC: _bindgen_ty_21 = 17;
#[doc = "< 18) Resolved DL dest"]
pub const COL_RES_DL_DST: _bindgen_ty_21 = 18;
#[doc = "< 19) Unresolved DL dest"]
pub const COL_UNRES_DL_DST: _bindgen_ty_21 = 19;
#[doc = "< 20) Resolved DL source"]
pub const COL_RES_DL_SRC: _bindgen_ty_21 = 20;
#[doc = "< 21) Unresolved DL source"]
pub const COL_UNRES_DL_SRC: _bindgen_ty_21 = 21;
#[doc = "< 22) IEEE 802.11 - received signal strength"]
pub const COL_RSSI: _bindgen_ty_21 = 22;
#[doc = "< 23) IEEE 802.11 - TX rate in Mbps"]
pub const COL_TX_RATE: _bindgen_ty_21 = 23;
#[doc = "< 24) IP DSCP Value"]
pub const COL_DSCP_VALUE: _bindgen_ty_21 = 24;
#[doc = "< 25) Description"]
pub const COL_INFO: _bindgen_ty_21 = 25;
#[doc = "< 26) Resolved net dest"]
pub const COL_RES_NET_DST: _bindgen_ty_21 = 26;
#[doc = "< 27) Unresolved net dest"]
pub const COL_UNRES_NET_DST: _bindgen_ty_21 = 27;
#[doc = "< 28) Resolved net source"]
pub const COL_RES_NET_SRC: _bindgen_ty_21 = 28;
#[doc = "< 29) Unresolved net source"]
pub const COL_UNRES_NET_SRC: _bindgen_ty_21 = 29;
#[doc = "< 30) Network layer dest address"]
pub const COL_DEF_NET_DST: _bindgen_ty_21 = 30;
#[doc = "< 31) Network layer source address"]
pub const COL_DEF_NET_SRC: _bindgen_ty_21 = 31;
#[doc = "< 32) Packet list item number"]
pub const COL_NUMBER: _bindgen_ty_21 = 32;
#[doc = "< 33) Packet length in bytes"]
pub const COL_PACKET_LENGTH: _bindgen_ty_21 = 33;
#[doc = "< 34) Protocol"]
pub const COL_PROTOCOL: _bindgen_ty_21 = 34;
#[doc = "< 35) Relative time"]
pub const COL_REL_TIME: _bindgen_ty_21 = 35;
#[doc = "< 36) Source address"]
pub const COL_DEF_SRC: _bindgen_ty_21 = 36;
#[doc = "< 37) Source port"]
pub const COL_DEF_SRC_PORT: _bindgen_ty_21 = 37;
#[doc = "< 38) Resolved source"]
pub const COL_RES_SRC: _bindgen_ty_21 = 38;
#[doc = "< 39) Unresolved source"]
pub const COL_UNRES_SRC: _bindgen_ty_21 = 39;
#[doc = "< 40) Resolved source port"]
pub const COL_RES_SRC_PORT: _bindgen_ty_21 = 40;
#[doc = "< 41) Unresolved source port"]
pub const COL_UNRES_SRC_PORT: _bindgen_ty_21 = 41;
#[doc = "< 42) UTC date, as YYYY-MM-DD, and time"]
pub const COL_UTC_YMD_TIME: _bindgen_ty_21 = 42;
#[doc = "< 43) UTC date, as YYYY/DOY, and time"]
pub const COL_UTC_YDOY_TIME: _bindgen_ty_21 = 43;
#[doc = "< 44) UTC time"]
pub const COL_UTC_TIME: _bindgen_ty_21 = 44;
#[doc = "< 45) Command line-specified time (default relative)"]
pub const COL_CLS_TIME: _bindgen_ty_21 = 45;
#[doc = "< 46) Should always be last"]
pub const NUM_COL_FMTS: _bindgen_ty_21 = 46;
#[doc = " All of the possible columns in summary listing.\n\n NOTE1: The entries MUST remain in this order, or else you need to reorder\n        the slist[] and dlist[] arrays in column.c to match!\n\n NOTE2: Please add the COL_XYZ entry in the appropriate spot, such that the\n        dlist[] array remains in alphabetical order!"]
pub type _bindgen_ty_21 = ::std::os::raw::c_uint;
extern "C" {
    #[doc = " Clears the text of a column element.\n\n @param cinfo the current packet row\n @param col the column to use, e.g. COL_INFO"]
    pub fn col_clear(cinfo: *mut column_info, col: gint);
}
extern "C" {
    #[doc = " Set (replace) the text of a column element, the text won't be formatted or copied.\n\n Use this for simple static strings like protocol names. Don't use for untrusted strings\n or strings that may contain unprintable characters.\n\n Usually used to set const strings!\n\n @param cinfo the current packet row\n @param col the column to use, e.g. COL_INFO\n @param str the string to set"]
    pub fn col_set_str(cinfo: *mut column_info, col: gint, str_: *const gchar);
}
extern "C" {
    #[doc = " Append the given text to a column element, the text will be formatted and copied.\n\n Unprintable characters according to isprint() are escaped.\n\n @param cinfo the current packet row\n @param col the column to use, e.g. COL_INFO\n @param str the string to append"]
    pub fn col_append_str(cinfo: *mut column_info, col: gint, str_: *const gchar);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dissector_handle {
    _unused: [u8; 0],
}
pub type dissector_handle_t = *mut dissector_handle;
pub type dissector_t = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *mut tvbuff_t,
        arg2: *mut packet_info,
        arg3: *mut proto_tree,
        arg4: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " Type of a heuristic dissector, used in heur_dissector_add().\n\n @param tvb the tvbuff with the (remaining) packet data\n @param pinfo the packet info of this packet (additional info)\n @param tree the protocol tree to be build or NULL\n @return TRUE if the packet was recognized by the sub-dissector (stop dissection here)"]
pub type heur_dissector_t = ::std::option::Option<
    unsafe extern "C" fn(
        tvb: *mut tvbuff_t,
        pinfo: *mut packet_info,
        tree: *mut proto_tree,
        arg1: *mut ::std::os::raw::c_void,
    ) -> gboolean,
>;
pub const heuristic_enable_e_HEURISTIC_DISABLE: heuristic_enable_e = 0;
pub const heuristic_enable_e_HEURISTIC_ENABLE: heuristic_enable_e = 1;
pub type heuristic_enable_e = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct heur_dtbl_entry {
    pub dissector: heur_dissector_t,
    pub protocol: *mut protocol_t,
    pub list_name: *mut gchar,
    pub display_name: *const gchar,
    pub short_name: *mut gchar,
    pub enabled: gboolean,
    pub enabled_by_default: bool,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of heur_dtbl_entry"][::std::mem::size_of::<heur_dtbl_entry>() - 48usize];
    ["Alignment of heur_dtbl_entry"][::std::mem::align_of::<heur_dtbl_entry>() - 8usize];
    ["Offset of field: heur_dtbl_entry::dissector"]
        [::std::mem::offset_of!(heur_dtbl_entry, dissector) - 0usize];
    ["Offset of field: heur_dtbl_entry::protocol"]
        [::std::mem::offset_of!(heur_dtbl_entry, protocol) - 8usize];
    ["Offset of field: heur_dtbl_entry::list_name"]
        [::std::mem::offset_of!(heur_dtbl_entry, list_name) - 16usize];
    ["Offset of field: heur_dtbl_entry::display_name"]
        [::std::mem::offset_of!(heur_dtbl_entry, display_name) - 24usize];
    ["Offset of field: heur_dtbl_entry::short_name"]
        [::std::mem::offset_of!(heur_dtbl_entry, short_name) - 32usize];
    ["Offset of field: heur_dtbl_entry::enabled"]
        [::std::mem::offset_of!(heur_dtbl_entry, enabled) - 40usize];
    ["Offset of field: heur_dtbl_entry::enabled_by_default"]
        [::std::mem::offset_of!(heur_dtbl_entry, enabled_by_default) - 44usize];
};
pub type DATFunc_heur = ::std::option::Option<
    unsafe extern "C" fn(
        table_name: *const gchar,
        entry: *mut heur_dtbl_entry,
        user_data: gpointer,
    ),
>;
extern "C" {
    #[doc = " Iterate over heuristic dissectors in a table.\n\n Walk one heuristic dissector table's list calling a user supplied function\n on each entry.\n\n @param[in] table_name The name of the dissector table, e.g. \"tcp\".\n @param[in] func The function to call for each dissector.\n @param[in] user_data User data to pass to the function."]
    pub fn heur_dissector_table_foreach(
        table_name: *const ::std::os::raw::c_char,
        func: DATFunc_heur,
        user_data: gpointer,
    );
}
extern "C" {
    #[doc = " Add a sub-dissector to a heuristic dissector list.\n  Call this in the proto_handoff function of the sub-dissector.\n\n @param name the name of the heuristic dissector table into which to register the dissector, e.g. \"tcp\"\n @param dissector the sub-dissector to be registered\n @param display_name the string used to present heuristic to user, e.g. \"HTTP over TCP\"\n @param internal_name the string used for \"internal\" use to identify heuristic, e.g. \"http_tcp\"\n @param proto the protocol id of the sub-dissector\n @param enable initially enabled or not"]
    pub fn heur_dissector_add(
        name: *const ::std::os::raw::c_char,
        dissector: heur_dissector_t,
        display_name: *const ::std::os::raw::c_char,
        internal_name: *const ::std::os::raw::c_char,
        proto: ::std::os::raw::c_int,
        enable: heuristic_enable_e,
    );
}
extern "C" {
    #[doc = " Remove a sub-dissector from a heuristic dissector list.\n  Call this in the prefs_reinit function of the sub-dissector.\n\n @param name the name of the \"parent\" protocol, e.g. \"tcp\"\n @param dissector the sub-dissector to be unregistered\n @param proto the protocol id of the sub-dissector"]
    pub fn heur_dissector_delete(
        name: *const ::std::os::raw::c_char,
        dissector: heur_dissector_t,
        proto: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn create_dissector_handle_with_name_and_description(
        dissector: dissector_t,
        proto: ::std::os::raw::c_int,
        name: *const ::std::os::raw::c_char,
        description: *const ::std::os::raw::c_char,
    ) -> dissector_handle_t;
}
pub const conversation_type_CONVERSATION_NONE: conversation_type = 0;
pub const conversation_type_CONVERSATION_SCTP: conversation_type = 1;
pub const conversation_type_CONVERSATION_TCP: conversation_type = 2;
pub const conversation_type_CONVERSATION_UDP: conversation_type = 3;
pub const conversation_type_CONVERSATION_DCCP: conversation_type = 4;
pub const conversation_type_CONVERSATION_IPX: conversation_type = 5;
pub const conversation_type_CONVERSATION_NCP: conversation_type = 6;
pub const conversation_type_CONVERSATION_EXCHG: conversation_type = 7;
pub const conversation_type_CONVERSATION_DDP: conversation_type = 8;
pub const conversation_type_CONVERSATION_SBCCS: conversation_type = 9;
pub const conversation_type_CONVERSATION_IDP: conversation_type = 10;
pub const conversation_type_CONVERSATION_TIPC: conversation_type = 11;
pub const conversation_type_CONVERSATION_USB: conversation_type = 12;
pub const conversation_type_CONVERSATION_I2C: conversation_type = 13;
pub const conversation_type_CONVERSATION_IBQP: conversation_type = 14;
pub const conversation_type_CONVERSATION_BLUETOOTH: conversation_type = 15;
pub const conversation_type_CONVERSATION_TDMOP: conversation_type = 16;
pub const conversation_type_CONVERSATION_DVBCI: conversation_type = 17;
pub const conversation_type_CONVERSATION_ISO14443: conversation_type = 18;
pub const conversation_type_CONVERSATION_ISDN: conversation_type = 19;
pub const conversation_type_CONVERSATION_H223: conversation_type = 20;
pub const conversation_type_CONVERSATION_X25: conversation_type = 21;
pub const conversation_type_CONVERSATION_IAX2: conversation_type = 22;
pub const conversation_type_CONVERSATION_DLCI: conversation_type = 23;
pub const conversation_type_CONVERSATION_ISUP: conversation_type = 24;
pub const conversation_type_CONVERSATION_BICC: conversation_type = 25;
pub const conversation_type_CONVERSATION_GSMTAP: conversation_type = 26;
pub const conversation_type_CONVERSATION_IUUP: conversation_type = 27;
pub const conversation_type_CONVERSATION_DVBBBF: conversation_type = 28;
pub const conversation_type_CONVERSATION_IWARP_MPA: conversation_type = 29;
pub const conversation_type_CONVERSATION_BT_UTP: conversation_type = 30;
pub const conversation_type_CONVERSATION_LOG: conversation_type = 31;
pub const conversation_type_CONVERSATION_LTP: conversation_type = 32;
pub const conversation_type_CONVERSATION_MCTP: conversation_type = 33;
pub const conversation_type_CONVERSATION_NVME_MI: conversation_type = 34;
pub const conversation_type_CONVERSATION_BP: conversation_type = 35;
pub const conversation_type_CONVERSATION_SNMP: conversation_type = 36;
pub const conversation_type_CONVERSATION_QUIC: conversation_type = 37;
pub const conversation_type_CONVERSATION_IDN: conversation_type = 38;
pub type conversation_type = ::std::os::raw::c_uint;
#[doc = " Elements used to identify conversations for *_full routines and\n pinfo->conv_elements.\n Arrays must be terminated with an element .type set to CE_CONVERSATION_TYPE.\n\n This is currently set only by conversation_set_elements_by_id(); it\n is not set for conversations identified by address/port endpoints.\n\n In find_conversation_pinfo() and find_or_create_conversation(), if\n any dissector has set this, then, unless some dissector has set the\n pair of address/port endpoints (see below), the array of elements\n is used to look up or create the conversation.  Otherwise, the\n current addresses and ports in the packet_info structure are used.\n\n XXX - is there any reason why we shouldn't use an array of conversation\n elements, with the appropriate addresses and ports, and set it for\n all protocols that use conversations specified by a pair of address/port\n endpoints?  That might simplify find_conversation_pinfo() by having\n them always use the array of elements if it's present, and just fail if\n it's not."]
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Copy, Clone)]
pub struct conversation_element {
    pub _bindgen_opaque_blob: [u64; 4usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union conversation_element__bindgen_ty_1 {
    pub conversation_type_val: conversation_type,
    pub addr_val: address,
    pub port_val: ::std::os::raw::c_uint,
    pub str_val: *const ::std::os::raw::c_char,
    pub uint_val: ::std::os::raw::c_uint,
    pub uint64_val: u64,
    pub int_val: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of conversation_element__bindgen_ty_1"]
        [::std::mem::size_of::<conversation_element__bindgen_ty_1>() - 24usize];
    ["Alignment of conversation_element__bindgen_ty_1"]
        [::std::mem::align_of::<conversation_element__bindgen_ty_1>() - 8usize];
    ["Offset of field: conversation_element__bindgen_ty_1::conversation_type_val"][::std::mem::offset_of!(
        conversation_element__bindgen_ty_1,
        conversation_type_val
    ) - 0usize];
    ["Offset of field: conversation_element__bindgen_ty_1::addr_val"]
        [::std::mem::offset_of!(conversation_element__bindgen_ty_1, addr_val) - 0usize];
    ["Offset of field: conversation_element__bindgen_ty_1::port_val"]
        [::std::mem::offset_of!(conversation_element__bindgen_ty_1, port_val) - 0usize];
    ["Offset of field: conversation_element__bindgen_ty_1::str_val"]
        [::std::mem::offset_of!(conversation_element__bindgen_ty_1, str_val) - 0usize];
    ["Offset of field: conversation_element__bindgen_ty_1::uint_val"]
        [::std::mem::offset_of!(conversation_element__bindgen_ty_1, uint_val) - 0usize];
    ["Offset of field: conversation_element__bindgen_ty_1::uint64_val"]
        [::std::mem::offset_of!(conversation_element__bindgen_ty_1, uint64_val) - 0usize];
    ["Offset of field: conversation_element__bindgen_ty_1::int_val"]
        [::std::mem::offset_of!(conversation_element__bindgen_ty_1, int_val) - 0usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of conversation_element"][::std::mem::size_of::<conversation_element>() - 32usize];
    ["Alignment of conversation_element"][::std::mem::align_of::<conversation_element>() - 8usize];
};
#[doc = " Elements used to identify conversations for *_full routines and\n pinfo->conv_elements.\n Arrays must be terminated with an element .type set to CE_CONVERSATION_TYPE.\n\n This is currently set only by conversation_set_elements_by_id(); it\n is not set for conversations identified by address/port endpoints.\n\n In find_conversation_pinfo() and find_or_create_conversation(), if\n any dissector has set this, then, unless some dissector has set the\n pair of address/port endpoints (see below), the array of elements\n is used to look up or create the conversation.  Otherwise, the\n current addresses and ports in the packet_info structure are used.\n\n XXX - is there any reason why we shouldn't use an array of conversation\n elements, with the appropriate addresses and ports, and set it for\n all protocols that use conversations specified by a pair of address/port\n endpoints?  That might simplify find_conversation_pinfo() by having\n them always use the array of elements if it's present, and just fail if\n it's not."]
pub type conversation_element_t = conversation_element;
#[doc = " Data structure representing a conversation."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct conversation {
    pub next: *mut conversation,
    #[doc = " pointer to next conversation on hash chain"]
    pub last: *mut conversation,
    #[doc = " pointer to the last conversation on hash chain"]
    pub latest_found: *mut conversation,
    #[doc = " pointer to the last conversation on hash chain"]
    pub conv_index: guint32,
    #[doc = " unique ID for conversation"]
    pub setup_frame: guint32,
    #[doc = " frame number that setup this conversation"]
    pub last_frame: guint32,
    #[doc = " highest frame number in this conversation"]
    pub data_list: *mut wmem_tree_t,
    #[doc = " list of data associated with conversation"]
    pub dissector_tree: *mut wmem_tree_t,
    #[doc = " tree containing protocol dissector client associated with conversation"]
    pub options: guint,
    #[doc = " wildcard flags"]
    pub key_ptr: *mut conversation_element_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of conversation"][::std::mem::size_of::<conversation>() - 72usize];
    ["Alignment of conversation"][::std::mem::align_of::<conversation>() - 8usize];
    ["Offset of field: conversation::next"][::std::mem::offset_of!(conversation, next) - 0usize];
    ["Offset of field: conversation::last"][::std::mem::offset_of!(conversation, last) - 8usize];
    ["Offset of field: conversation::latest_found"]
        [::std::mem::offset_of!(conversation, latest_found) - 16usize];
    ["Offset of field: conversation::conv_index"]
        [::std::mem::offset_of!(conversation, conv_index) - 24usize];
    ["Offset of field: conversation::setup_frame"]
        [::std::mem::offset_of!(conversation, setup_frame) - 28usize];
    ["Offset of field: conversation::last_frame"]
        [::std::mem::offset_of!(conversation, last_frame) - 32usize];
    ["Offset of field: conversation::data_list"]
        [::std::mem::offset_of!(conversation, data_list) - 40usize];
    ["Offset of field: conversation::dissector_tree"]
        [::std::mem::offset_of!(conversation, dissector_tree) - 48usize];
    ["Offset of field: conversation::options"]
        [::std::mem::offset_of!(conversation, options) - 56usize];
    ["Offset of field: conversation::key_ptr"]
        [::std::mem::offset_of!(conversation, key_ptr) - 64usize];
};
#[doc = " Data structure representing a conversation."]
pub type conversation_t = conversation;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct conversation_addr_port_endpoints {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = " A helper function that calls find_conversation() and, if a conversation is\n not found, calls conversation_new().\n The frame number and addresses are taken from pinfo.\n No options are used, though we could extend this API to include an options\n parameter.\n\n @param pinfo Packet info.\n @return The existing or new conversation."]
    pub fn find_or_create_conversation(pinfo: *mut packet_info) -> *mut conversation_t;
}
extern "C" {
    pub fn conversation_set_dissector(
        conversation: *mut conversation_t,
        handle: dissector_handle_t,
    );
}
pub type __builtin_va_list = [__va_list_tag; 1usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __va_list_tag {
    pub gp_offset: ::std::os::raw::c_uint,
    pub fp_offset: ::std::os::raw::c_uint,
    pub overflow_arg_area: *mut ::std::os::raw::c_void,
    pub reg_save_area: *mut ::std::os::raw::c_void,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __va_list_tag"][::std::mem::size_of::<__va_list_tag>() - 24usize];
    ["Alignment of __va_list_tag"][::std::mem::align_of::<__va_list_tag>() - 8usize];
    ["Offset of field: __va_list_tag::gp_offset"]
        [::std::mem::offset_of!(__va_list_tag, gp_offset) - 0usize];
    ["Offset of field: __va_list_tag::fp_offset"]
        [::std::mem::offset_of!(__va_list_tag, fp_offset) - 4usize];
    ["Offset of field: __va_list_tag::overflow_arg_area"]
        [::std::mem::offset_of!(__va_list_tag, overflow_arg_area) - 8usize];
    ["Offset of field: __va_list_tag::reg_save_area"]
        [::std::mem::offset_of!(__va_list_tag, reg_save_area) - 16usize];
};
#[repr(C)]
#[derive(Copy, Clone)]
pub union wtap_pseudo_header {
    pub _address: u8,
}
