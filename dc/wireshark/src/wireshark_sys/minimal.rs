/* automatically generated by rust-bindgen 0.69.4 */

// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
// SPDX-License-Identifier: Apache-2.0

#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage> {
    storage: Storage,
}
impl<Storage> __BindgenBitfieldUnit<Storage> {
    #[inline]
    pub const fn new(storage: Storage) -> Self {
        Self { storage }
    }
}
impl<Storage> __BindgenBitfieldUnit<Storage>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        byte & mask == mask
    }
    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        if val {
            *byte |= mask;
        } else {
            *byte &= !mask;
        }
    }
    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            self.set_bit(index + bit_offset, val_bit_is_set);
        }
    }
}
pub const DESEGMENT_ONE_MORE_SEGMENT: u32 = 268435455;
pub const DESEGMENT_UNTIL_FIN: u32 = 268435454;
pub const ENC_BIG_ENDIAN: u32 = 0;
pub type __time_t = ::std::os::raw::c_long;
pub type guint8 = ::std::os::raw::c_uchar;
pub type gint16 = ::std::os::raw::c_short;
pub type guint16 = ::std::os::raw::c_ushort;
pub type guint32 = ::std::os::raw::c_uint;
pub type guint64 = ::std::os::raw::c_ulong;
pub type time_t = __time_t;
pub type gchar = ::std::os::raw::c_char;
pub type gint = ::std::os::raw::c_int;
pub type gboolean = gint;
pub type guint = ::std::os::raw::c_uint;
pub type GHashTable = u8;
pub type GSList = [u64; 2usize];
#[doc = " @defgroup wmem Wireshark Memory Manager\n\n Wmem is a memory management framework for Wireshark that makes it simple to\n write dissectors (and other 'user-space' code) that doesn't leak memory. The\n core module provides basic functions like malloc, realloc and free, but\n many other functions are available (see the \"Modules\" list at the top of\n the generated doxygen HTML).\n\n Any wmem functions which allocate memory are guaranteed to either succeed or\n abort the program. However, they *can* still legally return NULL when the\n amount of requested memory is zero.\n\n @{"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _wmem_allocator_t {
    _unused: [u8; 0],
}
#[doc = " A public opaque type representing one wmem allocation pool."]
pub type wmem_allocator_t = _wmem_allocator_t;
#[doc = " @addtogroup wmem\n  @{\n    @defgroup wmem-list Doubly-Linked List\n\n    A doubly-linked list implementation on top of wmem.\n\n    @{"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _wmem_list_t {
    _unused: [u8; 0],
}
pub type wmem_list_t = _wmem_list_t;
#[doc = " @addtogroup wmem\n  @{\n    @defgroup wmem-map Hash Map\n\n    A hash map implementation on top of wmem. Provides insertion, deletion and\n    lookup in expected amortized constant time. Uses universal hashing to map\n    keys into buckets, and provides a generic strong hash function that makes\n    it secure against algorithmic complexity attacks, and suitable for use\n    even with untrusted data.\n\n    @{"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _wmem_map_t {
    _unused: [u8; 0],
}
pub type wmem_map_t = _wmem_map_t;
#[doc = " data structure to hold time values with nanosecond resolution"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nstime_t {
    pub secs: time_t,
    pub nsecs: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_nstime_t() {
    const UNINIT: ::std::mem::MaybeUninit<nstime_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<nstime_t>(),
        16usize,
        concat!("Size of: ", stringify!(nstime_t))
    );
    assert_eq!(
        ::std::mem::align_of::<nstime_t>(),
        8usize,
        concat!("Alignment of ", stringify!(nstime_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).secs) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nstime_t),
            "::",
            stringify!(secs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nsecs) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(nstime_t),
            "::",
            stringify!(nsecs)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wtap_rec {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct epan_session {
    _unused: [u8; 0],
}
pub type frame_data = [u64; 13usize];
#[doc = " \"testy, virtual(-izable) buffer\".  They are testy in that they get mad when\n an attempt is made to access data beyond the bounds of their array. In that\n case, they throw an exception.\n\n They are virtualizable in that new tvbuff's can be made from other tvbuffs,\n while only the original tvbuff may have data. That is, the new tvbuff has\n virtual data."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tvbuff {
    _unused: [u8; 0],
}
pub type tvbuff_t = u8;
pub type address = [u64; 3usize];
pub const port_type_PT_NONE: port_type = 0;
pub const port_type_PT_SCTP: port_type = 1;
pub const port_type_PT_TCP: port_type = 2;
pub const port_type_PT_UDP: port_type = 3;
pub const port_type_PT_DCCP: port_type = 4;
pub const port_type_PT_IPX: port_type = 5;
pub const port_type_PT_DDP: port_type = 6;
pub const port_type_PT_IDP: port_type = 7;
pub const port_type_PT_USB: port_type = 8;
pub const port_type_PT_I2C: port_type = 9;
pub const port_type_PT_IBQP: port_type = 10;
pub const port_type_PT_BLUETOOTH: port_type = 11;
pub const port_type_PT_IWARP_MPA: port_type = 12;
pub const port_type_PT_MCTP: port_type = 13;
pub type port_type = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _packet_info {
    #[doc = "< name of protocol currently being dissected"]
    pub current_proto: *const ::std::os::raw::c_char,
    #[doc = "< Column formatting information"]
    pub cinfo: *mut epan_column_info,
    #[doc = "< Presence flags for some items"]
    pub presence_flags: guint32,
    #[doc = "< Frame number"]
    pub num: guint32,
    #[doc = "< Packet absolute time stamp"]
    pub abs_ts: nstime_t,
    #[doc = "< Relative timestamp (yes, it can be negative)"]
    pub rel_ts: nstime_t,
    #[doc = "< Relative timestamp from capture start (might be negative for broken files)"]
    pub rel_cap_ts: nstime_t,
    #[doc = "< Relative timestamp from capture start valid"]
    pub rel_cap_ts_present: gboolean,
    pub fd: *mut frame_data,
    pub pseudo_header: *mut wtap_pseudo_header,
    #[doc = "< Record metadata"]
    pub rec: *mut wtap_rec,
    #[doc = "< Frame data sources"]
    pub data_src: *mut GSList,
    #[doc = "< link-layer source address"]
    pub dl_src: address,
    #[doc = "< link-layer destination address"]
    pub dl_dst: address,
    #[doc = "< network-layer source address"]
    pub net_src: address,
    #[doc = "< network-layer destination address"]
    pub net_dst: address,
    #[doc = "< source address (net if present, DL otherwise )"]
    pub src: address,
    #[doc = "< destination address (net if present, DL otherwise )"]
    pub dst: address,
    #[doc = "< First encountered VLAN Id if present otherwise 0"]
    pub vlan_id: guint32,
    #[doc = "< reason why reassembly wasn't done, if any"]
    pub noreassembly_reason: *const ::std::os::raw::c_char,
    #[doc = "< TRUE if the protocol is only a fragment"]
    pub fragmented: gboolean,
    pub flags: _packet_info__bindgen_ty_1,
    #[doc = "< type of the following two port numbers"]
    pub ptype: port_type,
    #[doc = "< source port"]
    pub srcport: guint32,
    #[doc = "< destination port"]
    pub destport: guint32,
    #[doc = "< matched uint for calling subdissector from table"]
    pub match_uint: guint32,
    #[doc = "< matched string for calling subdissector from table"]
    pub match_string: *const ::std::os::raw::c_char,
    #[doc = "< TRUE if address/port endpoints member should be used for conversations"]
    pub use_conv_addr_port_endpoints: gboolean,
    #[doc = "< Data that can be used for address+port conversations, including wildcarding"]
    pub conv_addr_port_endpoints: *mut conversation_addr_port_endpoints,
    #[doc = "< Arbritrary conversation identifier; can't be wildcarded"]
    pub conv_elements: *mut conversation_element,
    #[doc = "< >0 if this segment could be desegmented.\nA dissector that can offer this API (e.g.\nTCP) sets can_desegment=2, then\ncan_desegment is decremented by 1 each time\nwe pass to the next subdissector. Thus only\nthe dissector immediately above the\nprotocol which sets the flag can use it"]
    pub can_desegment: guint16,
    #[doc = "< Value of can_desegment before current\ndissector was called.  Supplied so that\ndissectors for proxy protocols such as\nSOCKS can restore it, allowing the\ndissectors that they call to use the\nTCP dissector's desegmentation (SOCKS\njust retransmits TCP segments once it's\nfinished setting things up, so the TCP\ndesegmentor can desegment its payload)."]
    pub saved_can_desegment: guint16,
    #[doc = "< offset to stuff needing desegmentation"]
    pub desegment_offset: ::std::os::raw::c_int,
    #[doc = "< requested desegmentation additional length\nor\nDESEGMENT_ONE_MORE_SEGMENT:\nDesegment one more full segment\n(warning! only partially implemented)\nDESEGMENT_UNTIL_FIN:\nDesgment all data for this tcp session\nuntil the FIN segment."]
    pub desegment_len: guint32,
    #[doc = "< >0 if the subdissector has specified\na value in 'bytes_until_next_pdu'.\nWhen a dissector detects that the next PDU\nwill start beyond the start of the next\nsegment, it can set this value to 2\nand 'bytes_until_next_pdu' to the number of\nbytes beyond the next segment where the\nnext PDU starts.\n\nIf the protocol dissector below this\none is capable of PDU tracking it can\nuse this hint to detect PDUs that starts\nunaligned to the segment boundaries.\nThe TCP dissector is using this hint from\n(some) protocols to detect when a new PDU\nstarts in the middle of a tcp segment.\n\nThere is intelligence in the glue between\ndissector layers to make sure that this\nrequest is only passed down to the protocol\nimmediately below the current one and not\nany further."]
    pub want_pdu_tracking: guint16,
    pub bytes_until_next_pdu: guint32,
    #[doc = "< Packet was captured as an\noutbound (P2P_DIR_SENT)\ninbound (P2P_DIR_RECV)\nunknown (P2P_DIR_UNKNOWN)"]
    pub p2p_dir: ::std::os::raw::c_int,
    #[doc = "< a hash table passed from one dissector to another"]
    pub private_table: *mut GHashTable,
    #[doc = "< layers of each protocol"]
    pub layers: *mut wmem_list_t,
    pub proto_layers: *mut wmem_map_t,
    #[doc = "< The current \"depth\" or layer number in the current frame"]
    pub curr_layer_num: guint8,
    #[doc = "< The current \"depth\" or layer number for this dissector in the current frame"]
    pub curr_proto_layer_num: guint8,
    pub link_number: guint16,
    #[doc = "< clnp/cotp source reference (can't use srcport, this would confuse tpkt)"]
    pub clnp_srcref: guint16,
    #[doc = "< clnp/cotp destination reference (can't use dstport, this would confuse tpkt)"]
    pub clnp_dstref: guint16,
    #[doc = "< 3GPP messages are sometime different UP link(UL) or Downlink(DL)"]
    pub link_dir: ::std::os::raw::c_int,
    #[doc = "< Rcv.Wind.Shift src applies when sending segments; -1 unknown; -2 disabled"]
    pub src_win_scale: gint16,
    #[doc = "< Rcv.Wind.Shift dst applies when sending segments; -1 unknown; -2 disabled"]
    pub dst_win_scale: gint16,
    #[doc = "< Per packet proto data"]
    pub proto_data: *mut GSList,
    pub frame_end_routines: *mut GSList,
    #[doc = "< Memory pool scoped to the pinfo struct"]
    pub pool: *mut wmem_allocator_t,
    pub epan: *mut epan_session,
    #[doc = "< name of heur list if this packet is being heuristically dissected"]
    pub heur_list_name: *const gchar,
    #[doc = "< The current \"depth\" or layer number in the current frame"]
    pub dissection_depth: ::std::os::raw::c_int,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct _packet_info__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: [u8; 3usize],
}
#[test]
fn bindgen_test_layout__packet_info__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<_packet_info__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(_packet_info__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<_packet_info__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(_packet_info__bindgen_ty_1))
    );
}
impl _packet_info__bindgen_ty_1 {
    #[inline]
    pub fn in_error_pkt(&self) -> guint32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_in_error_pkt(&mut self, val: guint32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn in_gre_pkt(&self) -> guint32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_in_gre_pkt(&mut self, val: guint32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        in_error_pkt: guint32,
        in_gre_pkt: guint32,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let in_error_pkt: u32 = unsafe { ::std::mem::transmute(in_error_pkt) };
            in_error_pkt as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let in_gre_pkt: u32 = unsafe { ::std::mem::transmute(in_gre_pkt) };
            in_gre_pkt as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout__packet_info() {
    const UNINIT: ::std::mem::MaybeUninit<_packet_info> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_packet_info>(),
        440usize,
        concat!("Size of: ", stringify!(_packet_info))
    );
    assert_eq!(
        ::std::mem::align_of::<_packet_info>(),
        8usize,
        concat!("Alignment of ", stringify!(_packet_info))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).current_proto) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_packet_info),
            "::",
            stringify!(current_proto)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cinfo) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_packet_info),
            "::",
            stringify!(cinfo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).presence_flags) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_packet_info),
            "::",
            stringify!(presence_flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).num) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_packet_info),
            "::",
            stringify!(num)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).abs_ts) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_packet_info),
            "::",
            stringify!(abs_ts)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rel_ts) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_packet_info),
            "::",
            stringify!(rel_ts)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rel_cap_ts) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_packet_info),
            "::",
            stringify!(rel_cap_ts)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rel_cap_ts_present) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_packet_info),
            "::",
            stringify!(rel_cap_ts_present)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fd) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_packet_info),
            "::",
            stringify!(fd)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pseudo_header) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_packet_info),
            "::",
            stringify!(pseudo_header)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rec) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(_packet_info),
            "::",
            stringify!(rec)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data_src) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(_packet_info),
            "::",
            stringify!(data_src)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dl_src) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(_packet_info),
            "::",
            stringify!(dl_src)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dl_dst) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_packet_info),
            "::",
            stringify!(dl_dst)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).net_src) as usize - ptr as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(_packet_info),
            "::",
            stringify!(net_src)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).net_dst) as usize - ptr as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(_packet_info),
            "::",
            stringify!(net_dst)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).src) as usize - ptr as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(_packet_info),
            "::",
            stringify!(src)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dst) as usize - ptr as usize },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(_packet_info),
            "::",
            stringify!(dst)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vlan_id) as usize - ptr as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(_packet_info),
            "::",
            stringify!(vlan_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).noreassembly_reason) as usize - ptr as usize },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(_packet_info),
            "::",
            stringify!(noreassembly_reason)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fragmented) as usize - ptr as usize },
        272usize,
        concat!(
            "Offset of field: ",
            stringify!(_packet_info),
            "::",
            stringify!(fragmented)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        276usize,
        concat!(
            "Offset of field: ",
            stringify!(_packet_info),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ptype) as usize - ptr as usize },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(_packet_info),
            "::",
            stringify!(ptype)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).srcport) as usize - ptr as usize },
        284usize,
        concat!(
            "Offset of field: ",
            stringify!(_packet_info),
            "::",
            stringify!(srcport)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).destport) as usize - ptr as usize },
        288usize,
        concat!(
            "Offset of field: ",
            stringify!(_packet_info),
            "::",
            stringify!(destport)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).match_uint) as usize - ptr as usize },
        292usize,
        concat!(
            "Offset of field: ",
            stringify!(_packet_info),
            "::",
            stringify!(match_uint)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).match_string) as usize - ptr as usize },
        296usize,
        concat!(
            "Offset of field: ",
            stringify!(_packet_info),
            "::",
            stringify!(match_string)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).use_conv_addr_port_endpoints) as usize - ptr as usize
        },
        304usize,
        concat!(
            "Offset of field: ",
            stringify!(_packet_info),
            "::",
            stringify!(use_conv_addr_port_endpoints)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).conv_addr_port_endpoints) as usize - ptr as usize },
        312usize,
        concat!(
            "Offset of field: ",
            stringify!(_packet_info),
            "::",
            stringify!(conv_addr_port_endpoints)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).conv_elements) as usize - ptr as usize },
        320usize,
        concat!(
            "Offset of field: ",
            stringify!(_packet_info),
            "::",
            stringify!(conv_elements)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).can_desegment) as usize - ptr as usize },
        328usize,
        concat!(
            "Offset of field: ",
            stringify!(_packet_info),
            "::",
            stringify!(can_desegment)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).saved_can_desegment) as usize - ptr as usize },
        330usize,
        concat!(
            "Offset of field: ",
            stringify!(_packet_info),
            "::",
            stringify!(saved_can_desegment)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).desegment_offset) as usize - ptr as usize },
        332usize,
        concat!(
            "Offset of field: ",
            stringify!(_packet_info),
            "::",
            stringify!(desegment_offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).desegment_len) as usize - ptr as usize },
        336usize,
        concat!(
            "Offset of field: ",
            stringify!(_packet_info),
            "::",
            stringify!(desegment_len)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).want_pdu_tracking) as usize - ptr as usize },
        340usize,
        concat!(
            "Offset of field: ",
            stringify!(_packet_info),
            "::",
            stringify!(want_pdu_tracking)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bytes_until_next_pdu) as usize - ptr as usize },
        344usize,
        concat!(
            "Offset of field: ",
            stringify!(_packet_info),
            "::",
            stringify!(bytes_until_next_pdu)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).p2p_dir) as usize - ptr as usize },
        348usize,
        concat!(
            "Offset of field: ",
            stringify!(_packet_info),
            "::",
            stringify!(p2p_dir)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).private_table) as usize - ptr as usize },
        352usize,
        concat!(
            "Offset of field: ",
            stringify!(_packet_info),
            "::",
            stringify!(private_table)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).layers) as usize - ptr as usize },
        360usize,
        concat!(
            "Offset of field: ",
            stringify!(_packet_info),
            "::",
            stringify!(layers)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).proto_layers) as usize - ptr as usize },
        368usize,
        concat!(
            "Offset of field: ",
            stringify!(_packet_info),
            "::",
            stringify!(proto_layers)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).curr_layer_num) as usize - ptr as usize },
        376usize,
        concat!(
            "Offset of field: ",
            stringify!(_packet_info),
            "::",
            stringify!(curr_layer_num)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).curr_proto_layer_num) as usize - ptr as usize },
        377usize,
        concat!(
            "Offset of field: ",
            stringify!(_packet_info),
            "::",
            stringify!(curr_proto_layer_num)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).link_number) as usize - ptr as usize },
        378usize,
        concat!(
            "Offset of field: ",
            stringify!(_packet_info),
            "::",
            stringify!(link_number)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).clnp_srcref) as usize - ptr as usize },
        380usize,
        concat!(
            "Offset of field: ",
            stringify!(_packet_info),
            "::",
            stringify!(clnp_srcref)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).clnp_dstref) as usize - ptr as usize },
        382usize,
        concat!(
            "Offset of field: ",
            stringify!(_packet_info),
            "::",
            stringify!(clnp_dstref)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).link_dir) as usize - ptr as usize },
        384usize,
        concat!(
            "Offset of field: ",
            stringify!(_packet_info),
            "::",
            stringify!(link_dir)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).src_win_scale) as usize - ptr as usize },
        388usize,
        concat!(
            "Offset of field: ",
            stringify!(_packet_info),
            "::",
            stringify!(src_win_scale)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dst_win_scale) as usize - ptr as usize },
        390usize,
        concat!(
            "Offset of field: ",
            stringify!(_packet_info),
            "::",
            stringify!(dst_win_scale)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).proto_data) as usize - ptr as usize },
        392usize,
        concat!(
            "Offset of field: ",
            stringify!(_packet_info),
            "::",
            stringify!(proto_data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).frame_end_routines) as usize - ptr as usize },
        400usize,
        concat!(
            "Offset of field: ",
            stringify!(_packet_info),
            "::",
            stringify!(frame_end_routines)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pool) as usize - ptr as usize },
        408usize,
        concat!(
            "Offset of field: ",
            stringify!(_packet_info),
            "::",
            stringify!(pool)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).epan) as usize - ptr as usize },
        416usize,
        concat!(
            "Offset of field: ",
            stringify!(_packet_info),
            "::",
            stringify!(epan)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).heur_list_name) as usize - ptr as usize },
        424usize,
        concat!(
            "Offset of field: ",
            stringify!(_packet_info),
            "::",
            stringify!(heur_list_name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dissection_depth) as usize - ptr as usize },
        432usize,
        concat!(
            "Offset of field: ",
            stringify!(_packet_info),
            "::",
            stringify!(dissection_depth)
        )
    );
}
pub const ftenum_FT_NONE: ftenum = 0;
pub const ftenum_FT_PROTOCOL: ftenum = 1;
pub const ftenum_FT_BOOLEAN: ftenum = 2;
pub const ftenum_FT_CHAR: ftenum = 3;
pub const ftenum_FT_UINT8: ftenum = 4;
pub const ftenum_FT_UINT16: ftenum = 5;
pub const ftenum_FT_UINT24: ftenum = 6;
pub const ftenum_FT_UINT32: ftenum = 7;
pub const ftenum_FT_UINT40: ftenum = 8;
pub const ftenum_FT_UINT48: ftenum = 9;
pub const ftenum_FT_UINT56: ftenum = 10;
pub const ftenum_FT_UINT64: ftenum = 11;
pub const ftenum_FT_INT8: ftenum = 12;
pub const ftenum_FT_INT16: ftenum = 13;
pub const ftenum_FT_INT24: ftenum = 14;
pub const ftenum_FT_INT32: ftenum = 15;
pub const ftenum_FT_INT40: ftenum = 16;
pub const ftenum_FT_INT48: ftenum = 17;
pub const ftenum_FT_INT56: ftenum = 18;
pub const ftenum_FT_INT64: ftenum = 19;
pub const ftenum_FT_IEEE_11073_SFLOAT: ftenum = 20;
pub const ftenum_FT_IEEE_11073_FLOAT: ftenum = 21;
pub const ftenum_FT_FLOAT: ftenum = 22;
pub const ftenum_FT_DOUBLE: ftenum = 23;
pub const ftenum_FT_ABSOLUTE_TIME: ftenum = 24;
pub const ftenum_FT_RELATIVE_TIME: ftenum = 25;
pub const ftenum_FT_STRING: ftenum = 26;
pub const ftenum_FT_STRINGZ: ftenum = 27;
pub const ftenum_FT_UINT_STRING: ftenum = 28;
pub const ftenum_FT_ETHER: ftenum = 29;
pub const ftenum_FT_BYTES: ftenum = 30;
pub const ftenum_FT_UINT_BYTES: ftenum = 31;
pub const ftenum_FT_IPv4: ftenum = 32;
pub const ftenum_FT_IPv6: ftenum = 33;
pub const ftenum_FT_IPXNET: ftenum = 34;
pub const ftenum_FT_FRAMENUM: ftenum = 35;
pub const ftenum_FT_GUID: ftenum = 36;
pub const ftenum_FT_OID: ftenum = 37;
pub const ftenum_FT_EUI64: ftenum = 38;
pub const ftenum_FT_AX25: ftenum = 39;
pub const ftenum_FT_VINES: ftenum = 40;
pub const ftenum_FT_REL_OID: ftenum = 41;
pub const ftenum_FT_SYSTEM_ID: ftenum = 42;
pub const ftenum_FT_STRINGZPAD: ftenum = 43;
pub const ftenum_FT_FCWWN: ftenum = 44;
pub const ftenum_FT_STRINGZTRUNC: ftenum = 45;
pub const ftenum_FT_NUM_TYPES: ftenum = 46;
pub type ftenum = ::std::os::raw::c_uint;
pub use self::ftenum as ftenum_t;
#[doc = "< none"]
pub const field_display_e_BASE_NONE: field_display_e = 0;
#[doc = "< decimal [integer, float]"]
pub const field_display_e_BASE_DEC: field_display_e = 1;
#[doc = "< hexadecimal [integer, float]"]
pub const field_display_e_BASE_HEX: field_display_e = 2;
#[doc = "< octal [integer]"]
pub const field_display_e_BASE_OCT: field_display_e = 3;
#[doc = "< decimal (hexadecimal) [integer]"]
pub const field_display_e_BASE_DEC_HEX: field_display_e = 4;
#[doc = "< hexadecimal (decimal) [integer]"]
pub const field_display_e_BASE_HEX_DEC: field_display_e = 5;
#[doc = "< call custom routine to format [integer, float]"]
pub const field_display_e_BASE_CUSTOM: field_display_e = 6;
#[doc = "< exponential [float]"]
pub const field_display_e_BASE_EXP: field_display_e = 7;
#[doc = "< hexadecimal bytes with a period (.) between each byte"]
pub const field_display_e_SEP_DOT: field_display_e = 8;
#[doc = "< hexadecimal bytes with a dash (-) between each byte"]
pub const field_display_e_SEP_DASH: field_display_e = 9;
#[doc = "< hexadecimal bytes with a colon (:) between each byte"]
pub const field_display_e_SEP_COLON: field_display_e = 10;
#[doc = "< hexadecimal bytes with a space between each byte"]
pub const field_display_e_SEP_SPACE: field_display_e = 11;
#[doc = "< Used for IPv4 address that shouldn't be resolved (like for netmasks)"]
pub const field_display_e_BASE_NETMASK: field_display_e = 12;
#[doc = "< UDP port"]
pub const field_display_e_BASE_PT_UDP: field_display_e = 13;
#[doc = "< TCP port"]
pub const field_display_e_BASE_PT_TCP: field_display_e = 14;
#[doc = "< DCCP port"]
pub const field_display_e_BASE_PT_DCCP: field_display_e = 15;
#[doc = "< SCTP port"]
pub const field_display_e_BASE_PT_SCTP: field_display_e = 16;
#[doc = "< OUI resolution"]
pub const field_display_e_BASE_OUI: field_display_e = 17;
#[doc = "< local time in our time zone, with month and day"]
pub const field_display_e_ABSOLUTE_TIME_LOCAL: field_display_e = 18;
#[doc = "< UTC, with month and day"]
pub const field_display_e_ABSOLUTE_TIME_UTC: field_display_e = 19;
#[doc = "< UTC, with 1-origin day-of-year"]
pub const field_display_e_ABSOLUTE_TIME_DOY_UTC: field_display_e = 20;
#[doc = "< UTC, with \"NULL\" when timestamp is all zeros"]
pub const field_display_e_ABSOLUTE_TIME_NTP_UTC: field_display_e = 21;
#[doc = "< Unix time"]
pub const field_display_e_ABSOLUTE_TIME_UNIX: field_display_e = 22;
#[doc = "< Replace all whitespace characters (newline, formfeed, etc) with \"space\"."]
pub const field_display_e_BASE_STR_WSP: field_display_e = 23;
pub type field_display_e = ::std::os::raw::c_uint;
#[doc = "< Field is not referenced"]
pub const hf_ref_type_HF_REF_TYPE_NONE: hf_ref_type = 0;
#[doc = "< Field is indirectly referenced (only applicable for FT_PROTOCOL) via. its child"]
pub const hf_ref_type_HF_REF_TYPE_INDIRECT: hf_ref_type = 1;
#[doc = "< Field is directly referenced"]
pub const hf_ref_type_HF_REF_TYPE_DIRECT: hf_ref_type = 2;
pub type hf_ref_type = ::std::os::raw::c_uint;
#[doc = " information describing a header field"]
pub type header_field_info = _header_field_info;
#[doc = " information describing a header field"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _header_field_info {
    #[doc = "< [FIELDNAME] full name of this field"]
    pub name: *const ::std::os::raw::c_char,
    #[doc = "< [FIELDFILTERNAME] filter name of this field"]
    pub abbrev: *const ::std::os::raw::c_char,
    #[doc = "< [FIELDTYPE] field type, one of FT_ (from ftypes.h)"]
    pub type_: ftenum,
    #[doc = "< [FIELDDISPLAY] one of BASE_, or field bit-width if FT_BOOLEAN and non-zero bitmask"]
    pub display: ::std::os::raw::c_int,
    #[doc = "< [FIELDCONVERT] value_string, val64_string, range_string or true_false_string,\ntypically converted by VALS(), RVALS() or TFS().\nIf this is an FT_PROTOCOL or BASE_PROTOCOL_INFO then it points to the\nassociated protocol_t structure"]
    pub strings: *const ::std::os::raw::c_void,
    #[doc = "< [BITMASK] bitmask of interesting bits"]
    pub bitmask: guint64,
    #[doc = "< [FIELDDESCR] Brief description of field"]
    pub blurb: *const ::std::os::raw::c_char,
    #[doc = "< Field ID"]
    pub id: ::std::os::raw::c_int,
    #[doc = "< parent protocol tree"]
    pub parent: ::std::os::raw::c_int,
    #[doc = "< is this field referenced by a filter"]
    pub ref_type: hf_ref_type,
    #[doc = "< ID of previous hfinfo with same abbrev"]
    pub same_name_prev_id: ::std::os::raw::c_int,
    #[doc = "< Link to next hfinfo with same abbrev"]
    pub same_name_next: *mut header_field_info,
}
#[test]
fn bindgen_test_layout__header_field_info() {
    const UNINIT: ::std::mem::MaybeUninit<_header_field_info> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_header_field_info>(),
        72usize,
        concat!("Size of: ", stringify!(_header_field_info))
    );
    assert_eq!(
        ::std::mem::align_of::<_header_field_info>(),
        8usize,
        concat!("Alignment of ", stringify!(_header_field_info))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_header_field_info),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).abbrev) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_header_field_info),
            "::",
            stringify!(abbrev)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_header_field_info),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).display) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_header_field_info),
            "::",
            stringify!(display)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).strings) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_header_field_info),
            "::",
            stringify!(strings)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bitmask) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_header_field_info),
            "::",
            stringify!(bitmask)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).blurb) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_header_field_info),
            "::",
            stringify!(blurb)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).id) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_header_field_info),
            "::",
            stringify!(id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(_header_field_info),
            "::",
            stringify!(parent)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ref_type) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_header_field_info),
            "::",
            stringify!(ref_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).same_name_prev_id) as usize - ptr as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(_header_field_info),
            "::",
            stringify!(same_name_prev_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).same_name_next) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_header_field_info),
            "::",
            stringify!(same_name_next)
        )
    );
}
#[doc = " Each proto_tree, proto_item is one of these."]
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Copy, Clone)]
pub struct _proto_node {
    pub _bindgen_opaque_blob: [u64; 6usize],
}
#[test]
fn bindgen_test_layout__proto_node() {
    assert_eq!(
        ::std::mem::size_of::<_proto_node>(),
        48usize,
        concat!("Size of: ", stringify!(_proto_node))
    );
    assert_eq!(
        ::std::mem::align_of::<_proto_node>(),
        8usize,
        concat!("Alignment of ", stringify!(_proto_node))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct proto_plugin {
    pub register_protoinfo: ::std::option::Option<unsafe extern "C" fn()>,
    pub register_handoff: ::std::option::Option<unsafe extern "C" fn()>,
}
#[test]
fn bindgen_test_layout_proto_plugin() {
    const UNINIT: ::std::mem::MaybeUninit<proto_plugin> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<proto_plugin>(),
        16usize,
        concat!("Size of: ", stringify!(proto_plugin))
    );
    assert_eq!(
        ::std::mem::align_of::<proto_plugin>(),
        8usize,
        concat!("Alignment of ", stringify!(proto_plugin))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).register_protoinfo) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(proto_plugin),
            "::",
            stringify!(register_protoinfo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).register_handoff) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(proto_plugin),
            "::",
            stringify!(register_handoff)
        )
    );
}
#[doc = "  Helper routines for column utility structures and routines."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct epan_column_info {
    _unused: [u8; 0],
}
#[doc = "< 0) Absolute date, as YYYY-MM-DD, and time"]
pub const COL_ABS_YMD_TIME: _bindgen_ty_21 = 0;
#[doc = "< 1) Absolute date, as YYYY/DOY, and time"]
pub const COL_ABS_YDOY_TIME: _bindgen_ty_21 = 1;
#[doc = "< 2) Absolute time"]
pub const COL_ABS_TIME: _bindgen_ty_21 = 2;
#[doc = "< 3) Cumulative number of bytes"]
pub const COL_CUMULATIVE_BYTES: _bindgen_ty_21 = 3;
#[doc = "< 4) Custom column (any filter name's contents)"]
pub const COL_CUSTOM: _bindgen_ty_21 = 4;
#[doc = "< 5) Delta time"]
pub const COL_DELTA_TIME: _bindgen_ty_21 = 5;
#[doc = "< 6) Delta time displayed"]
pub const COL_DELTA_TIME_DIS: _bindgen_ty_21 = 6;
#[doc = "< 7) Resolved dest"]
pub const COL_RES_DST: _bindgen_ty_21 = 7;
#[doc = "< 8) Unresolved dest"]
pub const COL_UNRES_DST: _bindgen_ty_21 = 8;
#[doc = "< 9) Resolved dest port"]
pub const COL_RES_DST_PORT: _bindgen_ty_21 = 9;
#[doc = "< 10) Unresolved dest port"]
pub const COL_UNRES_DST_PORT: _bindgen_ty_21 = 10;
#[doc = "< 11) Destination address"]
pub const COL_DEF_DST: _bindgen_ty_21 = 11;
#[doc = "< 12) Destination port"]
pub const COL_DEF_DST_PORT: _bindgen_ty_21 = 12;
#[doc = "< 13) Expert Info"]
pub const COL_EXPERT: _bindgen_ty_21 = 13;
#[doc = "< 14) FW-1 monitor interface/direction"]
pub const COL_IF_DIR: _bindgen_ty_21 = 14;
#[doc = "< 15) IEEE 802.11 (and WiMax?) - Channel"]
pub const COL_FREQ_CHAN: _bindgen_ty_21 = 15;
#[doc = "< 16) Data link layer dest address"]
pub const COL_DEF_DL_DST: _bindgen_ty_21 = 16;
#[doc = "< 17) Data link layer source address"]
pub const COL_DEF_DL_SRC: _bindgen_ty_21 = 17;
#[doc = "< 18) Resolved DL dest"]
pub const COL_RES_DL_DST: _bindgen_ty_21 = 18;
#[doc = "< 19) Unresolved DL dest"]
pub const COL_UNRES_DL_DST: _bindgen_ty_21 = 19;
#[doc = "< 20) Resolved DL source"]
pub const COL_RES_DL_SRC: _bindgen_ty_21 = 20;
#[doc = "< 21) Unresolved DL source"]
pub const COL_UNRES_DL_SRC: _bindgen_ty_21 = 21;
#[doc = "< 22) IEEE 802.11 - received signal strength"]
pub const COL_RSSI: _bindgen_ty_21 = 22;
#[doc = "< 23) IEEE 802.11 - TX rate in Mbps"]
pub const COL_TX_RATE: _bindgen_ty_21 = 23;
#[doc = "< 24) IP DSCP Value"]
pub const COL_DSCP_VALUE: _bindgen_ty_21 = 24;
#[doc = "< 25) Description"]
pub const COL_INFO: _bindgen_ty_21 = 25;
#[doc = "< 26) Resolved net dest"]
pub const COL_RES_NET_DST: _bindgen_ty_21 = 26;
#[doc = "< 27) Unresolved net dest"]
pub const COL_UNRES_NET_DST: _bindgen_ty_21 = 27;
#[doc = "< 28) Resolved net source"]
pub const COL_RES_NET_SRC: _bindgen_ty_21 = 28;
#[doc = "< 29) Unresolved net source"]
pub const COL_UNRES_NET_SRC: _bindgen_ty_21 = 29;
#[doc = "< 30) Network layer dest address"]
pub const COL_DEF_NET_DST: _bindgen_ty_21 = 30;
#[doc = "< 31) Network layer source address"]
pub const COL_DEF_NET_SRC: _bindgen_ty_21 = 31;
#[doc = "< 32) Packet list item number"]
pub const COL_NUMBER: _bindgen_ty_21 = 32;
#[doc = "< 33) Packet length in bytes"]
pub const COL_PACKET_LENGTH: _bindgen_ty_21 = 33;
#[doc = "< 34) Protocol"]
pub const COL_PROTOCOL: _bindgen_ty_21 = 34;
#[doc = "< 35) Relative time"]
pub const COL_REL_TIME: _bindgen_ty_21 = 35;
#[doc = "< 36) Source address"]
pub const COL_DEF_SRC: _bindgen_ty_21 = 36;
#[doc = "< 37) Source port"]
pub const COL_DEF_SRC_PORT: _bindgen_ty_21 = 37;
#[doc = "< 38) Resolved source"]
pub const COL_RES_SRC: _bindgen_ty_21 = 38;
#[doc = "< 39) Unresolved source"]
pub const COL_UNRES_SRC: _bindgen_ty_21 = 39;
#[doc = "< 40) Resolved source port"]
pub const COL_RES_SRC_PORT: _bindgen_ty_21 = 40;
#[doc = "< 41) Unresolved source port"]
pub const COL_UNRES_SRC_PORT: _bindgen_ty_21 = 41;
#[doc = "< 42) UTC date, as YYYY-MM-DD, and time"]
pub const COL_UTC_YMD_TIME: _bindgen_ty_21 = 42;
#[doc = "< 43) UTC date, as YYYY/DOY, and time"]
pub const COL_UTC_YDOY_TIME: _bindgen_ty_21 = 43;
#[doc = "< 44) UTC time"]
pub const COL_UTC_TIME: _bindgen_ty_21 = 44;
#[doc = "< 45) Command line-specified time (default relative)"]
pub const COL_CLS_TIME: _bindgen_ty_21 = 45;
#[doc = "< 46) Should always be last"]
pub const NUM_COL_FMTS: _bindgen_ty_21 = 46;
#[doc = " All of the possible columns in summary listing.\n\n NOTE1: The entries MUST remain in this order, or else you need to reorder\n        the slist[] and dlist[] arrays in column.c to match!\n\n NOTE2: Please add the COL_XYZ entry in the appropriate spot, such that the\n        dlist[] array remains in alphabetical order!"]
pub type _bindgen_ty_21 = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dissector_handle {
    _unused: [u8; 0],
}
pub type dissector_handle_t = *mut dissector_handle;
pub const conversation_type_CONVERSATION_NONE: conversation_type = 0;
pub const conversation_type_CONVERSATION_SCTP: conversation_type = 1;
pub const conversation_type_CONVERSATION_TCP: conversation_type = 2;
pub const conversation_type_CONVERSATION_UDP: conversation_type = 3;
pub const conversation_type_CONVERSATION_DCCP: conversation_type = 4;
pub const conversation_type_CONVERSATION_IPX: conversation_type = 5;
pub const conversation_type_CONVERSATION_NCP: conversation_type = 6;
pub const conversation_type_CONVERSATION_EXCHG: conversation_type = 7;
pub const conversation_type_CONVERSATION_DDP: conversation_type = 8;
pub const conversation_type_CONVERSATION_SBCCS: conversation_type = 9;
pub const conversation_type_CONVERSATION_IDP: conversation_type = 10;
pub const conversation_type_CONVERSATION_TIPC: conversation_type = 11;
pub const conversation_type_CONVERSATION_USB: conversation_type = 12;
pub const conversation_type_CONVERSATION_I2C: conversation_type = 13;
pub const conversation_type_CONVERSATION_IBQP: conversation_type = 14;
pub const conversation_type_CONVERSATION_BLUETOOTH: conversation_type = 15;
pub const conversation_type_CONVERSATION_TDMOP: conversation_type = 16;
pub const conversation_type_CONVERSATION_DVBCI: conversation_type = 17;
pub const conversation_type_CONVERSATION_ISO14443: conversation_type = 18;
pub const conversation_type_CONVERSATION_ISDN: conversation_type = 19;
pub const conversation_type_CONVERSATION_H223: conversation_type = 20;
pub const conversation_type_CONVERSATION_X25: conversation_type = 21;
pub const conversation_type_CONVERSATION_IAX2: conversation_type = 22;
pub const conversation_type_CONVERSATION_DLCI: conversation_type = 23;
pub const conversation_type_CONVERSATION_ISUP: conversation_type = 24;
pub const conversation_type_CONVERSATION_BICC: conversation_type = 25;
pub const conversation_type_CONVERSATION_GSMTAP: conversation_type = 26;
pub const conversation_type_CONVERSATION_IUUP: conversation_type = 27;
pub const conversation_type_CONVERSATION_DVBBBF: conversation_type = 28;
pub const conversation_type_CONVERSATION_IWARP_MPA: conversation_type = 29;
pub const conversation_type_CONVERSATION_BT_UTP: conversation_type = 30;
pub const conversation_type_CONVERSATION_LOG: conversation_type = 31;
pub const conversation_type_CONVERSATION_LTP: conversation_type = 32;
pub const conversation_type_CONVERSATION_MCTP: conversation_type = 33;
pub const conversation_type_CONVERSATION_NVME_MI: conversation_type = 34;
pub const conversation_type_CONVERSATION_BP: conversation_type = 35;
pub const conversation_type_CONVERSATION_SNMP: conversation_type = 36;
pub const conversation_type_CONVERSATION_QUIC: conversation_type = 37;
pub const conversation_type_CONVERSATION_IDN: conversation_type = 38;
pub type conversation_type = ::std::os::raw::c_uint;
#[doc = " Elements used to identify conversations for *_full routines and\n pinfo->conv_elements.\n Arrays must be terminated with an element .type set to CE_CONVERSATION_TYPE.\n\n This is currently set only by conversation_set_elements_by_id(); it\n is not set for conversations identified by address/port endpoints.\n\n In find_conversation_pinfo() and find_or_create_conversation(), if\n any dissector has set this, then, unless some dissector has set the\n pair of address/port endpoints (see below), the array of elements\n is used to look up or create the conversation.  Otherwise, the\n current addresses and ports in the packet_info structure are used.\n\n XXX - is there any reason why we shouldn't use an array of conversation\n elements, with the appropriate addresses and ports, and set it for\n all protocols that use conversations specified by a pair of address/port\n endpoints?  That might simplify find_conversation_pinfo() by having\n them always use the array of elements if it's present, and just fail if\n it's not."]
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Copy, Clone)]
pub struct conversation_element {
    pub _bindgen_opaque_blob: [u64; 4usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union conversation_element__bindgen_ty_1 {
    pub conversation_type_val: conversation_type,
    pub addr_val: address,
    pub port_val: ::std::os::raw::c_uint,
    pub str_val: *const ::std::os::raw::c_char,
    pub uint_val: ::std::os::raw::c_uint,
    pub uint64_val: u64,
    pub int_val: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_conversation_element__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<conversation_element__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<conversation_element__bindgen_ty_1>(),
        24usize,
        concat!("Size of: ", stringify!(conversation_element__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<conversation_element__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(conversation_element__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).conversation_type_val) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(conversation_element__bindgen_ty_1),
            "::",
            stringify!(conversation_type_val)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).addr_val) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(conversation_element__bindgen_ty_1),
            "::",
            stringify!(addr_val)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).port_val) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(conversation_element__bindgen_ty_1),
            "::",
            stringify!(port_val)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).str_val) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(conversation_element__bindgen_ty_1),
            "::",
            stringify!(str_val)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).uint_val) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(conversation_element__bindgen_ty_1),
            "::",
            stringify!(uint_val)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).uint64_val) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(conversation_element__bindgen_ty_1),
            "::",
            stringify!(uint64_val)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).int_val) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(conversation_element__bindgen_ty_1),
            "::",
            stringify!(int_val)
        )
    );
}
#[test]
fn bindgen_test_layout_conversation_element() {
    assert_eq!(
        ::std::mem::size_of::<conversation_element>(),
        32usize,
        concat!("Size of: ", stringify!(conversation_element))
    );
    assert_eq!(
        ::std::mem::align_of::<conversation_element>(),
        8usize,
        concat!("Alignment of ", stringify!(conversation_element))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct conversation_addr_port_endpoints {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union wtap_pseudo_header {
    pub _address: u8,
}
