target = "https://tools.ietf.org/id/draft-ietf-quic-tls-32.txt#5.4.2"

# 5.4.2.  Header Protection Sample
#
# The header protection algorithm uses both the header protection key
# and a sample of the ciphertext from the packet Payload field.
# 
# The same number of bytes are always sampled, but an allowance needs
# to be made for the endpoint removing protection, which will not know
# the length of the Packet Number field.  In sampling the packet
# ciphertext, the Packet Number field is assumed to be 4 bytes long
# (its maximum possible encoded length).
# 
# An endpoint MUST discard packets that are not long enough to contain
# a complete sample.
# 
# To ensure that sufficient data is available for sampling, packets are
# padded so that the combined lengths of the encoded packet number and
# protected payload is at least 4 bytes longer than the sample required
# for header protection.  The cipher suites defined in [TLS13] - other
# than TLS_AES_128_CCM_8_SHA256, for which a header protection scheme
# is not defined in this document - have 16-byte expansions and 16-byte
# header protection samples.  This results in needing at least 3 bytes
# of frames in the unprotected payload if the packet number is encoded
# on a single byte, or 2 bytes of frames for a 2-byte packet number
# encoding.
# 
# The sampled ciphertext for a packet with a short header can be
# determined by the following pseudocode:
# 
# sample_offset = 1 + len(connection_id) + 4
# 
# sample = packet[sample_offset..sample_offset+sample_length]
# 
# For example, for a packet with a short header, an 8-byte connection
# ID, and protected with AEAD_AES_128_GCM, the sample takes bytes 13 to
# 28 inclusive (using zero-based indexing).
# 
# A packet with a long header is sampled in the same way, noting that
# multiple QUIC packets might be included in the same UDP datagram and
# that each one is handled separately.
# 
# sample_offset = 7 + len(destination_connection_id) +
#                     len(source_connection_id) +
#                     len(payload_length) + 4
# if packet_type == Initial:
#     sample_offset += len(token_length) +
#                      len(token)
# 
# sample = packet[sample_offset..sample_offset+sample_length]

[[spec]]
level = "MUST"
quote = '''
An endpoint MUST discard packets that are not long enough to contain
a complete sample.
'''

