SPECIFICATION: https://tools.ietf.org/id/draft-banks-quic-performance-00
  SECTION: [Protocol Negotiation](#section-2.1)
    TEXT[implementation]:    The ALPN used by the QUIC performance protocol is "perf".

  SECTION: [Encoding Server Response Size](#section-2.3.1)
    TEXT[implementation]:    Every stream opened by the client uses the first 8 bytes of the
    TEXT[implementation]:    stream data to encode a 64-bit unsigned integer in network byte order
    TEXT[implementation]:    to indicate the length of data the client wishes the server to
    TEXT[implementation]:    respond with.
    TEXT[implementation]:    On the server side, any stream that is closed before all 8 bytes are
    TEXT[implementation]:    received should just be ignored, and gracefully closed on its end (if
    TEXT[implementation]:    applicable).

  SECTION: [Bidirectional vs Unidirectional Streams](#section-2.3.2)
    TEXT[implementation]:    When a client uses a bidirectional stream to request a response
    TEXT[implementation]:    payload from the server, the server sends the requested data on the
    TEXT[implementation]:    same stream.  If no data is requested by the client, the server
    TEXT[implementation]:    merely closes its side of the stream.
    TEXT[implementation]:    When a client uses a unidirectional stream to request a response
    TEXT[implementation]:    payload from the server, the server opens a new unidirectional stream
    TEXT[implementation]:    to send the requested data.  If no data is requested by the client,
    TEXT[implementation]:    the server need take no action.

  SECTION: [What Data Should be Sent?](#section-4.1)
    TEXT[implementation]:    Since the goal here is to measure the efficiency of the QUIC
    TEXT[implementation]:    implementation and not any application protocol, the performance
    TEXT[implementation]:    application layer should be as light-weight as possible.  To this
    TEXT[implementation]:    end, the client and server application layer may use a single
    TEXT[implementation]:    preallocated and initialized buffer that it queues to send when any
    TEXT[implementation]:    payload needs to be sent out.

SPECIFICATION: https://tools.ietf.org/id/draft-cardwell-iccrg-bbr-congestion-control-02
  SECTION: [Transport Connection State](#section-2.1)
    TEXT[implementation]: True if the connection has fully utilized its cwnd
    TEXT[implementation]:    at any point in the last packet-timed round trip.

  SECTION: [Pacing State and Parameters](#section-2.5)
    TEXT[implementation]: The static discount factor of 1% used to
    TEXT[implementation]:    scale BBR.bw to produce BBR.pacing_rate.

  SECTION: [cwnd State and Parameters](#section-2.6)
    TEXT[implementation,test]: A constant specifying the minimum gain value
    TEXT[implementation,test]:    for calculating the pacing rate that will allow the sending rate to
    TEXT[implementation,test]:    double each round (4*ln(2) ~= 2.77)
    TEXT[implementation,test]: A constant specifying the minimum gain value for
    TEXT[implementation,test]:    calculating the cwnd that will allow the sending rate to double each
    TEXT[implementation,test]:    round (2.0)

  SECTION: [Core Algorithm Design Parameters](#section-2.8)
    TEXT[implementation]: The maximum tolerated per-round-trip packet loss rate
    TEXT[implementation]:    when probing for bandwidth (the default is 2%).
    TEXT[implementation]: The default multiplicative decrease to make upon each round
    TEXT[implementation]:    trip during which the connection detects packet loss (the value is
    TEXT[implementation]:    0.7)
    TEXT[implementation]: The multiplicative factor to apply to BBR.inflight_hi
    TEXT[implementation]:    when attempting to leave free headroom in the path (e.g. free space
    TEXT[implementation]:    in the bottleneck buffer or free time slots in the bottleneck link)
    TEXT[implementation]:    that can be used by cross traffic (the value is 0.85).
    TEXT[implementation]: The minimal cwnd value BBR targets, to allow
    TEXT[implementation]:    pipelining with TCP endpoints that follow an "ACK every other packet"
    TEXT[implementation]:    delayed-ACK policy: 4 * SMSS.

  SECTION: [Data Rate Network Path Model Parameters](#section-2.9.1)
    TEXT[implementation]:    The data rate model parameters together estimate both the sending
    TEXT[implementation]:    rate required to reach the full bandwidth available to the flow
    TEXT[implementation]:    (BBR.max_bw), and the maximum pacing rate control parameter that is
    TEXT[implementation]:    consistent with the queue pressure objective (BBR.bw).
    TEXT[implementation]: The windowed maximum recent bandwidth sample - obtained
    TEXT[implementation]:    using the BBR delivery rate sampling algorithm [draft-cheng-iccrg-
    TEXT[implementation]:    delivery-rate-estimation] - measured during the current or previous
    TEXT[implementation]:    bandwidth probing cycle (or during Startup, if the flow is still in
    TEXT[implementation]:    that state).
    TEXT[implementation]: The long-term maximum sending bandwidth that the algorithm
    TEXT[implementation]:    estimates will produce acceptable queue pressure, based on signals in
    TEXT[implementation]:    the current or previous bandwidth probing cycle, as measured by loss.
    TEXT[implementation]: The short-term maximum sending bandwidth that the
    TEXT[implementation]:    algorithm estimates is safe for matching the current network path
    TEXT[implementation]:    delivery rate, based on any loss signals in the current bandwidth
    TEXT[implementation]:    probing cycle.  This is generally lower than max_bw or bw_hi (thus
    TEXT[implementation]:    the name).
    TEXT[implementation]: The maximum sending bandwidth that the algorithm estimates is
    TEXT[implementation]:    appropriate for matching the current network path delivery rate,
    TEXT[implementation]:    given all available signals in the model, at any time scale.  It is
    TEXT[implementation]:    the min() of max_bw, bw_hi, and bw_lo.

  SECTION: [Data Volume Network Path Model Parameters](#section-2.9.2)
    TEXT[implementation]:    The data volume model parameters together estimate both the volume of
    TEXT[implementation]:    in-flight data required to reach the full bandwidth available to the
    TEXT[implementation]:    flow (BBR.max_inflight), and the maximum volume of data that is
    TEXT[implementation]:    consistent with the queue pressure objective (cwnd).
    TEXT[implementation]: The windowed minimum round-trip time sample measured
    TEXT[implementation]:    over the last MinRTTFilterLen = 10 seconds.
    TEXT[implementation]: A volume of data that is the estimate of the recent
    TEXT[implementation]:    degree of aggregation in the network path.
    TEXT[implementation]: Analogous to BBR.bw_hi, the long-term maximum volume
    TEXT[implementation]:    of in-flight data that the algorithm estimates will produce
    TEXT[implementation]:    acceptable queue pressure, based on signals in the current or
    TEXT[implementation]:    previous bandwidth probing cycle, as measured by loss.
    TEXT[implementation]: Analogous to BBR.bw_lo, the short-term maximum
    TEXT[implementation]:    volume of in-flight data that the algorithm estimates is safe for
    TEXT[implementation]:    matching the current network path delivery process, based on any loss
    TEXT[implementation]:    signals in the current bandwidth probing cycle.

  SECTION: [State for Responding to Congestion](#section-2.10)
    TEXT[implementation]: a 1-round-trip max of delivered bandwidth
    TEXT[implementation]:    (rs.delivery_rate)
    TEXT[implementation]: a 1-round-trip max of delivered volume of data
    TEXT[implementation]:    (rs.delivered)

  SECTION: [Estimating BBR.max_bw](#section-2.11)
    TEXT[implementation]: The filter window length for BBR.MaxBwFilter = 2
    TEXT[implementation]:    (representing up to 2 ProbeBW cycles, the current cycle and the
    TEXT[implementation]:    previous full cycle)
    TEXT[implementation]: The virtual time used by the BBR.max_bw filter
    TEXT[implementation]:    window.

  SECTION: [Estimating BBR.extra_acked](#section-2.12)
    TEXT[implementation]: the start of the time interval for
    TEXT[implementation]:    estimating the excess amount of data acknowledged due to aggregation
    TEXT[implementation]:    effects.
    TEXT[implementation]: the volume of data marked as delivered
    TEXT[implementation]:    since BBR.extra_acked_interval_start.
    TEXT[implementation]: The window length of the
    TEXT[implementation]:    BBR.ExtraACKedFilter max filter window: 10 (in units of packet-timed
    TEXT[implementation]:    round trips).

  SECTION: [Startup Parameters and State](#section-2.13)
    TEXT[implementation]: A boolean that records whether BBR estimates that it
    TEXT[implementation]:    has ever fully utilized its available bandwidth ("filled the pipe").
    TEXT[implementation]: A recent baseline BBR.max_bw to estimate if BBR has
    TEXT[implementation]:    "filled the pipe" in Startup.
    TEXT[implementation]: The number of non-app-limited round trips without
    TEXT[implementation]:    large increases in BBR.full_bw.

  SECTION: [Parameters for Estimating BBR.min_rtt](#section-2.14.1)
    TEXT[implementation]: A constant specifying the length of the BBR.min_rtt
    TEXT[implementation]:    min filter window, MinRTTFilterLen is 10 secs.

  SECTION: [Parameters for Scheduling ProbeRTT](#section-2.14.2)
    TEXT[implementation,test]: A constant specifying the gain value for
    TEXT[implementation,test]:    calculating the cwnd during ProbeRTT: 0.5
    TEXT[implementation]: A constant specifying the minimum duration for
    TEXT[implementation]:    which ProbeRTT state holds inflight to BBRMinPipeCwnd or fewer
    TEXT[implementation]:    packets: 200 ms.
    TEXT[implementation]: A constant specifying the minimum time interval
    TEXT[implementation]:    between ProbeRTT states: 5 secs.
    TEXT[implementation]: A boolean recording whether the
    TEXT[implementation]:    BBR.probe_rtt_min_delay has expired and is due for a refresh with an
    TEXT[implementation]:    application idle period or a transition into ProbeRTT state.

  SECTION: [State Transition Diagram](#section-4.1.1)
    TEXT[implementation]:    The following state transition diagram summarizes the flow of control
    TEXT[implementation]:    and the relationship between the different states:
    TEXT[implementation]:        +---> Startup  ------------+
    TEXT[implementation]:        |        |                 |
    TEXT[implementation]:        |        V                 |
    TEXT[implementation]:        |     Drain  --------------+
    TEXT[implementation]:        |        |                 |
    TEXT[implementation]:        |        V                 |
    TEXT[implementation]:        +---> ProbeBW_DOWN  -------+
    TEXT[implementation]:        | ^      |                 |
    TEXT[implementation]:        | |      V                 |
    TEXT[implementation]:        | |   ProbeBW_CRUISE ------+
    TEXT[implementation]:        | |      |                 |
    TEXT[implementation]:        | |      V                 |
    TEXT[implementation]:        | |   ProbeBW_REFILL  -----+
    TEXT[implementation]:        | |      |                 |
    TEXT[implementation]:        | |      V                 |
    TEXT[implementation]:        | |   ProbeBW_UP  ---------+
    TEXT[implementation]:        | |      |                 |
    TEXT[implementation]:        | +------+                 |
    TEXT[implementation]:        |                          |
    TEXT[implementation]:        +---- ProbeRTT <-----------+

  SECTION: [Initialization](#section-4.2.1)
    TEXT[implementation,test]:      BBROnInit():
    TEXT[implementation,test]:        init_windowed_max_filter(filter=BBR.MaxBwFilter, value=0, time=0)
    TEXT[implementation,test]:        BBR.min_rtt = SRTT ? SRTT : Inf
    TEXT[implementation,test]:        BBR.min_rtt_stamp = Now()
    TEXT[implementation,test]:        BBR.probe_rtt_done_stamp = 0
    TEXT[implementation,test]:        BBR.probe_rtt_round_done = false
    TEXT[implementation,test]:        BBR.prior_cwnd = 0
    TEXT[implementation,test]:        BBR.idle_restart = false
    TEXT[implementation,test]:        BBR.extra_acked_interval_start = Now()
    TEXT[implementation,test]:        BBR.extra_acked_delivered = 0
    TEXT[implementation,test]:        BBRResetCongestionSignals()
    TEXT[implementation,test]:        BBRResetLowerBounds()
    TEXT[implementation,test]:        BBRInitRoundCounting()
    TEXT[implementation,test]:        BBRInitFullPipe()
    TEXT[implementation,test]:        BBRInitPacingRate()
    TEXT[implementation,test]:        BBREnterStartup()

  SECTION: [Per-Transmit Steps](#section-4.2.2)
    TEXT[implementation]:      BBROnTransmit():
    TEXT[implementation]:        BBRHandleRestartFromIdle()

  SECTION: [Per-ACK Steps](#section-4.2.3)
    TEXT[implementation]:    On every ACK, the BBR algorithm executes the following
    TEXT[implementation]:    BBRUpdateOnACK() steps in order to update its network path model,
    TEXT[implementation]:    update its state machine, and adjust its control parameters to adapt
    TEXT[implementation]:    to the updated model:
    TEXT[implementation]:      BBRUpdateOnACK():
    TEXT[implementation]:        BBRUpdateModelAndState()
    TEXT[implementation]:        BBRUpdateControlParameters()
    TEXT[implementation]:      BBRUpdateModelAndState():
    TEXT[implementation]:        BBRUpdateLatestDeliverySignals()
    TEXT[implementation]:        BBRUpdateCongestionSignals()
    TEXT[implementation]:        BBRUpdateACKAggregation()
    TEXT[implementation]:        BBRCheckStartupDone()
    TEXT[implementation]:        BBRCheckDrain()
    TEXT[implementation]:        BBRUpdateProbeBWCyclePhase()
    TEXT[implementation]:        BBRUpdateMinRTT()
    TEXT[implementation]:        BBRCheckProbeRTT()
    TEXT[implementation]:        BBRAdvanceLatestDeliverySignals()
    TEXT[implementation]:        BBRBoundBWForModel()
    TEXT[implementation]:      BBRUpdateControlParameters():
    TEXT[implementation]:        BBRSetPacingRate()
    TEXT[implementation]:        BBRSetSendQuantum()
    TEXT[implementation]:        BBRSetCwnd()

  SECTION: [Per-Loss Steps](#section-4.2.4)
    TEXT[implementation]:      BBRUpdateOnLoss(packet):
    TEXT[implementation]:        BBRHandleLostPacket(packet)

  SECTION: [Startup Dynamics](#section-4.3.1.1)
    TEXT[implementation]:      BBREnterStartup():
    TEXT[implementation]:        BBR.state = Startup
    TEXT[implementation]:        BBR.pacing_gain = BBRStartupPacingGain
    TEXT[implementation]:        BBR.cwnd_gain = BBRStartupCwndGain
    TEXT[implementation,test]:      BBRCheckStartupDone():
    TEXT[implementation,test]:        BBRCheckStartupFullBandwidth()
    TEXT[implementation,test]:        BBRCheckStartupHighLoss()
    TEXT[implementation,test]:        if (BBR.state == Startup and BBR.filled_pipe)
    TEXT[implementation,test]:          BBREnterDrain()

  SECTION: [Exiting Startup Based on Bandwidth Plateau](#section-4.3.1.2)
    TEXT[implementation]:      BBRInitFullPipe():
    TEXT[implementation]:        BBR.filled_pipe = false
    TEXT[implementation]:        BBR.full_bw = 0
    TEXT[implementation]:        BBR.full_bw_count = 0
    TEXT[implementation]:    Once per round trip, upon an ACK that acknowledges new data, and when
    TEXT[implementation]:    the delivery rate sample is not application-limited (see [draft-
    TEXT[implementation]:    cheng-iccrg-delivery-rate-estimation]), BBR runs the "full pipe"
    TEXT[implementation]:    estimator
    TEXT[implementation]:      BBRCheckStartupFullBandwidth():
    TEXT[implementation]:        if BBR.filled_pipe or
    TEXT[implementation]:           !BBR.round_start or rs.is_app_limited
    TEXT[implementation]:          return  /* no need to check for a full pipe now */
    TEXT[implementation]:        if (BBR.max_bw >= BBR.full_bw * 1.25)  /* still growing? */
    TEXT[implementation]:          BBR.full_bw = BBR.max_bw    /* record new baseline level */
    TEXT[implementation]:          BBR.full_bw_count = 0
    TEXT[implementation]:          return
    TEXT[implementation]:        BBR.full_bw_count++ /* another round w/o much growth */
    TEXT[implementation]:        if (BBR.full_bw_count >= 3)
    TEXT[implementation]:          BBR.filled_pipe = true

  SECTION: [Exiting Startup Based on Packet Loss](#section-4.3.1.3)
    TEXT[implementation]:    A second method BBR uses for estimating the bottleneck is full is by
    TEXT[implementation]:    looking at sustained packet losses Specifically for a case where the
    TEXT[implementation]:    following criteria are all met:
    TEXT[implementation,exception]:    *  The connection has been in fast recovery for at least one full
    TEXT[implementation,exception]:       round trip.
    TEXT[implementation]:    *  The loss rate over the time scale of a single full round trip
    TEXT[implementation]:       exceeds BBRLossThresh (2%).
    TEXT[exception]:    *  There are at least BBRStartupFullLossCnt=3 discontiguous sequence
    TEXT[exception]:       ranges lost in that round trip.

  SECTION: [Drain](#section-4.3.2)
    TEXT[implementation,test]: In Drain, BBR aims
    TEXT[implementation,test]:    to quickly drain any queue created in Startup by switching to a
    TEXT[implementation,test]:    pacing_gain well below 1.0, until any estimated queue has been
    TEXT[implementation,test]:    drained.  It uses a pacing_gain that is the inverse of the value used
    TEXT[implementation,test]:    during Startup, chosen to try to drain the queue in one round
    TEXT[implementation,test]:      BBREnterDrain():
    TEXT[implementation,test]:        BBR.state = Drain
    TEXT[implementation,test]:        BBR.pacing_gain = 1/BBRStartupCwndGain  /* pace slowly */
    TEXT[implementation,test]:        BBR.cwnd_gain = BBRStartupCwndGain      /* maintain cwnd */
    TEXT[implementation,test]:      BBRCheckDrain():
    TEXT[implementation,test]:        if (BBR.state == Drain and packets_in_flight <= BBRInflight(1.0))
    TEXT[implementation,test]:          BBREnterProbeBW()  /* BBR estimates the queue was drained */

  SECTION: [ProbeBW](#section-4.3.3)
    TEXT[implementation]: a BBR
    TEXT[implementation]:    flow in ProbeBW mode cycles through the four Probe bw states - DOWN,
    TEXT[implementation]:    CRUISE, REFILL, and UP

  SECTION: [ProbeBW_DOWN](#section-4.3.3.1)
    TEXT[implementation,test]:    In the ProbeBW_DOWN phase of the cycle, a BBR flow pursues the
    TEXT[implementation,test]:    deceleration tactic, to try to send slower than the network is
    TEXT[implementation,test]:    delivering data, to reduce the amount of data in flight, with all of
    TEXT[implementation,test]:    the standard motivations for the deceleration tactic (discussed in
    TEXT[implementation,test]:    "State Machine Tactics", above).  It does this by switching to a
    TEXT[implementation,test]:    BBR.pacing_gain of 0.9, sending at 90% of BBR.bw.

  SECTION: [ProbeBW_CRUISE](#section-4.3.3.2)
    TEXT[implementation,test]:    In the ProbeBW_CRUISE phase of the cycle, a BBR flow pursues the
    TEXT[implementation,test]:    "cruising" tactic (discussed in "State Machine Tactics", above),
    TEXT[implementation,test]:    attempting to send at the same rate the network is delivering data.
    TEXT[implementation,test]:    It tries to match the sending rate to the flow's current available
    TEXT[implementation,test]:    bandwidth, to try to achieve high utilization of the available
    TEXT[implementation,test]:    bandwidth without increasing queue pressure.  It does this by
    TEXT[implementation,test]:    switching to a pacing_gain of 1.0, sending at 100% of BBR.bw.

  SECTION: [ProbeBW_REFILL](#section-4.3.3.3)
    TEXT[implementation,test]:    During ProbeBW_REFILL BBR uses a BBR.pacing_gain of 1.0, to send at a
    TEXT[implementation,test]:    rate that matches the current estimated available bandwidth

  SECTION: [ProbeBW_UP](#section-4.3.3.4)
    TEXT[implementation,test]:    After ProbeBW_REFILL refills the pipe, ProbeBW_UP probes for possible
    TEXT[implementation,test]:    increases in available bandwidth by using a BBR.pacing_gain of 1.25,
    TEXT[implementation,test]:    sending faster than the current estimated available bandwidth.
    TEXT[implementation]: BBR takes an approach where the additive increase
    TEXT[implementation]:       to BBR.inflight_hi exponentially doubles each round trip

  SECTION: [Design Considerations for Choosing Constant Parameters](#section-4.3.3.5.3)
    TEXT[implementation]:      BBRCheckTimeToProbeBW():
    TEXT[implementation]:        if (BBRHasElapsedInPhase(BBR.bw_probe_wait) ||
    TEXT[implementation]:            BBRIsRenoCoexistenceProbeTime())
    TEXT[implementation]:          BBRStartProbeBW_REFILL()
    TEXT[implementation]:          return true
    TEXT[implementation]:        return false
    TEXT[implementation]:      BBRPickProbeWait():
    TEXT[implementation]:        /* Decide random round-trip bound for wait: */
    TEXT[implementation]:        BBR.rounds_since_bw_probe =
    TEXT[implementation]:          random_int_between(0, 1); /* 0 or 1 */
    TEXT[implementation]:        /* Decide the random wall clock bound for wait: */
    TEXT[implementation]:        BBR.bw_probe_wait =
    TEXT[implementation]:          2sec + random_float_between(0.0, 1.0) /* 0..1 sec */
    TEXT[implementation]:      BBRIsRenoCoexistenceProbeTime():
    TEXT[implementation]:        reno_rounds = BBRTargetInflight()
    TEXT[implementation]:        rounds = min(reno_rounds, 63)
    TEXT[implementation]:        return BBR.rounds_since_bw_probe >= rounds
    TEXT[implementation]:      BBRTargetInflight()
    TEXT[implementation]:        return min(BBR.bdp, cwnd)

  SECTION: [ProbeBW Algorithm Details](#section-4.3.3.6)
    TEXT[implementation]:      BBREnterProbeBW():
    TEXT[implementation]:        BBRStartProbeBW_DOWN()
    TEXT[implementation]:      BBRStartProbeBW_DOWN():
    TEXT[implementation]:        BBRResetCongestionSignals()
    TEXT[implementation]:        BBR.probe_up_cnt = Infinity /* not growing inflight_hi */
    TEXT[implementation]:        BBRPickProbeWait()
    TEXT[implementation]:        BBR.cycle_stamp = Now()  /* start wall clock */
    TEXT[implementation]:        BBR.ack_phase  = ACKS_PROBE_STOPPING
    TEXT[implementation]:        BBRStartRound()
    TEXT[implementation]:        BBR.state = ProbeBW_DOWN
    TEXT[implementation]:      BBRStartProbeBW_CRUISE():
    TEXT[implementation]:        BBR.state = ProbeBW_CRUISE
    TEXT[implementation]:      BBRStartProbeBW_REFILL():
    TEXT[implementation]:        BBRResetLowerBounds()
    TEXT[implementation]:        BBR.bw_probe_up_rounds = 0
    TEXT[implementation]:        BBR.bw_probe_up_acks = 0
    TEXT[implementation]:        BBR.ack_phase = ACKS_REFILLING
    TEXT[implementation]:        BBRStartRound()
    TEXT[implementation]:        BBR.state = ProbeBW_REFILL
    TEXT[implementation]:      BBRStartProbeBW_UP():
    TEXT[implementation]:        BBR.ack_phase = ACKS_PROBE_STARTING
    TEXT[implementation]:        BBRStartRound()
    TEXT[implementation]:        BBR.cycle_stamp = Now() /* start wall clock */
    TEXT[implementation]:        BBR.state = ProbeBW_UP
    TEXT[implementation]:        BBRRaiseInflightHiSlope()
    TEXT[implementation]:      BBRUpdateProbeBWCyclePhase():
    TEXT[implementation]:        if (!BBR.filled_pipe)
    TEXT[implementation]:          return  /* only handling steady-state behavior here */
    TEXT[implementation]:        BBRAdaptUpperBounds()
    TEXT[implementation]:        if (!IsInAProbeBWState())
    TEXT[implementation]:          return /* only handling ProbeBW states here: */
    TEXT[implementation]:        switch (state)
    TEXT[implementation]:        ProbeBW_DOWN:
    TEXT[implementation]:          if (BBRCheckTimeToProbeBW())
    TEXT[implementation]:            return /* already decided state transition */
    TEXT[implementation]:          if (BBRCheckTimeToCruise())
    TEXT[implementation]:            BBRStartProbeBW_CRUISE()
    TEXT[implementation]:        ProbeBW_CRUISE:
    TEXT[implementation]:          if (BBRCheckTimeToProbeBW())
    TEXT[implementation]:            return /* already decided state transition */
    TEXT[implementation]:        ProbeBW_REFILL:
    TEXT[implementation]:          /* After one round of REFILL, start UP */
    TEXT[implementation]:          if (BBR.round_start)
    TEXT[implementation]:            BBR.bw_probe_samples = 1
    TEXT[implementation]:            BBRStartProbeBW_UP()
    TEXT[implementation]:        ProbeBW_UP:
    TEXT[implementation]:          if (BBRHasElapsedInPhase(BBR.min_rtt) and
    TEXT[implementation]:              inflight > BBRInflight(BBR.max_bw, 1.25))
    TEXT[implementation]:            BBRStartProbeBW_DOWN()
    TEXT[implementation]:      IsInAProbeBWState()
    TEXT[implementation]:        state = BBR.state
    TEXT[implementation]:        return (state == ProbeBW_DOWN or
    TEXT[implementation]:                state == ProbeBW_CRUISE or
    TEXT[implementation]:                state == ProbeBW_REFILL or
    TEXT[implementation]:                state == ProbeBW_UP)
    TEXT[implementation]:      BBRCheckTimeToCruise():
    TEXT[implementation]:        if (inflight > BBRInflightWithHeadroom())
    TEXT[implementation]:          return false /* not enough headroom */
    TEXT[implementation]:        if (inflight <= BBRInflight(BBR.max_bw, 1.0))
    TEXT[implementation]:          return true  /* inflight <= estimated BDP */
    TEXT[implementation]:      BBRHasElapsedInPhase(interval):
    TEXT[implementation]:        return Now() > BBR.cycle_stamp + interval
    TEXT[implementation,test]:      BBRInflightWithHeadroom():
    TEXT[implementation,test]:        if (BBR.inflight_hi == Infinity)
    TEXT[implementation,test]:          return Infinity
    TEXT[implementation,test]:        headroom = max(1, BBRHeadroom * BBR.inflight_hi)
    TEXT[implementation,test]:          return max(BBR.inflight_hi - headroom,
    TEXT[implementation,test]:                     BBRMinPipeCwnd)
    TEXT[implementation]:      BBRRaiseInflightHiSlope():
    TEXT[implementation]:        growth_this_round = 1MSS << BBR.bw_probe_up_rounds
    TEXT[implementation]:        BBR.bw_probe_up_rounds = min(BBR.bw_probe_up_rounds + 1, 30)
    TEXT[implementation]:        BBR.probe_up_cnt = max(cwnd / growth_this_round, 1)
    TEXT[implementation]:      BBRProbeInflightHiUpward():
    TEXT[implementation]:        if (!is_cwnd_limited or cwnd < BBR.inflight_hi)
    TEXT[implementation]:          return  /* not fully using inflight_hi, so don't grow it */
    TEXT[implementation]:       BBR.bw_probe_up_acks += rs.newly_acked
    TEXT[implementation]:       if (BBR.bw_probe_up_acks >= BBR.probe_up_cnt)
    TEXT[implementation]:         delta = BBR.bw_probe_up_acks / BBR.probe_up_cnt
    TEXT[implementation]:         BBR.bw_probe_up_acks -= delta * BBR.bw_probe_up_cnt
    TEXT[implementation]:         BBR.inflight_hi += delta
    TEXT[implementation]:       if (BBR.round_start)
    TEXT[implementation]:         BBRRaiseInflightHiSlope()
    TEXT[implementation]:      BBRAdaptUpperBounds():
    TEXT[implementation]:        if (BBR.ack_phase == ACKS_PROBE_STARTING and BBR.round_start)
    TEXT[implementation]:          /* starting to get bw probing samples */
    TEXT[implementation]:          BBR.ack_phase = ACKS_PROBE_FEEDBACK
    TEXT[implementation]:        if (BBR.ack_phase == ACKS_PROBE_STOPPING and BBR.round_start)
    TEXT[implementation]:          /* end of samples from bw probing phase */
    TEXT[implementation]:          if (IsInAProbeBWState() and !rs.is_app_limited)
    TEXT[implementation]:            BBRAdvanceMaxBwFilter()
    TEXT[implementation]:        if (!CheckInflightTooHigh())
    TEXT[implementation]:          /* Loss rate is safe. Adjust upper bounds upward. */
    TEXT[implementation]:          if (BBR.inflight_hi == Infinity or BBR.bw_hi == Infinity)
    TEXT[implementation]:            return /* no upper bounds to raise */
    TEXT[implementation]:          if (rs.tx_in_flight > BBR.inflight_hi)
    TEXT[implementation]:            BBR.inflight_hi = rs.tx_in_flight

  SECTION: [ProbeRTT Logic](#section-4.3.4.4)
    TEXT[implementation]:      BBRUpdateMinRTT()
    TEXT[implementation]:        BBR.probe_rtt_expired =
    TEXT[implementation]:          Now() > BBR.probe_rtt_min_stamp + ProbeRTTInterval
    TEXT[implementation]:        if (rs.rtt >= 0 and
    TEXT[implementation]:            (rs.rtt < BBR.probe_rtt_min_delay or
    TEXT[implementation]:             BBR.probe_rtt_expired))
    TEXT[implementation]:           BBR.probe_rtt_min_delay = rs.rtt
    TEXT[implementation]:           BBR.probe_rtt_min_stamp = Now()
    TEXT[implementation]:        min_rtt_expired =
    TEXT[implementation]:          Now() > BBR.min_rtt_stamp + MinRTTFilterLen
    TEXT[implementation]:        if (BBR.probe_rtt_min_delay < BBR.min_rtt or
    TEXT[implementation]:            min_rtt_expired)
    TEXT[implementation]:          BBR.min_rtt       = BBR.probe_rtt_min_delay
    TEXT[implementation]:          BBR.min_rtt_stamp = BBR.probe_rtt_min_stamp
    TEXT[implementation]:      BBRCheckProbeRTT():
    TEXT[implementation]:        if (BBR.state != ProbeRTT and
    TEXT[implementation]:            BBR.probe_rtt_expired and
    TEXT[implementation]:            not BBR.idle_restart)
    TEXT[implementation]:          BBREnterProbeRTT()
    TEXT[implementation]:          BBRSaveCwnd()
    TEXT[implementation]:          BBR.probe_rtt_done_stamp = 0
    TEXT[implementation]:          BBR.ack_phase = ACKS_PROBE_STOPPING
    TEXT[implementation]:          BBRStartRound()
    TEXT[implementation]:        if (BBR.state == ProbeRTT)
    TEXT[implementation]:          BBRHandleProbeRTT()
    TEXT[implementation]:        if (rs.delivered > 0)
    TEXT[implementation]:          BBR.idle_restart = false
    TEXT[implementation,test]:      BBREnterProbeRTT():
    TEXT[implementation,test]:        BBR.state = ProbeRTT
    TEXT[implementation,test]:        BBR.pacing_gain = 1
    TEXT[implementation]:      BBRHandleProbeRTT():
    TEXT[implementation]:        /* Ignore low rate samples during ProbeRTT: */
    TEXT[implementation]:        MarkConnectionAppLimited()
    TEXT[implementation]:        if (BBR.probe_rtt_done_stamp == 0 and
    TEXT[implementation]:            packets_in_flight <= BBRProbeRTTCwnd())
    TEXT[implementation]:          /* Wait for at least ProbeRTTDuration to elapse: */
    TEXT[implementation]:          BBR.probe_rtt_done_stamp =
    TEXT[implementation]:            Now() + ProbeRTTDuration
    TEXT[implementation]:          /* Wait for at least one round to elapse: */
    TEXT[implementation]:          BBR.probe_rtt_round_done = false
    TEXT[implementation]:          BBRStartRound()
    TEXT[implementation]:        else if (BBR.probe_rtt_done_stamp != 0)
    TEXT[implementation]:          if (BBR.round_start)
    TEXT[implementation]:            BBR.probe_rtt_round_done = true
    TEXT[implementation]:          if (BBR.probe_rtt_round_done)
    TEXT[implementation]:            BBRCheckProbeRTTDone()
    TEXT[implementation]:      BBRCheckProbeRTTDone():
    TEXT[implementation]:        if (BBR.probe_rtt_done_stamp != 0 and
    TEXT[implementation]:            Now() > BBR.probe_rtt_done_stamp)
    TEXT[implementation]:          /* schedule next ProbeRTT: */
    TEXT[implementation]:          BBR.probe_rtt_min_stamp = Now()
    TEXT[implementation]:          BBRRestoreCwnd()
    TEXT[implementation]:          BBRExitProbeRTT()
    TEXT[implementation]:      MarkConnectionAppLimited():
    TEXT[implementation]:        C.app_limited =
    TEXT[implementation]:          (C.delivered + packets_in_flight) ? : 1

  SECTION: [Exiting ProbeRTT](#section-4.3.4.5)
    TEXT[implementation]: as an optimization, since the connection is
    TEXT[implementation]:    exiting ProbeRTT, we know that infligh is already below the estimated
    TEXT[implementation]:    BDP, so the connection can proceed immediately to ProbeBW_CRUISE
    TEXT[implementation]:      BBRExitProbeRTT():
    TEXT[implementation]:        BBRResetLowerBounds()
    TEXT[implementation]:        if (BBR.filled_pipe)
    TEXT[implementation]:          BBRStartProbeBW_DOWN()
    TEXT[implementation]:          BBRStartProbeBW_CRUISE()
    TEXT[implementation]:        else
    TEXT[implementation]:          BBREnterStartup()

  SECTION: [Checking for ProberRTT Completion](#section-4.4.2)
    TEXT[todo]:    As an optimization, when restarting from idle BBR checks to see if
    TEXT[todo]:    the connection is in ProbeRTT and has met the exit conditions for
    TEXT[todo]:    ProbeRTT.  If a connection goes idle during ProbeRTT then often it
    TEXT[todo]:    will have met those exit conditions by the time it restarts, so that
    TEXT[todo]:    the connection can restore the cwnd to its full value before it
    TEXT[todo]:    starts transmitting a new flight of data.

  SECTION: [Logic](#section-4.4.3)
    TEXT[implementation,test]:      BBRHandleRestartFromIdle():
    TEXT[implementation,test]:        if (packets_in_flight == 0 and C.app_limited)
    TEXT[implementation,test]:          BBR.idle_restart = true
    TEXT[implementation,test]:             BBR.extra_acked_interval_start = Now()
    TEXT[implementation,test]:          if (IsInAProbeBWState())
    TEXT[implementation,test]:            BBRSetPacingRateWithGain(1)
    TEXT[todo]:          else if (BBR.state == ProbeRTT)
    TEXT[todo]:            BBRCheckProbeRTTDone()

  SECTION: [BBR.round_count: Tracking Packet-Timed Round Trips](#section-4.5.1)
    TEXT[implementation]:    Several aspects of the BBR algorithm depend on counting the progress
    TEXT[implementation]:    of "packet-timed" round trips, which start at the transmission of
    TEXT[implementation]:    some segment, and then end at the acknowledgement of that segment.
    TEXT[implementation]:    BBR.round_count is a count of the number of these "packet-timed"
    TEXT[implementation]:    round trips elapsed so far.
    TEXT[implementation]:      BBRInitRoundCounting():
    TEXT[implementation]:        BBR.next_round_delivered = 0
    TEXT[implementation]:        BBR.round_start = false
    TEXT[implementation]:        BBR.round_count = 0
    TEXT[implementation]:      BBRUpdateRound():
    TEXT[implementation]:        if (packet.delivered >= BBR.next_round_delivered)
    TEXT[implementation]:          BBRStartRound()
    TEXT[implementation]:          BBR.round_count++
    TEXT[implementation]:          BBR.rounds_since_probe++
    TEXT[implementation]:          BBR.round_start = true
    TEXT[implementation]:        else
    TEXT[implementation]:          BBR.round_start = false
    TEXT[implementation]:      BBRStartRound():
    TEXT[implementation]:        BBR.next_round_delivered = C.delivered

  SECTION: [BBR.max_bw and Application-limited Delivery Rate Samples](#section-4.5.2.3)
    TEXT[implementation]: By default, the estimator discards
    TEXT[implementation]:    application-limited samples, since by definition they reflect
    TEXT[implementation]:    application limits.  However, the estimator does use application-
    TEXT[implementation]:    limited samples if the measured delivery rate happens to be larger
    TEXT[implementation]:    than the current BBR.max_bw estimate, since this indicates the
    TEXT[implementation]:    current BBR.Max_bw estimate is too low.

  SECTION: [Updating the BBR.max_bw Max Filter](#section-4.5.2.4)
    TEXT[implementation]:      BBRUpdateMaxBw()
    TEXT[implementation]:        BBRUpdateRound()
    TEXT[implementation]:        if (rs.delivery_rate >= BBR.max_bw || !rs.is_app_limited)
    TEXT[implementation]:            BBR.max_bw = update_windowed_max_filter(
    TEXT[implementation]:                          filter=BBR.MaxBwFilter,
    TEXT[implementation]:                          value=rs.delivery_rate,
    TEXT[implementation]:                          time=BBR.cycle_count,
    TEXT[implementation]:                          window_length=MaxBwFilterLen)

  SECTION: [Tracking Time for the BBR.max_bw Max Filter](#section-4.5.2.5)
    TEXT[implementation]:      BBRAdvanceMaxBwFilter():
    TEXT[implementation]:        BBR.cycle_count++

  SECTION: [BBR.min_rtt Min Filter](#section-4.5.3.2)
    TEXT[implementation]:    A BBR implementation MAY use a generic windowed min filter to track
    TEXT[implementation]:    BBR.min_rtt.  However, a significant savings in space and improvement
    TEXT[implementation]:    in freshness can be achieved by integrating the BBR.min_rtt
    TEXT[implementation]:    estimation into the ProbeRTT state machine

  SECTION: [BBR.offload_budget](#section-4.5.4)
    TEXT[implementation]:        BBRUpdateOffloadBudget():
    TEXT[implementation]:          BBR.offload_budget = 3 * BBR.send_quantum

  SECTION: [BBR.extra_acked](#section-4.5.5)
    TEXT[implementation]:      BBRUpdateACKAggregation():
    TEXT[implementation]:        /* Find excess ACKed beyond expected amount over this interval */
    TEXT[implementation]:        interval = (Now() - BBR.extra_acked_interval_start)
    TEXT[implementation]:        expected_delivered = BBR.bw * interval
    TEXT[implementation]:        /* Reset interval if ACK rate is below expected rate: */
    TEXT[implementation]:        if (BBR.extra_acked_delivered <= expected_delivered)
    TEXT[implementation]:            BBR.extra_acked_delivered = 0
    TEXT[implementation]:            BBR.extra_acked_interval_start = Now()
    TEXT[implementation]:            expected_delivered = 0
    TEXT[implementation]:        BBR.extra_acked_delivered += rs.newly_acked
    TEXT[implementation]:        extra = BBR.extra_acked_delivered - expected_delivered
    TEXT[implementation]:        extra = min(extra, cwnd)
    TEXT[implementation]:        BBR.extra_acked =
    TEXT[implementation]:          update_windowed_max_filter(
    TEXT[implementation]:            filter=BBR.ExtraACKedFilter,
    TEXT[implementation]:            value=extra,
    TEXT[implementation]:            time=BBR.round_count,
    TEXT[implementation]:            window_length=BBRExtraAckedFilterLen)

  SECTION: [Probing for Bandwidth In ProbeBW](#section-4.5.6.2)
    TEXT[implementation]:      IsInflightTooHigh():
    TEXT[implementation]:        return (rs.lost > rs.tx_in_flight * BBRLossThresh)
    TEXT[implementation]:      BBRHandleInflightTooHigh():
    TEXT[implementation]:        BBR.bw_probe_samples = 0;  /* only react once per bw probe */
    TEXT[implementation]:        if (!rs.is_app_limited)
    TEXT[implementation]:          BBR.inflight_hi = max(rs.tx_in_flight,
    TEXT[implementation]:                                BBRTargetInflight() * BBRBeta))
    TEXT[implementation]:        If (BBR.state == ProbeBW_UP)
    TEXT[implementation]:          BBRStartProbeBW_DOWN()
    TEXT[implementation,test]:        if (!BBR.bw_probe_samples)
    TEXT[implementation,test]:          return /* not a packet sent while probing bandwidth */
    TEXT[implementation,test]:        rs.tx_in_flight = packet.tx_in_flight /* inflight at transmit */
    TEXT[implementation,test]:        rs.lost = C.lost - packet.lost /* data lost since transmit */
    TEXT[implementation,test]:        rs.is_app_limited = packet.is_app_limited;
    TEXT[implementation,test]:        if (IsInflightTooHigh(rs))
    TEXT[implementation,test]:          rs.tx_in_flight = BBRInflightHiFromLostPacket(rs, packet)
    TEXT[implementation,test]:          BBRHandleInflightTooHigh(rs)
    TEXT[implementation,test]:      BBRInflightHiFromLostPacket(rs, packet):
    TEXT[implementation,test]:        size = packet.size
    TEXT[implementation,test]:        /* What was in flight before this packet? */
    TEXT[implementation,test]:        inflight_prev = rs.tx_in_flight - size
    TEXT[implementation,test]:        /* What was lost before this packet? */
    TEXT[implementation,test]:        lost_prev = rs.lost - size
    TEXT[implementation,test]:        lost_prefix = (BBRLossThresh * inflight_prev - lost_prev) /
    TEXT[implementation,test]:                      (1 - BBRLossThresh)
    TEXT[implementation,test]:        /* At what inflight value did losses cross BBRLossThresh? */
    TEXT[implementation,test]:        inflight = inflight_prev + lost_prefix
    TEXT[implementation,test]:        return inflight

  SECTION: [When not Probing for Bandwidth](#section-4.5.6.3)
    TEXT[implementation,test]:    When not explicitly accelerating to probe for bandwidth (Drain,
    TEXT[implementation,test]:    ProbeRTT, ProbeBW_DOWN, ProbeBW_CRUISE), BBR responds to loss by
    TEXT[implementation,test]:    slowing down to some extent.
    TEXT[implementation]:      BBRUpdateLatestDeliverySignals():
    TEXT[implementation]:        BBR.loss_round_start = 0
    TEXT[implementation]:        BBR.bw_latest       = max(BBR.bw_latest,       rs.delivery_rate)
    TEXT[implementation]:        BBR.inflight_latest = max(BBR.inflight_latest, rs.delivered)
    TEXT[implementation]:        if (rs.prior_delivered >= BBR.loss_round_delivered)
    TEXT[implementation]:          BBR.loss_round_delivered = C.delivered
    TEXT[implementation]:          BBR.loss_round_start = 1
    TEXT[implementation]:      BBRAdvanceLatestDeliverySignals():
    TEXT[implementation]:        if (BBR.loss_round_start)
    TEXT[implementation]:          BBR.bw_latest       = rs.delivery_rate
    TEXT[implementation]:          BBR.inflight_latest = rs.delivered
    TEXT[implementation]:      BBRResetCongestionSignals():
    TEXT[implementation]:        BBR.loss_in_round = 0
    TEXT[implementation]:        BBR.bw_latest = 0
    TEXT[implementation]:        BBR.inflight_latest = 0
    TEXT[implementation]:      BBRUpdateCongestionSignals():
    TEXT[implementation]:        BBRUpdateMaxBw()
    TEXT[implementation]:        if (rs.losses > 0)
    TEXT[implementation]:          BBR.loss_in_round = 1
    TEXT[implementation]:        if (!BBR.loss_round_start)
    TEXT[implementation]:          return  /* wait until end of round trip */
    TEXT[implementation]:        BBRAdaptLowerBoundsFromCongestion()
    TEXT[implementation]:        BBR.loss_in_round = 0
    TEXT[implementation]:      BBRAdaptLowerBoundsFromCongestion():
    TEXT[implementation]:        if (BBRIsProbingBW())
    TEXT[implementation]:          return
    TEXT[implementation]:        if (BBR.loss_in_round())
    TEXT[implementation]:          BBRInitLowerBounds()
    TEXT[implementation]:          BBRLossLowerBounds()
    TEXT[implementation]:      BBRInitLowerBounds():
    TEXT[implementation]:        if (BBR.bw_lo == Infinity)
    TEXT[implementation]:          BBR.bw_lo = BBR.max_bw
    TEXT[implementation]:        if (BBR.inflight_lo == Infinity)
    TEXT[implementation]:          BBR.inflight_lo = cwnd
    TEXT[implementation]:      BBRLossLowerBounds()
    TEXT[implementation]:        BBR.bw_lo       = max(BBR.bw_latest,
    TEXT[implementation]:                              BBRBeta * BBR.bw_lo)
    TEXT[implementation]:        BBR.inflight_lo = max(BBR.inflight_latest,
    TEXT[implementation]:                              BBRBeta * BBR.infligh_lo)
    TEXT[implementation]:      BBRResetLowerBounds():
    TEXT[implementation]:        BBR.bw_lo       = Infinity
    TEXT[implementation]:        BBR.inflight_lo = Infinity
    TEXT[implementation]:      BBRBoundBWForModel():
    TEXT[implementation]:        BBR.bw = min(BBR.max_bw, BBR.bw_lo, BBR.bw_hi)

  SECTION: [Pacing Rate: BBR.pacing_rate](#section-4.6.2)
    TEXT[implementation]:      BBR.next_departure_time = max(Now(), BBR.next_departure_time)
    TEXT[implementation]:      packet.departure_time = BBR.next_departure_time
    TEXT[implementation]:      pacing_delay = packet.size / BBR.pacing_rate
    TEXT[implementation]:      BBRInitPacingRate():
    TEXT[implementation]:        nominal_bandwidth = InitialCwnd / (SRTT ? SRTT : 1ms)
    TEXT[implementation]:        BBR.pacing_rate =  BBRStartupPacingGain * nominal_bandwidth
    TEXT[implementation,test]:      BBRSetPacingRateWithGain(pacing_gain):
    TEXT[implementation,test]:        rate = pacing_gain * bw * (100 - BBRPacingMarginPercent) / 100
    TEXT[implementation,test]:        if (BBR.filled_pipe || rate > BBR.pacing_rate)
    TEXT[implementation,test]:          BBR.pacing_rate = rate

  SECTION: [Send Quantum: BBR.send_quantum](#section-4.6.3)
    TEXT[implementation,test]:        if (BBR.pacing_rate < 1.2 Mbps)
    TEXT[implementation,test]:          floor = 1 * SMSS
    TEXT[implementation,test]:        else
    TEXT[implementation,test]:          floor = 2 * SMSS
    TEXT[implementation,test,exception]:        BBR.send_quantum = min(BBR.pacing_rate * 1ms, 64KBytes)
    TEXT[implementation,test]:        BBR.send_quantum = max(BBR.send_quantum, floor)

  SECTION: [Computing BBR.max_inflight](#section-4.6.4.2)
    TEXT[implementation,test]:      BBRBDPMultiple(gain):
    TEXT[implementation,test]:        if (BBR.min_rtt == Inf)
    TEXT[implementation,test]:          return InitialCwnd /* no valid RTT samples yet */
    TEXT[implementation,test]:        BBR.bdp = BBR.bw * BBR.min_rtt
    TEXT[implementation,test]:        return gain * BBR.bdp
    TEXT[implementation,test]:      BBRQuantizationBudget(inflight)
    TEXT[implementation,test]:        BBRUpdateOffloadBudget()
    TEXT[implementation,test]:        inflight = max(inflight, BBR.offload_budget)
    TEXT[implementation,test]:        inflight = max(inflight, BBRMinPipeCwnd)
    TEXT[implementation,test]:          if (BBR.state == ProbeBW && BBR.cycle_idx == ProbeBW_UP)
    TEXT[implementation,test]:          inflight += 2
    TEXT[implementation,test]:        return inflight
    TEXT[implementation,test]:      BBRInflight(gain):
    TEXT[implementation,test]:        inflight = BBRBDPMultiple(gain)
    TEXT[implementation,test]:        return BBRQuantizationBudget(inflight)
    TEXT[implementation,test]:      BBRUpdateMaxInflight():
    TEXT[implementation,test]:        BBRUpdateAggregationBudget()
    TEXT[implementation,test]:        inflight = BBRBDPMultiple(BBR.cwnd_gain)
    TEXT[implementation,test]:        inflight += BBR.extra_acked
    TEXT[implementation,test]:        BBR.max_inflight = BBRQuantizationBudget(inflight)

  SECTION: [Modulating cwnd in Loss Recovery](#section-4.6.4.4)
    TEXT[test]:    Upon entering Fast Recovery, set cwnd to the number of packets still
    TEXT[test]:    in flight (allowing at least one for a fast retransmit):
    TEXT[test]:      BBROnEnterFastRecovery():
    TEXT[test]:        BBR.prior_cwnd = BBRSaveCwnd()
    TEXT[test]:        cwnd = packets_in_flight + max(rs.newly_acked, 1)
    TEXT[test]:        BBR.packet_conservation = true
    TEXT[implementation,test]:      BBRSaveCwnd():
    TEXT[implementation,test]:        if (!InLossRecovery() and BBR.state != ProbeRTT)
    TEXT[implementation,test]:          return cwnd
    TEXT[implementation,test]:        else
    TEXT[implementation,test]:          return max(BBR.prior_cwnd, cwnd)
    TEXT[implementation,test]:      BBRRestoreCwnd():
    TEXT[implementation,test]:        cwnd = max(cwnd, BBR.prior_cwnd)

  SECTION: [Modulating cwnd in ProbeRTT](#section-4.6.4.5)
    TEXT[implementation,test]:      BBRProbeRTTCwnd():
    TEXT[implementation,test]:        probe_rtt_cwnd = BBRBDPMultiple(BBR.bw, BBRProbeRTTCwndGain)
    TEXT[implementation,test]:        probe_rtt_cwnd = max(probe_rtt_cwnd, BBRMinPipeCwnd)
    TEXT[implementation,test]:        return probe_rtt_cwnd
    TEXT[implementation,test]:      BBRBoundCwndForProbeRTT():
    TEXT[implementation,test]:        if (BBR.state == ProbeRTT)
    TEXT[implementation,test]:          cwnd = min(cwnd, BBRProbeRTTCwnd())

  SECTION: [Core cwnd Adjustment Mechanism](#section-4.6.4.6)
    TEXT[implementation]:      BBRSetCwnd():
    TEXT[implementation]:        BBRUpdateMaxInflight()
    TEXT[implementation,exception]:        BBRModulateCwndForRecovery()
    TEXT[implementation]:        if (!BBR.packet_conservation) {
    TEXT[implementation,test]:          if (BBR.filled_pipe)
    TEXT[implementation,test]:            cwnd = min(cwnd + rs.newly_acked, BBR.max_inflight)
    TEXT[implementation,test]:          else if (cwnd < BBR.max_inflight || C.delivered < InitialCwnd)
    TEXT[implementation,test]:            cwnd = cwnd + rs.newly_acked
    TEXT[implementation]:          cwnd = max(cwnd, BBRMinPipeCwnd)
    TEXT[implementation]:        BBRBoundCwndForProbeRTT()
    TEXT[implementation]:        BBRBoundCwndForModel()

  SECTION: [Bounding cwnd Based on Recent Congestion](#section-4.6.4.7)
    TEXT[implementation,test]:      BBRBoundCwndForModel():
    TEXT[implementation,test]:        cap = Infinity
    TEXT[implementation,test]:        if (IsInAProbeBWState() and
    TEXT[implementation,test]:            BBR.state != ProbeBW_CRUISE)
    TEXT[implementation,test]:          cap = BBR.inflight_hi
    TEXT[implementation,test]:        else if (BBR.state == ProbeRTT or
    TEXT[implementation,test]:                 BBR.state == ProbeBW_CRUISE)
    TEXT[implementation,test]:          cap = BBRInflightWithHeadroom()
    TEXT[implementation,test]:        /* apply inflight_lo (possibly infinite): */
    TEXT[implementation,test]:        cap = min(cap, BBR.inflight_lo)
    TEXT[implementation,test]:        cap = max(cap, BBRMinPipeCwnd)
    TEXT[implementation,test]:        cwnd = min(cwnd, cap)

SPECIFICATION: https://tools.ietf.org/id/draft-cheng-iccrg-delivery-rate-estimation-02
  SECTION: [Estimating Delivery Rate](#section-2.2)
    TEXT[implementation]:    The amount of data delivered MAY be tracked in units of either octets
    TEXT[implementation]:    or packets.

  SECTION: [Delivery Rate](#section-2.2.4)
    TEXT[implementation,test]:    Since it is physically impossible to have data delivered faster than
    TEXT[implementation,test]:    it is sent in a sustained fashion, when the estimator notices that
    TEXT[implementation,test]:    the ack_rate for a flight is faster than the send rate for the
    TEXT[implementation,test]:    flight, it filters out the implausible ack_rate by capping the
    TEXT[implementation,test]:    delivery rate sample to be no higher than the send rate.

  SECTION: [Transmitting or retransmitting a data packet](#section-3.2)
    TEXT[implementation]: If there are no packets in flight
    TEXT[implementation]:    yet, then we can start the delivery rate interval at the current
    TEXT[implementation]:    time, since we know that any ACKs after now indicate that the network
    TEXT[implementation]:    was able to deliver those packets completely in the sampling interval
    TEXT[implementation]:    between now and the next ACK.
    TEXT[implementation]:    Upon each packet transmission, the sender executes the following
    TEXT[implementation]:    steps:
    TEXT[implementation]:      SendPacket(Packet P):
    TEXT[implementation]:        if (SND.NXT == SND.UNA)  /* no packets in flight yet? */
    TEXT[implementation]:          C.first_sent_time  = C.delivered_time = Now()
    TEXT[implementation]:        P.first_sent_time = C.first_sent_time
    TEXT[implementation]:        P.delivered_time  = C.delivered_time
    TEXT[implementation]:        P.delivered       = C.delivered
    TEXT[implementation]:        P.is_app_limited  = (C.app_limited != 0)

  SECTION: [Upon receiving an ACK](#section-3.3)
    TEXT[implementation]: For each packet that was newly SACKed or ACKed,
    TEXT[implementation]:    UpdateRateSample() updates the rate sample based on a snapshot of
    TEXT[implementation]:    connection delivery information from the time at which the packet was
    TEXT[implementation]:    last transmitted.
    TEXT[implementation,test]: UpdateRateSample() is invoked multiple times when
    TEXT[implementation,test]:    a stretched ACK acknowledges multiple data packets.  In this case we
    TEXT[implementation,test]:    use the information from the most recently sent packet, i.e., the
    TEXT[implementation,test]:    packet with the highest "P.delivered" value.

SPECIFICATION: https://tools.ietf.org/id/draft-eggert-tcpm-rfc8312bis-01
  SECTION: [Window Increase Function](#section-4.2)
    TEXT[implementation]: _K_ is the time period that the above
    TEXT[implementation]:    function takes to increase the congestion window size at the
    TEXT[implementation]:    beginning of the current congestion avoidance stage to _W_(max)_ if
    TEXT[implementation]:    there are no further congestion events and is calculated using the
    TEXT[implementation]:    following equation:
    TEXT[implementation]:                                   ________________
    TEXT[implementation]:                                  /W    - cwnd
    TEXT[implementation]:                              3  /  max       start
    TEXT[implementation]:                          K = | /  ----------------
    TEXT[implementation]:                              |/           C
    TEXT[implementation]:                                   Figure 2
    TEXT[implementation]:    where _cwnd_(start)_ is the congestion window at the beginning of the
    TEXT[implementation]:    current congestion avoidance stage.

SPECIFICATION: https://tools.ietf.org/id/draft-ietf-tcpm-hystartplusplus-04.txt
  SECTION: [Algorithm Details](#section-4.2)
    TEXT[implementation]:          o  RttThresh = clamp(MIN_RTT_THRESH, lastRoundMinRTT / 8,
    TEXT[implementation]:             MAX_RTT_THRESH)

  SECTION: [Tuning constants](#section-4.3)
    TEXT[implementation]:    It is RECOMMENDED that a HyStart++ implementation use the following
    TEXT[implementation]:    constants:
    TEXT[implementation]:    *  MIN_RTT_THRESH = 4 msec
    TEXT[implementation]:    *  MAX_RTT_THRESH = 16 msec
    TEXT[implementation]:    *  N_RTT_SAMPLE = 8
    TEXT[implementation]:    *  CSS_GROWTH_DIVISOR = 4
    TEXT[implementation]:    *  CSS_ROUNDS = 5
    TEXT[implementation]:    An implementation SHOULD use HyStart++ only for the initial slow
    TEXT[implementation]:    start (when ssthresh is at its initial value of arbitrarily high per
    TEXT[implementation]:    [RFC5681]) and fall back to using traditional slow start for the
    TEXT[implementation]:    remainder of the connection lifetime.

SPECIFICATION: https://tools.ietf.org/id/draft-marx-qlog-event-definitions-quic-h3-02
  SECTION: [QUIC and HTTP/3 fields](#section-4)
    TEXT[implementation]: it is recommended to use
    TEXT[implementation]:    QUIC's Original Destination Connection ID (ODCID, the CID chosen by
    TEXT[implementation]:    the client when first contacting the server)

  SECTION: [version_information](#section-5.3.1)
    TEXT[implementation]:    QUIC endpoints each have their own list of of QUIC versions they
    TEXT[implementation]:    support.
    TEXT[implementation]: Upon receiving a client initial with a supported version, the
    TEXT[implementation]:       server logs this event with server_versions and chosen_version set
    TEXT[implementation]: Upon receiving a client initial with an unsupported version, the
    TEXT[implementation]:       server logs this event with server_versions set and
    TEXT[implementation]:       client_versions to the single-element array containing the
    TEXT[implementation]:       client's attempted version.  The absence of chosen_version implies
    TEXT[implementation]:       no overlap was found.

  SECTION: [alpn_information](#section-5.3.2)
    TEXT[implementation]:    QUIC implementations each have their own list of application level
    TEXT[implementation]:    protocols and versions thereof they support.

SPECIFICATION: https://www.rfc-editor.org/rfc/rfc1071
  SECTION: [Numerical Examples](#section-3)
    TEXT[test]:    We now present explicit examples of calculating a simple 1's
    TEXT[test]:    complement sum on a 2's complement machine.  The examples show the
    TEXT[test]:    same sum calculated byte by bye, by 16-bits words in normal and
    TEXT[test]:    swapped order, and 32 bits at a time in 3 different orders.  All
    TEXT[test]:    numbers are in hex.
    TEXT[test]:                   Byte-by-byte    "Normal"  Swapped
    TEXT[test]:                                     Order    Order
    TEXT[test]:         Byte 0/1:    00   01        0001      0100
    TEXT[test]:         Byte 2/3:    f2   03        f203      03f2
    TEXT[test]:         Byte 4/5:    f4   f5        f4f5      f5f4
    TEXT[test]:         Byte 6/7:    f6   f7        f6f7      f7f6
    TEXT[test]:                     ---  ---       -----     -----
    TEXT[test]:         Sum1:       2dc  1f0       2ddf0     1f2dc
    TEXT[test]:                      dc   f0        ddf0      f2dc
    TEXT[test]:         Carrys:       1    2           2         1
    TEXT[test]:                      --   --        ----      ----
    TEXT[test]:         Sum2:        dd   f2        ddf2      f2dd
    TEXT[test]:         Final Swap:  dd   f2        ddf2      ddf2

  SECTION: ["C"](#section-4.1)
    TEXT[implementation,test]:    The following "C" code algorithm computes the checksum with an inner
    TEXT[implementation,test]:    loop that sums 16-bits at a time in a 32-bit accumulator.
    TEXT[implementation,test]:    in 6
    TEXT[implementation,test]:            /* Compute Internet Checksum for "count" bytes
    TEXT[implementation,test]:             *         beginning at location "addr".
    TEXT[implementation,test]:             */
    TEXT[implementation,test]:        register long sum = 0;
    TEXT[implementation,test]:         while( count > 1 )  {
    TEXT[implementation,test]:            /*  This is the inner loop */
    TEXT[implementation,test]:                sum += * (unsigned short) addr++;
    TEXT[implementation,test]:                count -= 2;
    TEXT[implementation,test]:            /*  Add left-over byte, if any */
    TEXT[implementation,test]:        if( count > 0 )
    TEXT[implementation,test]:                sum += * (unsigned char *) addr;
    TEXT[implementation,test]:            /*  Fold 32-bit sum to 16 bits */
    TEXT[implementation,test]:        while (sum>>16)
    TEXT[implementation,test]:            sum = (sum & 0xffff) + (sum >> 16);
    TEXT[implementation,test]:        checksum = ~sum;

SPECIFICATION: https://www.rfc-editor.org/rfc/rfc1112
  SECTION: [HOST GROUP ADDRESSES](#section-4)
    TEXT[implementation]: Class E IP addresses, i.e.,
    TEXT[implementation]:    those with "1111" as their high-order four bits, are reserved for
    TEXT[implementation]:    future addressing modes.

SPECIFICATION: https://www.rfc-editor.org/rfc/rfc1918
  SECTION: [Private Address Space](#section-3)
    TEXT[implementation]:    The Internet Assigned Numbers Authority (IANA) has reserved the
    TEXT[implementation]:    following three blocks of the IP address space for private internets:
    TEXT[implementation]:      10.0.0.0        -   10.255.255.255  (10/8 prefix)
    TEXT[implementation]:      172.16.0.0      -   172.31.255.255  (172.16/12 prefix)
    TEXT[implementation]:      192.168.0.0     -   192.168.255.255 (192.168/16 prefix)

SPECIFICATION: https://www.rfc-editor.org/rfc/rfc2373
  SECTION: [IPv6 ADDRESSING](#section-2.0)
    TEXT[implementation]:    IPv6 addresses are 128-bit identifiers for interfaces and sets of
    TEXT[implementation]:    interfaces.

SPECIFICATION: https://www.rfc-editor.org/rfc/rfc2460
  SECTION: [Upper-Layer Checksums](#section-8.1)
    TEXT[implementation]:    Any transport or other upper-layer protocol that includes the
    TEXT[implementation]:    addresses from the IP header in its checksum computation must be
    TEXT[implementation]:    modified for use over IPv6, to include the 128-bit IPv6 addresses
    TEXT[implementation]:    instead of 32-bit IPv4 addresses.  In particular, the following
    TEXT[implementation]:    illustration shows the TCP and UDP "pseudo-header" for IPv6:
    TEXT[implementation]:    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    TEXT[implementation]:    |                                                               |
    TEXT[implementation]:    +                                                               +
    TEXT[implementation]:    |                                                               |
    TEXT[implementation]:    +                         Source Address                        +
    TEXT[implementation]:    |                                                               |
    TEXT[implementation]:    +                                                               +
    TEXT[implementation]:    |                                                               |
    TEXT[implementation]:    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    TEXT[implementation]:    |                                                               |
    TEXT[implementation]:    +                                                               +
    TEXT[implementation]:    |                                                               |
    TEXT[implementation]:    +                      Destination Address                      +
    TEXT[implementation]:    |                                                               |
    TEXT[implementation]:    +                                                               +
    TEXT[implementation]:    |                                                               |
    TEXT[implementation]:    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    TEXT[implementation]:    |                   Upper-Layer Packet Length                   |
    TEXT[implementation]:    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    TEXT[implementation]:    |                      zero                     |  Next Header  |
    TEXT[implementation]:    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

SPECIFICATION: https://www.rfc-editor.org/rfc/rfc2544
  SECTION: [Protocol Addresses](#appendix-C.2.2)
    TEXT[implementation]:    The network addresses 192.18.0.0 through 198.19.255.255 are have been
    TEXT[implementation]:    assigned to the BMWG by the IANA for this purpose.

SPECIFICATION: https://www.rfc-editor.org/rfc/rfc3168
  SECTION: [Explicit Congestion Notification in IP](#section-5)
    TEXT[implementation]:    This document specifies that the Internet provide a congestion
    TEXT[implementation]:    indication for incipient congestion (as in RED and earlier work
    TEXT[implementation]:    [RJ90]) where the notification can sometimes be through marking
    TEXT[implementation]:    packets rather than dropping them.  This uses an ECN field in the IP
    TEXT[implementation]:    header with two bits, making four ECN codepoints, '00' to '11'.  The
    TEXT[implementation]:    ECN-Capable Transport (ECT) codepoints '10' and '01' are set by the
    TEXT[implementation]:    data sender to indicate that the end-points of the transport protocol
    TEXT[implementation]:    are ECN-capable; we call them ECT(0) and ECT(1) respectively.  The
    TEXT[implementation]:    phrase "the ECT codepoint" in this documents refers to either of the
    TEXT[implementation]:    two ECT codepoints.  Routers treat the ECT(0) and ECT(1) codepoints
    TEXT[implementation]:    as equivalent.  Senders are free to use either the ECT(0) or the
    TEXT[implementation]:    ECT(1) codepoint to indicate ECT, on a packet-by-packet basis.
    TEXT[implementation]:    The use of both the two codepoints for ECT, ECT(0) and ECT(1), is
    TEXT[implementation]:    motivated primarily by the desire to allow mechanisms for the data
    TEXT[implementation]:    sender to verify that network elements are not erasing the CE
    TEXT[implementation]:    codepoint, and that data receivers are properly reporting to the
    TEXT[implementation]:    sender the receipt of packets with the CE codepoint set, as required
    TEXT[implementation]:    by the transport protocol.  Guidelines for the senders and receivers
    TEXT[implementation]:    to differentiate between the ECT(0) and ECT(1) codepoints will be
    TEXT[implementation]:    addressed in separate documents, for each transport protocol.  In
    TEXT[implementation]:    particular, this document does not address mechanisms for TCP end-
    TEXT[implementation]:    nodes to differentiate between the ECT(0) and ECT(1) codepoints.
    TEXT[implementation]:    Protocols and senders that only require a single ECT codepoint SHOULD
    TEXT[implementation]:    use ECT(0).
    TEXT[implementation]:    The not-ECT codepoint '00' indicates a packet that is not using ECN.
    TEXT[implementation]:    The CE codepoint '11' is set by a router to indicate congestion to
    TEXT[implementation]:    the end nodes.  Routers that have a packet arriving at a full queue
    TEXT[implementation]:    drop the packet, just as they do in the absence of ECN.
    TEXT[implementation]:       +-----+-----+
    TEXT[implementation]:       | ECN FIELD |
    TEXT[implementation]:       +-----+-----+
    TEXT[implementation]:         ECT   CE         [Obsolete] RFC 2481 names for the ECN bits.
    TEXT[implementation]:          0     0         Not-ECT
    TEXT[implementation]:          0     1         ECT(1)
    TEXT[implementation]:          1     0         ECT(0)
    TEXT[implementation]:          1     1         CE
    TEXT[implementation]:       Figure 1: The ECN Field in IP.

SPECIFICATION: https://www.rfc-editor.org/rfc/rfc3849
  SECTION: [IANA Considerations](#section-4)
    TEXT[implementation]:    IANA is to record the allocation of the IPv6 global unicast address
    TEXT[implementation]:    prefix  2001:DB8::/32 as a documentation-only prefix  in the IPv6
    TEXT[implementation]:    address registry.

SPECIFICATION: https://www.rfc-editor.org/rfc/rfc3927
  SECTION: [IANA Considerations](#section-8)
    TEXT[implementation]:    The IANA has allocated the prefix 169.254/16 for the use described in
    TEXT[implementation]:    this document.

SPECIFICATION: https://www.rfc-editor.org/rfc/rfc4193
  SECTION: [Introduction](#section-1)
    TEXT[implementation]: They are not
    TEXT[implementation]:    expected to be routable on the global Internet.  They are routable
    TEXT[implementation]:    inside of a more limited area such as a site.  They may also be
    TEXT[implementation]:    routed between a limited set of sites.

  SECTION: [IANA Considerations](#section-8)
    TEXT[implementation]:    The IANA has assigned the FC00::/7 prefix to "Unique Local Unicast".

SPECIFICATION: https://www.rfc-editor.org/rfc/rfc4291
  SECTION: [The Unspecified Address](#section-2.5.2)
    TEXT[implementation]:    The address 0:0:0:0:0:0:0:0 is called the unspecified address.

  SECTION: [The Loopback Address](#section-2.5.3)
    TEXT[implementation]:    The unicast address 0:0:0:0:0:0:0:1 is called the loopback address.

  SECTION: [IPv4-Compatible IPv6 Address](#section-2.5.5.1)
    TEXT[implementation]: The format of the "IPv4-Compatible IPv6 address" is as
    TEXT[implementation]:    follows:
    TEXT[implementation]:    |                80 bits               | 16 |      32 bits        |
    TEXT[implementation]:    +--------------------------------------+--------------------------+
    TEXT[implementation]:    |0000..............................0000|0000|    IPv4 address     |
    TEXT[implementation]:    +--------------------------------------+----+---------------------+

  SECTION: [IPv4-Mapped IPv6 Address](#section-2.5.5.2)
    TEXT[implementation]: The format of the "IPv4-mapped IPv6
    TEXT[implementation]:    address" is as follows:
    TEXT[implementation]:    |                80 bits               | 16 |      32 bits        |
    TEXT[implementation]:    +--------------------------------------+--------------------------+
    TEXT[implementation]:    |0000..............................0000|FFFF|    IPv4 address     |
    TEXT[implementation]:    +--------------------------------------+----+---------------------+

  SECTION: [Link-Local IPv6 Unicast Addresses](#section-2.5.6)
    TEXT[implementation]: Link-Local
    TEXT[implementation]:    addresses have the following format:
    TEXT[implementation]:    |   10     |
    TEXT[implementation]:    |  bits    |         54 bits         |          64 bits           |
    TEXT[implementation]:    +----------+-------------------------+----------------------------+
    TEXT[implementation]:    |1111111010|           0             |       interface ID         |
    TEXT[implementation]:    +----------+-------------------------+----------------------------+

  SECTION: [Multicast Addresses](#section-2.7)
    TEXT[implementation]:       binary 11111111 at the start of the address identifies the address
    TEXT[implementation]:       as being a multicast address.

SPECIFICATION: https://www.rfc-editor.org/rfc/rfc4303
  SECTION: [Sequence Number Verification](#section-3.4.3)
    TEXT[implementation]:    Duplicates are rejected through the use of a sliding receive window.
    TEXT[implementation]:    How the window is implemented is a local matter, but the following
    TEXT[implementation]:    text describes the functionality that the implementation must
    TEXT[implementation]:    exhibit.
    TEXT[implementation]:    The "right" edge of the window represents the highest, validated
    TEXT[implementation]:    Sequence Number value received on this SA.  Packets that contain
    TEXT[implementation]:    sequence numbers lower than the "left" edge of the window are
    TEXT[implementation]:    rejected.  Packets falling within the window are checked against a
    TEXT[implementation]:    list of received packets within the window.

SPECIFICATION: https://www.rfc-editor.org/rfc/rfc5156
  SECTION: [IPv4-Mapped Addresses](#section-2.2)
    TEXT[implementation,test]:    ::FFFF:0:0/96 are the IPv4-mapped addresses [RFC4291].

SPECIFICATION: https://www.rfc-editor.org/rfc/rfc5180
  SECTION: [IANA Considerations](#section-8)
    TEXT[implementation]:    The IANA has allocated 2001:0200::/48 for IPv6 benchmarking, which is
    TEXT[implementation]:    a 48-bit prefix from the RFC 4773 pool.

SPECIFICATION: https://www.rfc-editor.org/rfc/rfc5246
  SECTION: [Handshake Protocol](#appendix-A.4)
    TEXT[implementation]:    enum {
    TEXT[implementation]:        hello_request(0), client_hello(1), server_hello(2),
    TEXT[implementation]:        certificate(11), server_key_exchange (12),
    TEXT[implementation]:        certificate_request(13), server_hello_done(14),
    TEXT[implementation]:        certificate_verify(15), client_key_exchange(16),
    TEXT[implementation]:        finished(20)
    TEXT[implementation]:        (255)
    TEXT[implementation]:    } HandshakeType;
    TEXT[implementation]:    struct {
    TEXT[implementation]:        HandshakeType msg_type;
    TEXT[implementation]:        uint24 length;
    TEXT[implementation]:        select (HandshakeType) {
    TEXT[implementation]:            case hello_request:       HelloRequest;
    TEXT[implementation]:            case client_hello:        ClientHello;
    TEXT[implementation]:            case server_hello:        ServerHello;
    TEXT[implementation]:            case certificate:         Certificate;
    TEXT[implementation]:            case server_key_exchange: ServerKeyExchange;
    TEXT[implementation]:            case certificate_request: CertificateRequest;
    TEXT[implementation]:            case server_hello_done:   ServerHelloDone;
    TEXT[implementation]:            case certificate_verify:  CertificateVerify;
    TEXT[implementation]:            case client_key_exchange: ClientKeyExchange;
    TEXT[implementation]:            case finished:            Finished;
    TEXT[implementation]:        } body;
    TEXT[implementation]:    } Handshake;

SPECIFICATION: https://www.rfc-editor.org/rfc/rfc5737
  SECTION: [Documentation Address Blocks](#section-3)
    TEXT[implementation]:    The blocks 192.0.2.0/24 (TEST-NET-1), 198.51.100.0/24 (TEST-NET-2),
    TEXT[implementation]:    and 203.0.113.0/24 (TEST-NET-3) are provided for use in
    TEXT[implementation]:    documentation.

SPECIFICATION: https://www.rfc-editor.org/rfc/rfc6052
  SECTION: [Well-Known Prefix](#section-2.1)
    TEXT[implementation]:    This document reserves a "Well-Known Prefix" for use in an
    TEXT[implementation]:    algorithmic mapping.  The value of this IPv6 prefix is:
    TEXT[implementation]:       64:ff9b::/96

SPECIFICATION: https://www.rfc-editor.org/rfc/rfc6335
  SECTION: [Port Number Ranges](#section-6)
    TEXT[implementation]:    o  the System Ports, also known as the Well Known Ports, from 0-1023
    TEXT[implementation]:       (assigned by IANA)
    TEXT[implementation]:    o  the User Ports, also known as the Registered Ports, from 1024-
    TEXT[implementation]:       49151 (assigned by IANA)
    TEXT[implementation]:    o  the Dynamic Ports, also known as the Private or Ephemeral Ports,
    TEXT[implementation]:       from 49152-65535 (never assigned)

SPECIFICATION: https://www.rfc-editor.org/rfc/rfc6598
  SECTION: [Introduction](#section-1)
    TEXT[implementation]:    Shared Address Space is similar to [RFC1918] private address space in
    TEXT[implementation]:    that it is not globally routable address space and can be used by
    TEXT[implementation]:    multiple pieces of equipment.

  SECTION: [IANA Considerations](#section-7)
    TEXT[implementation]:    The Shared Address Space address range is 100.64.0.0/10.

SPECIFICATION: https://www.rfc-editor.org/rfc/rfc6666
  SECTION: [IANA Considerations](#section-4)
    TEXT[implementation]:    Per this document, IANA has recorded the allocation of the IPv6
    TEXT[implementation]:    address prefix 0100::/64 as a Discard-Only Prefix in the "Internet
    TEXT[implementation]:    Protocol Version 6 Address Space" and added the prefix to the "IANA
    TEXT[implementation]:    IPv6 Special Purpose Address Registry" [IANA-IPV6REG].

SPECIFICATION: https://www.rfc-editor.org/rfc/rfc6676
  SECTION: [IPv4 Multicast Documentation Addresses](#section-2)
    TEXT[implementation]:    For Any-Source Multicast (ASM), the IPv4 multicast addresses
    TEXT[implementation]:    allocated for documentation purposes are 233.252.0.0 - 233.252.0.255
    TEXT[implementation]:    (233.252.0.0/24).

SPECIFICATION: https://www.rfc-editor.org/rfc/rfc6890
  SECTION: [Assignment of an IPv4 Address Block to IANA](#section-2.1)
    TEXT[implementation]:    Table 7 of this document records the assignment of an IPv4 address
    TEXT[implementation]:    block (192.0.0.0/24) to IANA for IETF protocol assignments.

  SECTION: [IPv6 Special-Purpose Address Registry Entries](#section-2.2.3)
    TEXT[implementation]:               +----------------------+---------------------------+
    TEXT[implementation]:               | Attribute            | Value                     |
    TEXT[implementation]:               +----------------------+---------------------------+
    TEXT[implementation]:               | Address Block        | 2001::/23                 |
    TEXT[implementation]:               | Name                 | IETF Protocol Assignments |
    TEXT[implementation]:               | RFC                  | [RFC2928]                 |
    TEXT[implementation]:               | Allocation Date      | September 2000            |
    TEXT[implementation]:               | Termination Date     | N/A                       |
    TEXT[implementation]:               | Source               | False[1]                  |
    TEXT[implementation]:               | Destination          | False[1]                  |
    TEXT[implementation]:               | Forwardable          | False[1]                  |
    TEXT[implementation]:               | Global               | False[1]                  |
    TEXT[implementation]:               | Reserved-by-Protocol | False                     |
    TEXT[implementation]:               +----------------------+---------------------------+

SPECIFICATION: https://www.rfc-editor.org/rfc/rfc7301
  SECTION: [The Application-Layer Protocol Negotiation Extension](#section-3.1)
    TEXT[implementation]:    Client                                              Server
    TEXT[implementation]:    ClientHello                     -------->       ServerHello
    TEXT[implementation]:      (ALPN extension &                               (ALPN extension &
    TEXT[implementation]:       list of protocols)                              selected protocol)
    TEXT[implementation]:                                                    [ChangeCipherSpec]
    TEXT[implementation]:                                    <--------       Finished
    TEXT[implementation]:    [ChangeCipherSpec]
    TEXT[implementation]:    Finished                        -------->
    TEXT[implementation]:    Application Data                <------->       Application Data

SPECIFICATION: https://www.rfc-editor.org/rfc/rfc7723
  SECTION: [Registration of an IPv4 Special-Purpose Address](#section-4.1)
    TEXT[implementation]:    +----------------------+-------------------------------------------+
    TEXT[implementation]:    | Attribute            | Value                                     |
    TEXT[implementation]:    +----------------------+-------------------------------------------+
    TEXT[implementation]:    | Address Block        | 192.0.0.9/32                              |
    TEXT[implementation]:    | Name                 | Port Control Protocol Anycast             |
    TEXT[implementation]:    | RFC                  | RFC 7723 (this document)                  |
    TEXT[implementation]:    | Allocation Date      | October 2015                              |
    TEXT[implementation]:    | Termination Date     | N/A                                       |
    TEXT[implementation]:    | Source               | True                                      |
    TEXT[implementation]:    | Destination          | True                                      |
    TEXT[implementation]:    | Forwardable          | True                                      |
    TEXT[implementation]:    | Global               | True                                      |

  SECTION: [Registration of an IPv6 Special-Purpose Address](#section-4.2)
    TEXT[implementation]:    +----------------------+-------------------------------------------+
    TEXT[implementation]:    | Attribute            | Value                                     |
    TEXT[implementation]:    +----------------------+-------------------------------------------+
    TEXT[implementation]:    | Address Block        | 2001:1::1/128                             |
    TEXT[implementation]:    | Name                 | Port Control Protocol Anycast             |
    TEXT[implementation]:    | RFC                  | RFC 7723 (this document)                  |
    TEXT[implementation]:    | Allocation Date      | October 2015                              |
    TEXT[implementation]:    | Termination Date     | N/A                                       |
    TEXT[implementation]:    | Source               | True                                      |
    TEXT[implementation]:    | Destination          | True                                      |
    TEXT[implementation]:    | Forwardable          | True                                      |
    TEXT[implementation]:    | Global               | True                                      |
    TEXT[implementation]:    | Reserved-by-Protocol | False                                     |
    TEXT[implementation]:    +----------------------+-------------------------------------------+

SPECIFICATION: https://www.rfc-editor.org/rfc/rfc791
  SECTION: [Function Description](#section-2.3)
    TEXT[implementation]:     Addresses are fixed length of four octets (32 bits).

  SECTION: [Internet Header Format](#section-3.1)
    TEXT[implementation]:   IHL:  4 bits
    TEXT[implementation]:     Internet Header Length is the length of the internet header in 32
    TEXT[implementation]:     bit words, and thus points to the beginning of the data.  Note that
    TEXT[implementation]:     the minimum value for a correct header is 5.

SPECIFICATION: https://www.rfc-editor.org/rfc/rfc791.html
  SECTION: [Internet Header Format](#section-3.1)
    TEXT[implementation]:   A summary of the contents of the internet header follows:
    TEXT[implementation]:     0                   1                   2                   3
    TEXT[implementation]:     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
    TEXT[implementation]:    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    TEXT[implementation]:    |Version|  IHL  |Type of Service|          Total Length         |
    TEXT[implementation]:    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    TEXT[implementation]:    |         Identification        |Flags|      Fragment Offset    |
    TEXT[implementation]:    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    TEXT[implementation]:    |  Time to Live |    Protocol   |         Header Checksum       |
    TEXT[implementation]:    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    TEXT[implementation]:    |                       Source Address                          |
    TEXT[implementation]:    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    TEXT[implementation]:    |                    Destination Address                        |
    TEXT[implementation]:    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    TEXT[implementation]:    |                    Options                    |    Padding    |
    TEXT[implementation]:    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

SPECIFICATION: https://www.rfc-editor.org/rfc/rfc8155
  SECTION: [IPv4 Anycast](#section-8.1)
    TEXT[implementation]:     +----------------------+-------------------------------------------+
    TEXT[implementation]:     | Attribute            | Value                                     |
    TEXT[implementation]:     +----------------------+-------------------------------------------+
    TEXT[implementation]:     | Address Block        | 192.0.0.10/32                             |
    TEXT[implementation]:     | Name                 | Traversal Using Relays around NAT Anycast |
    TEXT[implementation]:     | RFC                  | RFC 8155                                  |
    TEXT[implementation]:     | Allocation Date      | 2017-02                                   |
    TEXT[implementation]:     | Termination Date     | N/A                                       |
    TEXT[implementation]:     | Source               | True                                      |
    TEXT[implementation]:     | Destination          | True                                      |
    TEXT[implementation]:     | Forwardable          | True                                      |
    TEXT[implementation]:     | Global               | True                                      |

  SECTION: [IPv6 Anycast](#section-8.2)
    TEXT[implementation]:     +----------------------+-------------------------------------------+
    TEXT[implementation]:     | Attribute            | Value                                     |
    TEXT[implementation]:     +----------------------+-------------------------------------------+
    TEXT[implementation]:     | Address Block        | 2001:1::2/128                             |
    TEXT[implementation]:     | Name                 | Traversal Using Relays around NAT Anycast |
    TEXT[implementation]:     | RFC                  | RFC 8155                                  |
    TEXT[implementation]:     | Allocation Date      | 2017-02                                   |
    TEXT[implementation]:     | Termination Date     | N/A                                       |
    TEXT[implementation]:     | Source               | True                                      |
    TEXT[implementation]:     | Destination          | True                                      |
    TEXT[implementation]:     | Forwardable          | True                                      |
    TEXT[implementation]:     | Global               | True                                      |
    TEXT[implementation]:     | Reserved-by-Protocol | False                                     |
    TEXT[implementation]:     +----------------------+-------------------------------------------+

SPECIFICATION: https://www.rfc-editor.org/rfc/rfc8200
  SECTION: [IPv6 Header Format](#section-3)
    TEXT[implementation]:    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    TEXT[implementation]:    |Version| Traffic Class |           Flow Label                  |
    TEXT[implementation]:    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    TEXT[implementation]:    |         Payload Length        |  Next Header  |   Hop Limit   |
    TEXT[implementation]:    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    TEXT[implementation]:    |                                                               |
    TEXT[implementation]:    +                                                               +
    TEXT[implementation]:    |                                                               |
    TEXT[implementation]:    +                         Source Address                        +
    TEXT[implementation]:    |                                                               |
    TEXT[implementation]:    +                                                               +
    TEXT[implementation]:    |                                                               |
    TEXT[implementation]:    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    TEXT[implementation]:    |                                                               |
    TEXT[implementation]:    +                                                               +
    TEXT[implementation]:    |                                                               |
    TEXT[implementation]:    +                      Destination Address                      +
    TEXT[implementation]:    |                                                               |
    TEXT[implementation]:    +                                                               +
    TEXT[implementation]:    |                                                               |
    TEXT[implementation]:    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

SPECIFICATION: https://www.rfc-editor.org/rfc/rfc8312
  SECTION: [Window Increase Function](#section-4.1)
    TEXT[implementation]: W_max is the window size just before the window is
    TEXT[implementation]:    reduced in the last congestion event.
    TEXT[implementation]:    CUBIC uses the following window increase function:
    TEXT[implementation]:        W_cubic(t) = C*(t-K)^3 + W_max (Eq. 1)
    TEXT[implementation]:    where C is a constant fixed to determine the aggressiveness of window
    TEXT[implementation]:    increase in high BDP networks, t is the elapsed time from the
    TEXT[implementation]:    beginning of the current congestion avoidance, and K is the time
    TEXT[implementation]:    period that the above function takes to increase the current window
    TEXT[implementation]:    size to W_max if there are no further congestion events and is
    TEXT[implementation]:    calculated using the following equation:
    TEXT[implementation]:        K = cubic_root(W_max*(1-beta_cubic)/C) (Eq. 2)
    TEXT[implementation]:    where beta_cubic is the CUBIC multiplication decrease factor
    TEXT[implementation]:    Upon receiving an ACK during congestion avoidance, CUBIC computes the
    TEXT[implementation]:    window increase rate during the next RTT period using Eq. 1.  It sets
    TEXT[implementation]:    W_cubic(t+RTT) as the candidate target value of the congestion
    TEXT[implementation]:    window
    TEXT[implementation]: RTT is the weighted average RTT

  SECTION: [TCP-Friendly Region](#section-4.2)
    TEXT[implementation]: When
    TEXT[implementation]:    receiving an ACK in congestion avoidance (cwnd could be greater than
    TEXT[implementation]:    or less than W_max), CUBIC checks whether W_cubic(t) is less than
    TEXT[implementation]:    W_est(t).
    TEXT[!SHOULD,implementation,test]: If so, CUBIC is in the TCP-friendly region and cwnd SHOULD
    TEXT[!SHOULD,implementation,test]:    be set to W_est(t) at each reception of an ACK.
    TEXT[implementation]:        W_est(t) = W_max*beta_cubic +

  SECTION: [Concave Region](#section-4.3)
    TEXT[implementation]:    When receiving an ACK in congestion avoidance, if CUBIC is not in the
    TEXT[implementation]:    TCP-friendly region and cwnd is less than W_max, then CUBIC is in the
    TEXT[implementation]:    concave region.
    TEXT[!MUST,implementation,test]: In this region, cwnd MUST be incremented by
    TEXT[!MUST,implementation,test]:    (W_cubic(t+RTT) - cwnd)/cwnd for each received ACK, where
    TEXT[!MUST,implementation,test]:    W_cubic(t+RTT) is calculated using Eq.
    TEXT[implementation,test]:  1.

  SECTION: [Convex Region](#section-4.4)
    TEXT[!MUST,implementation,test]: In this region, cwnd MUST be incremented by
    TEXT[!MUST,implementation,test]:    (W_cubic(t+RTT) - cwnd)/cwnd for each received ACK, where
    TEXT[!MUST,implementation,test]:    W_cubic(t+RTT) is calculated using Eq.
    TEXT[implementation,test]:  1.

  SECTION: [Multiplicative Decrease](#section-4.5)
    TEXT[implementation]:    When a packet loss is detected by duplicate ACKs or a network
    TEXT[implementation]:    congestion is detected by ECN-Echo ACKs, CUBIC updates its W_max,
    TEXT[implementation]:    cwnd, and ssthresh as follows.
    TEXT[!SHOULD,implementation,test]: Parameter beta_cubic SHOULD be set to
    TEXT[!SHOULD,implementation,test]:    0.7.
    TEXT[implementation]:       W_max = cwnd;                 // save window size before reduction
    TEXT[implementation]:       ssthresh = cwnd * beta_cubic; // new slow-start threshold
    TEXT[implementation]:       ssthresh = max(ssthresh, 2);  // threshold is at least 2 MSS
    TEXT[implementation]:       cwnd = cwnd * beta_cubic;     // window reduction

  SECTION: [Fast Convergence](#section-4.6)
    TEXT[!SHOULD,implementation,test]: To speed up this bandwidth release by
    TEXT[!SHOULD,implementation,test]:    existing flows, the following mechanism called "fast convergence"
    TEXT[!SHOULD,implementation,test]:    SHOULD be implemented.
    TEXT[implementation]:    With fast convergence, when a congestion event occurs, before the
    TEXT[implementation]:    window reduction of the congestion window, a flow remembers the last
    TEXT[implementation]:    value of W_max before it updates W_max for the current congestion
    TEXT[implementation]:    event.  Let us call the last value of W_max to be W_last_max.
    TEXT[implementation]:       if (W_max < W_last_max){ // should we make room for others
    TEXT[implementation]:           W_last_max = W_max;             // remember the last W_max
    TEXT[implementation]:           W_max = W_max*(1.0+beta_cubic)/2.0; // further reduce W_max
    TEXT[implementation]:       } else {
    TEXT[implementation]:           W_last_max = W_max              // remember the last W_max
    TEXT[implementation]:    At a congestion event, if the current value of W_max is less than
    TEXT[implementation]:    W_last_max, this indicates that the saturation point experienced by
    TEXT[implementation]:    this flow is getting reduced because of the change in available
    TEXT[implementation]:    bandwidth.  Then we allow this flow to release more bandwidth by
    TEXT[implementation]:    reducing W_max further.  This action effectively lengthens the time
    TEXT[implementation]:    for this flow to increase its congestion window because the reduced
    TEXT[implementation]:    W_max forces the flow to have the plateau earlier.  This allows more
    TEXT[implementation]:    time for the new flow to catch up to its congestion window size.
    TEXT[!SHOULD,exception]: In network environments with only a single
    TEXT[!SHOULD,exception]:    CUBIC flow and without any other traffic, the fast convergence SHOULD
    TEXT[!SHOULD,exception]:    be disabled.

  SECTION: [Slow Start](#section-4.8)
    TEXT[!MUST,implementation,test]:    CUBIC MUST employ a slow-start algorithm, when the cwnd is no more
    TEXT[!MUST,implementation,test]:    than ssthresh.
    TEXT[!MAY,implementation,test]: Among the slow-start algorithms, CUBIC MAY choose the
    TEXT[!MAY,implementation,test]:    standard TCP slow start [RFC5681] in general networks, or the limited
    TEXT[!MAY,implementation,test]:    slow start [RFC3742] or hybrid slow start [HR08] for fast and long-
    TEXT[!MAY,implementation,test]:    distance networks.
    TEXT[implementation]:    In the case when CUBIC runs the hybrid slow start [HR08], it may exit
    TEXT[implementation]:    the first slow start without incurring any packet loss and thus W_max
    TEXT[implementation]:    is undefined.  In this special case, CUBIC switches to congestion
    TEXT[implementation]:    avoidance and increases its congestion window size using Eq. 1, where
    TEXT[implementation]:    t is the elapsed time since the beginning of the current congestion
    TEXT[implementation]:    avoidance, K is set to 0, and W_max is set to the congestion window
    TEXT[implementation]:    size at the beginning of the current congestion avoidance.

  SECTION: [Fairness to Standard TCP](#section-5.1)
    TEXT[implementation]: Based on these observations and our
    TEXT[implementation]:    experiments, we find C=0.4 gives a good balance between TCP-
    TEXT[implementation]:    friendliness and aggressiveness of window increase.
    TEXT[!SHOULD,implementation,test]: Therefore, C
    TEXT[!SHOULD,implementation,test]:    SHOULD be set to 0.4.

  SECTION: [Behavior for Application-Limited Flows](#section-5.8)
    TEXT[implementation]:    CUBIC does not raise its congestion window size if the flow is
    TEXT[implementation]:    currently limited by the application instead of the congestion
    TEXT[implementation]:    window.
    TEXT[implementation,test]: In case of long periods when cwnd has not been updated due
    TEXT[implementation,test]:    to the application rate limit, such as idle periods, t in Eq.
    TEXT[!MUST,implementation,test]: 1 MUST
    TEXT[!MUST,implementation,test]:    NOT include these periods; otherwise, W_cubic(t) might be very high
    TEXT[!MUST,implementation,test]:    after restarting from these periods.

SPECIFICATION: https://www.rfc-editor.org/rfc/rfc8446
  SECTION: [Alert Messages](#appendix-B.2)
    TEXT[implementation]:       enum { warning(1), fatal(2), (255) } AlertLevel;
    TEXT[implementation]:       enum {
    TEXT[implementation]:           close_notify(0),
    TEXT[implementation]:           unexpected_message(10),
    TEXT[implementation]:           bad_record_mac(20),
    TEXT[implementation]:           decryption_failed_RESERVED(21),
    TEXT[implementation]:           record_overflow(22),
    TEXT[implementation]:           decompression_failure_RESERVED(30),
    TEXT[implementation]:           handshake_failure(40),
    TEXT[implementation]:           no_certificate_RESERVED(41),
    TEXT[implementation]:           bad_certificate(42),
    TEXT[implementation]:           unsupported_certificate(43),
    TEXT[implementation]:           certificate_revoked(44),
    TEXT[implementation]:           certificate_expired(45),
    TEXT[implementation]:           certificate_unknown(46),
    TEXT[implementation]:           illegal_parameter(47),
    TEXT[implementation]:           unknown_ca(48),
    TEXT[implementation]:           access_denied(49),
    TEXT[implementation]:           decode_error(50),
    TEXT[implementation]:           decrypt_error(51),
    TEXT[implementation]:           export_restriction_RESERVED(60),
    TEXT[implementation]:           protocol_version(70),
    TEXT[implementation]:           insufficient_security(71),
    TEXT[implementation]:           internal_error(80),
    TEXT[implementation]:           inappropriate_fallback(86),
    TEXT[implementation]:           user_canceled(90),
    TEXT[implementation]:           no_renegotiation_RESERVED(100),
    TEXT[implementation]:           missing_extension(109),
    TEXT[implementation]:           unsupported_extension(110),
    TEXT[implementation]:           certificate_unobtainable_RESERVED(111),
    TEXT[implementation]:           unrecognized_name(112),
    TEXT[implementation]:           bad_certificate_status_response(113),
    TEXT[implementation]:           bad_certificate_hash_value_RESERVED(114),
    TEXT[implementation]:           unknown_psk_identity(115),
    TEXT[implementation]:           certificate_required(116),
    TEXT[implementation]:           no_application_protocol(120),
    TEXT[implementation]:           (255)
    TEXT[implementation]:       } AlertDescription;
    TEXT[implementation]:       struct {
    TEXT[implementation]:           AlertLevel level;
    TEXT[implementation]:           AlertDescription description;
    TEXT[implementation]:       } Alert;

  SECTION: [Cipher Suites](#appendix-B.4)
    TEXT[implementation]:    This specification defines the following cipher suites for use with
    TEXT[implementation]:    TLS 1.3.
    TEXT[implementation]:               +------------------------------+-------------+
    TEXT[implementation]:               | Description                  | Value       |
    TEXT[implementation]:               +------------------------------+-------------+
    TEXT[implementation]:               | TLS_AES_128_GCM_SHA256       | {0x13,0x01} |
    TEXT[implementation]:               |                              |             |
    TEXT[implementation]:               | TLS_AES_256_GCM_SHA384       | {0x13,0x02} |
    TEXT[implementation]:               |                              |             |
    TEXT[implementation]:               | TLS_CHACHA20_POLY1305_SHA256 | {0x13,0x03} |
    TEXT[implementation]:               |                              |             |
    TEXT[implementation]:               | TLS_AES_128_CCM_SHA256       | {0x13,0x04} |
    TEXT[implementation]:               |                              |             |
    TEXT[implementation]:               | TLS_AES_128_CCM_8_SHA256     | {0x13,0x05} |
    TEXT[implementation]:               +------------------------------+-------------+

SPECIFICATION: https://www.rfc-editor.org/rfc/rfc8899
  SECTION: [Path MTU Discovery for Datagram Services](#section-1.3)
    TEXT[!SHOULD,exception]:    The message size guidelines in Section 3.2 of the UDP Usage
    TEXT[!SHOULD,exception]:    Guidelines [BCP145] state that "an application SHOULD either use the
    TEXT[!SHOULD,exception]:    Path MTU information provided by the IP layer or implement Path MTU
    TEXT[!SHOULD,exception]:    Discovery (PMTUD)" but do not provide a mechanism for discovering the
    TEXT[!SHOULD,exception]:    largest size of unfragmented datagram that can be used on a network
    TEXT[!SHOULD,exception]:    path.
    TEXT[!MUST,exception]:    The Datagram Congestion Control Protocol (DCCP) [RFC4340] requires
    TEXT[!MUST,exception]:    implementations to support Classical PMTUD and states that a DCCP
    TEXT[!MUST,exception]:    sender "MUST maintain the MPS allowed for each active DCCP session".

  SECTION: [Terminology](#section-2)
    TEXT[!MUST,exception]: This specification continues the requirement in
    TEXT[!MUST,exception]:       [RFC4821] that states, "All links MUST enforce their MTU: links
    TEXT[!MUST,exception]:       that might non-deterministically deliver packets that are larger
    TEXT[!MUST,exception]:       than their rated MTU MUST consistently discard such packets."
    TEXT[implementation]: The Packetization Layer PMTU is an estimate of the largest
    TEXT[implementation]:       size of PL datagram that can be sent by a path, controlled by
    TEXT[implementation]:       PLPMTUD

  SECTION: [Features Required to Provide Datagram PLPMTUD](#section-3)
    TEXT[!MUST,implementation,test]: A PL MUST NOT send a datagram (other than a probe
    TEXT[!MUST,implementation,test]:        packet) with a size at the PL that is larger than the current
    TEXT[!MUST,implementation,test]:        PLPMTU.
    TEXT[!MUST,exception]: Probe packets: The network interface below the PL is REQUIRED to
    TEXT[!MUST,exception]:        provide a way to transmit a probe packet that is larger than the
    TEXT[!MUST,exception]:        PLPMTU.
    TEXT[!MUST,implementation]: In IPv4, a probe packet MUST be sent with the Don't
    TEXT[!MUST,implementation]:        Fragment (DF) bit set in the IP header and without network layer
    TEXT[!MUST,implementation]:        endpoint fragmentation.
    TEXT[!MUST,exception]: Reception feedback: The destination PL endpoint is REQUIRED to
    TEXT[!MUST,exception]:        provide a feedback method that indicates to the DPLPMTUD sender
    TEXT[!MUST,exception]:        when a probe packet has been received by the destination PL
    TEXT[!MUST,exception]:        endpoint.
    TEXT[!SHOULD,implementation,test]: Probe loss recovery: It is RECOMMENDED to use probe packets that
    TEXT[!SHOULD,implementation,test]:        do not carry any user data that would require retransmission if
    TEXT[!SHOULD,implementation,test]:        lost.
    TEXT[!MUST,exception]: If a probe packet
    TEXT[!MUST,exception]:        contains user data requiring retransmission in case of loss, the
    TEXT[!MUST,exception]:        PL (or layers above) is REQUIRED to arrange any retransmission
    TEXT[!MUST,exception]:        and/or repair of any resulting loss.
    TEXT[!MUST,implementation,test]: The PL is REQUIRED to be
    TEXT[!MUST,implementation,test]:        robust in the case where probe packets are lost due to other
    TEXT[!MUST,implementation,test]:        reasons (including link transmission error, congestion).
    TEXT[!SHOULD]: PMTU parameters: A DPLPMTUD sender is RECOMMENDED to utilize
    TEXT[!SHOULD]:        information about the maximum size of packet that can be
    TEXT[!SHOULD]:        transmitted by the sender on the local link (e.g., the local link
    TEXT[!SHOULD]:        MTU).
    TEXT[!MAY,exception]: A PL sender MAY utilize similar information about the
    TEXT[!MAY,exception]:        maximum size of network-layer packet that a receiver can accept
    TEXT[!MAY,exception]:        when this is supplied (note this could be less than EMTU_R).
    TEXT[!MAY,todo]: Processing PTB messages: A DPLPMTUD sender MAY optionally utilize
    TEXT[!MAY,todo]:        PTB messages received from the network layer to help identify
    TEXT[!MAY,todo]:        when a network path does not support the current size of probe
    TEXT[!MAY,todo]:        packet.
    TEXT[!MUST,todo]: Any received PTB message MUST be validated before it is
    TEXT[!MUST,todo]:        used to update the PLPMTU discovery information [RFC8201].
    TEXT[!MUST,todo]:        PTB message MUST NOT be used to increase the PLPMTU [RFC8201] but
    TEXT[!MUST,todo]:        could trigger a probe to test for a larger PLPMTU.
    TEXT[!SHOULD,todo]: A PL_PTB_SIZE that is greater than
    TEXT[!SHOULD,todo]:        that currently probed SHOULD be ignored.
    TEXT[!MAY]: Probing and congestion control: A PL MAY use a congestion
    TEXT[!MAY]:        controller to decide when to send a probe packet.
    TEXT[!MUST,exception]: When the
    TEXT[!MUST,exception]:        transmission of probe packets is not controlled by the congestion
    TEXT[!MUST,exception]:        controller, the interval between probe packets MUST be at least
    TEXT[!MUST,exception]:        one RTT.
    TEXT[!SHOULD,implementation,test]: Loss of a probe packet SHOULD NOT be treated as an
    TEXT[!SHOULD,implementation,test]:        indication of congestion and SHOULD NOT trigger a congestion
    TEXT[!SHOULD,implementation,test]:        control reaction [RFC4821] because this could result in
    TEXT[!SHOULD,implementation,test]:        unnecessary reduction of the sending rate.
    TEXT[!MUST,exception]: An update to the
    TEXT[!MUST,exception]:        PLPMTU (or MPS) MUST NOT increase the congestion window measured
    TEXT[!MUST,exception]:        in bytes [RFC4821].
    TEXT[!SHOULD,implementation,test]:        A PL that maintains the congestion window in terms of a limit to
    TEXT[!SHOULD,implementation,test]:        the number of outstanding fixed-size packets SHOULD adapt this
    TEXT[!SHOULD,implementation,test]:        limit to compensate for the size of the actual packets.
    TEXT[!SHOULD,exception]: Flow control
    TEXT[!SHOULD,exception]:        SHOULD NOT apply to DPLPMTU when probe packets use a design that
    TEXT[!SHOULD,exception]:        does not carry user data to the remote application.
    TEXT[!MAY,exception]: Shared PLPMTU state: The PMTU value calculated from the PLPMTU
    TEXT[!MAY,exception]:        MAY also be stored with the corresponding entry associated with
    TEXT[!MAY,exception]:        the destination in the IP layer cache and used by other PL
    TEXT[!MAY,exception]:        instances.
    TEXT[!SHOULD]: The specification of PLPMTUD [RFC4821] states, "If
    TEXT[!SHOULD]:        PLPMTUD updates the MTU for a particular path, all Packetization
    TEXT[!SHOULD]:        Layer sessions that share the path representation (as described
    TEXT[!SHOULD]:        in Section 5.2) SHOULD be notified to make use of the new MTU".
    TEXT[!MUST]:        Such methods MUST be robust to the wide variety of underlying
    TEXT[!MUST]:        network forwarding behaviors.
    TEXT[!MAY,exception]:    *  A PL MAY be designed to segment data blocks larger than the MPS
    TEXT[!MAY,exception]:       into multiple datagrams.
    TEXT[!SHOULD,exception]: It is RECOMMENDED that methods avoid
    TEXT[!SHOULD,exception]:       forcing an application to use an arbitrary small MPS for
    TEXT[!SHOULD,exception]:       transmission while the method is searching for the currently
    TEXT[!SHOULD,exception]:       supported PLPMTU.
    TEXT[!SHOULD,exception]:    *  To assist applications in choosing a suitable data block size, the
    TEXT[!SHOULD,exception]:       PL is RECOMMENDED to provide a primitive that returns the MPS
    TEXT[!SHOULD,exception]:       derived from the PLPMTU to the higher layer using the PL.
    TEXT[!SHOULD]:    *  Path validation: It is RECOMMENDED that methods are robust to path
    TEXT[!SHOULD]:       changes that could have occurred since the path characteristics
    TEXT[!SHOULD]:       were last confirmed and to the possibility of inconsistent path
    TEXT[!SHOULD]:       information being received.
    TEXT[!MUST]:    *  Datagram reordering: A method is REQUIRED to be robust to the
    TEXT[!MUST]:       possibility that a flow encounters reordering or that the traffic
    TEXT[!MUST]:       (including probe packets) is divided over more than one network
    TEXT[!MUST]:       path.
    TEXT[!MUST]:    *  Datagram delay and duplication: The feedback mechanism is REQUIRED
    TEXT[!MUST]:       to be robust to the possibility that packets could be
    TEXT[!MUST]:       significantly delayed or duplicated along a network path.
    TEXT[!SHOULD]:    *  When to probe: It is RECOMMENDED that methods determine whether
    TEXT[!SHOULD]:       the path has changed since it last measured the path.

  SECTION: [PLPMTU Probe Packets](#section-4.1)
    TEXT[!MUST,exception]:    A receiver is REQUIRED to be able to distinguish an in-band data
    TEXT[!MUST,exception]:    block from any added padding.
    TEXT[!MAY,implementation,test]:    DPLPMTUD MAY choose to use only one of these methods to simplify the
    TEXT[!MAY,implementation,test]:    implementation.
    TEXT[!MUST,exception]:    Probe messages sent by a PL MUST contain enough information to
    TEXT[!MUST,exception]:    uniquely identify the probe within the Maximum Segment Lifetime
    TEXT[!MUST,exception]:    (e.g., including a unique identifier from the PL or the DPLPMTUD
    TEXT[!MUST,exception]:    implementation), while being robust to reordering and replay of probe
    TEXT[!MUST,exception]:    response and PTB messages.

  SECTION: [Confirmation of Probed Packet Size](#section-4.2)
    TEXT[!MAY,implementation,test]: When
    TEXT[!MAY,implementation,test]:    supported, this mechanism MAY also be used by DPLPMTUD to acknowledge
    TEXT[!MAY,implementation,test]:    reception of a probe packet.

  SECTION: [Black Hole Detection and Reducing the PLPMTU](#section-4.3)
    TEXT[!MUST,todo]: A DPLPMTUD method MUST
    TEXT[!MUST,todo]:       NOT rely solely on this method.
    TEXT[!MAY]:    A PL MAY inhibit sending probe packets when no application data has
    TEXT[!MAY]:    been sent since the previous probe packet.
    TEXT[!MAY]: A PL that resumes sending
    TEXT[!MAY]:    user data MAY continue PLPMTU discovery for each path.

  SECTION: [The Maximum Packet Size (MPS)](#section-4.4)
    TEXT[!MAY,exception]: To avoid
    TEXT[!MAY,exception]:    this, a PL MAY be designed to segment data blocks larger than the MPS
    TEXT[!MAY,exception]:    into multiple datagrams.
    TEXT[!SHOULD,exception]: To determine the largest data block that can be sent,
    TEXT[!SHOULD,exception]:    a PL SHOULD provide applications with a primitive that returns the
    TEXT[!SHOULD,exception]:    MPS, derived from the current PLPMTU.
    TEXT[!MAY,exception]: If these packets are lost, the PL MAY segment
    TEXT[!MAY,exception]:    the data using the new MPS.

  SECTION: [Disabling the Effect of PMTUD](#section-4.5)
    TEXT[!MUST,implementation]:    A PL implementing this specification MUST suspend network layer
    TEXT[!MUST,implementation]:    processing of outgoing packets that enforces a PMTU
    TEXT[!MUST,implementation]:    [RFC1191][RFC8201] for each flow utilizing DPLPMTUD and instead use
    TEXT[!MUST,implementation]:    DPLPMTUD to control the size of packets that are sent by a flow.

  SECTION: [Validation of PTB Messages](#section-4.6.1)
    TEXT[!MAY]:    *  A simple implementation MAY ignore received PTB messages, and in
    TEXT[!MAY]:       this case, the PLPMTU is not updated when a PTB message is
    TEXT[!MAY]:       received.
    TEXT[!MUST,todo]:    *  A PL that supports PTB messages MUST validate these messages
    TEXT[!MUST,todo]:       before they are further processed.
    TEXT[!MUST,todo]:    The PL MUST check the protocol information in the quoted packet
    TEXT[!MUST,todo]:    carried in an ICMP PTB message payload to validate the message
    TEXT[!MUST,todo]:    originated from the sending node.
    TEXT[!SHOULD,todo]:    The validation SHOULD utilize information that is not simple for an
    TEXT[!SHOULD,todo]:    off-path attacker to determine [BCP145].
    TEXT[!MUST,todo]: A PTB message
    TEXT[!MUST,todo]:    that does not complete the validation MUST NOT be further utilized by
    TEXT[!MUST,todo]:    the DPLPMTUD method, as discussed in the Security Considerations
    TEXT[!MUST,todo]:    section (Section 8).

  SECTION: [Use of PTB Messages](#section-4.6.2)
    TEXT[!MUST,todo]:    PTB messages that have been validated MAY be utilized by the DPLPMTUD
    TEXT[!MUST,todo]:    algorithm but MUST NOT be used directly to set the PLPMTU.
    TEXT[!MAY,todo]:    MIN_PLPMTU < PL_PTB_SIZE < BASE_PLPMTU
    TEXT[!MAY,todo]:       *  A robust PL MAY enter an error state (see Section 5.2) for an
    TEXT[!MAY,todo]:          IPv4 path when the PL_PTB_SIZE reported in the PTB message is
    TEXT[!MAY,todo]:          larger than or equal to 68 bytes [RFC0791] and when this is
    TEXT[!MAY,todo]:          less than the BASE_PLPMTU.
    TEXT[!MAY,todo]:       *  A robust PL MAY enter an error state (see Section 5.2) for an
    TEXT[!MAY,todo]:          IPv6 path when the PL_PTB_SIZE reported in the PTB message is
    TEXT[!MAY,todo]:          larger than or equal to 1280 bytes [RFC8200] and when this is
    TEXT[!MAY,todo]:          less than the BASE_PLPMTU.
    TEXT[!SHOULD,todo]: The PLPMTU SHOULD
    TEXT[!SHOULD,todo]:          be set to BASE_PLPMTU (the PLPMTU is reduced to the BASE_PLPMTU
    TEXT[!SHOULD,todo]:          to avoid unnecessary packet loss when a black hole is
    TEXT[!SHOULD,todo]:          encountered).

  SECTION: [Datagram Packetization Layer PMTUD](#section-5)
    TEXT[!SHOULD]:    DPLPMTUD SHOULD only be performed at one layer between a pair of
    TEXT[!SHOULD]:    endpoints.
    TEXT[!MUST]: A PL MUST
    TEXT[!MUST]:    adjust the MPS indicated by DPLPMTUD to account for any additional
    TEXT[!MUST]:    overhead introduced by the PL.

  SECTION: [Timers](#section-5.1.1)
    TEXT[!MUST,exception]: This value MUST NOT be smaller than 1 second and
    TEXT[!MUST,exception]:       SHOULD be larger than 15 seconds.
    TEXT[implementation]: The PMTU_RAISE_TIMER is configured to the period a
    TEXT[implementation]:       sender will continue to use the current PLPMTU, after which it
    TEXT[implementation]:       reenters the Search Phase.  This timer has a period of 600
    TEXT[implementation]:       seconds, as recommended by PLPMTUD [RFC4821].
    TEXT[!MAY]:       DPLPMTUD MAY inhibit sending probe packets when no application
    TEXT[!MAY]:       data has been sent since the previous probe packet.
    TEXT[!MUST,exception]:    CONFIRMATION_TIMER:  When an acknowledged PL is used, this timer MUST
    TEXT[!MUST,exception]:       NOT be used.

  SECTION: [Constants](#section-5.1.2)
    TEXT[implementation]: The MAX_PROBES is the maximum value of the PROBE_COUNT
    TEXT[implementation]:       counter (see Section 5.1.3).  MAX_PROBES represents the limit for
    TEXT[implementation]:       the number of consecutive probe attempts of any size.  Search
    TEXT[implementation]:       algorithms benefit from a MAX_PROBES value greater than 1 because
    TEXT[implementation]:       this can provide robustness to isolated packet loss.  The default
    TEXT[implementation]:       value of MAX_PROBES is 3.
    TEXT[!MAY]: An application, or PL, MAY
    TEXT[!MAY]:       choose a smaller MAX_PLPMTU when there is no need to send packets
    TEXT[!MAY]:       larger than a specific size.
    TEXT[implementation]: The BASE_PLPMTU is a configured size expected to work
    TEXT[implementation]:       for most paths.  The size is equal to or larger than the
    TEXT[implementation]:       MIN_PLPMTU and smaller than the MAX_PLPMTU.
    TEXT[!SHOULD,implementation,test]: When using
    TEXT[!SHOULD,implementation,test]:       IPv4, there is no currently equivalent size specified, and a
    TEXT[!SHOULD,implementation,test]:       default BASE_PLPMTU of 1200 bytes is RECOMMENDED.

  SECTION: [Variables](#section-5.1.3)
    TEXT[implementation]: The PROBED_SIZE is the size of the current probe packet
    TEXT[implementation]:       as determined at the PL.  This is a tentative value for the
    TEXT[implementation]:       PLPMTU, which is awaiting confirmation by an acknowledgment.
    TEXT[implementation]: The PROBE_COUNT is a count of the number of successive
    TEXT[implementation]:       unsuccessful probe packets that have been sent.

  SECTION: [State Machine](#section-5.2)
    TEXT[implementation]: The DISABLED state is the initial state before probing has
    TEXT[implementation]:       started.
    TEXT[implementation]: The SEARCHING state is the main probing state.
    TEXT[implementation]: The SEARCH_COMPLETE state indicates that a search
    TEXT[implementation]:       has completed.
    TEXT[!SHOULD,implementation,test]: When used with an
    TEXT[!SHOULD,implementation,test]:       acknowledged PL (e.g., SCTP), DPLPMTUD SHOULD NOT continue to
    TEXT[!SHOULD,implementation,test]:       generate PLPMTU probes in this state.

  SECTION: [Probing for a Larger PLPMTU](#section-5.3.1)
    TEXT[!MAY,exception]: The
    TEXT[!MAY,exception]:    MAX_PLPMTU MAY be reduced by an application that sets a maximum to
    TEXT[!MAY,exception]:    the size of datagrams it will send.

  SECTION: [Selection of Probe Sizes](#section-5.3.2)
    TEXT[!SHOULD,implementation,test]:    Implementations SHOULD select the set of probe packet sizes to
    TEXT[!SHOULD,implementation,test]:    maximize the gain in PLPMTU from each search step.

  SECTION: [Application Support for DPLPMTUD with UDP or UDP-Lite](#section-6.1)
    TEXT[!SHOULD,exception]: An application SHOULD avoid using
    TEXT[!SHOULD,exception]:    DPLPMTUD when the underlying transport system provides this
    TEXT[!SHOULD,exception]:    capability.

  SECTION: [Application Request](#section-6.1.1)
    TEXT[!SHOULD,exception]: The method SHOULD allow the sender to check
    TEXT[!SHOULD,exception]:    the value returned in the response to provide additional protection
    TEXT[!SHOULD,exception]:    from off-path insertion of data [BCP145].

  SECTION: [Initial Connectivity](#section-6.1.4)
    TEXT[!SHOULD,exception]:    An application that does not have other higher-layer information
    TEXT[!SHOULD,exception]:    confirming connectivity with the remote peer SHOULD implement a
    TEXT[!SHOULD,exception]:    connectivity mechanism using acknowledged probe packets before
    TEXT[!SHOULD,exception]:    entering the BASE state.

  SECTION: [Validating the Path](#section-6.1.5)
    TEXT[!SHOULD,exception]:    An application that does not have other higher-layer information
    TEXT[!SHOULD,exception]:    confirming correct delivery of datagrams SHOULD implement the
    TEXT[!SHOULD,exception]:    CONFIRMATION_TIMER to periodically send probe packets while in the
    TEXT[!SHOULD,exception]:    SEARCH_COMPLETE state.

  SECTION: [Handling of PTB Messages](#section-6.1.6)
    TEXT[!MUST,exception]:    An application that is able and wishes to receive PTB messages MUST
    TEXT[!MUST,exception]:    perform ICMP validation as specified in Section 5.2 of [BCP145].
    TEXT[!MUST,exception]: A validated PTB message MAY be used
    TEXT[!MUST,exception]:    as input to the DPLPMTUD algorithm but MUST NOT be used directly to
    TEXT[!MUST,exception]:    set the PLPMTU.

  SECTION: [DPLPMTUD for SCTP](#section-6.2)
    TEXT[!SHOULD,exception]:    The specification for DPLPMTUD continues the practice of using the PL
    TEXT[!SHOULD,exception]:    to discover the PMTU but updates RFC4960 with a recommendation to use
    TEXT[!SHOULD,exception]:    the method specified in this document: The RECOMMENDED method for
    TEXT[!SHOULD,exception]:    generating probes is to add a chunk consisting only of padding to an
    TEXT[!SHOULD,exception]:    SCTP message.
    TEXT[!SHOULD,exception]: The PAD chunk defined in [RFC4820] SHOULD be attached
    TEXT[!SHOULD,exception]:    to a minimum-length HEARTBEAT (HB) chunk to build a probe packet.

  SECTION: [Validating the Path with SCTP](#section-6.2.1.3)
    TEXT[!MUST,exception]:    Since SCTP provides an acknowledged PL, a sender MUST NOT implement
    TEXT[!MUST,exception]:    the CONFIRMATION_TIMER while in the SEARCH_COMPLETE state.

  SECTION: [PTB Message Handling by SCTP](#section-6.2.1.4)
    TEXT[!MUST,exception]:    Normal ICMP validation MUST be performed as specified in Appendix C
    TEXT[!MUST,exception]:    of [RFC4960].
    TEXT[!SHOULD,exception]:    When a PTB message has been validated, the PL_PTB_SIZE calculated
    TEXT[!SHOULD,exception]:    from the PTB_SIZE reported in the PTB message SHOULD be used with the
    TEXT[!SHOULD,exception]:    DPLPMTUD algorithm, provided that the reported PL_PTB_SIZE is less
    TEXT[!SHOULD,exception]:    than the current probe size (see Section 4.6).

  SECTION: [DPLPMTUD for SCTP/UDP](#section-6.2.2)
    TEXT[!SHOULD,exception]:    |  The RECOMMENDED method for determining the MTU of the path is
    TEXT[!SHOULD,exception]:    |  specified in RFC 8899.

  SECTION: [Handling of PTB Messages by SCTP/UDP](#section-6.2.2.4)
    TEXT[!MUST,exception]:    ICMP validation MUST be performed for PTB messages as specified in
    TEXT[!MUST,exception]:    Appendix C of [RFC4960].
    TEXT[!SHOULD,exception]: When the
    TEXT[!SHOULD,exception]:    validation is completed, the PL_PTB_SIZE calculated from the PTB_SIZE
    TEXT[!SHOULD,exception]:    in the PTB message SHOULD be used with the DPLPMTUD providing that
    TEXT[!SHOULD,exception]:    the reported PL_PTB_SIZE is less than the current probe size.

  SECTION: [Validating the Path with SCTP/DTLS](#section-6.2.3.3)
    TEXT[!MUST,exception]:    Since SCTP provides an acknowledged PL, a sender MUST NOT implement
    TEXT[!MUST,exception]:    the CONFIRMATION_TIMER while in the SEARCH_COMPLETE state.

  SECTION: [Security Considerations](#section-8)
    TEXT[!MUST,implementation,test]:    To avoid excessive load, the interval between individual probe
    TEXT[!MUST,implementation,test]:    packets MUST be at least one RTT, and the interval between rounds of
    TEXT[!MUST,implementation,test]:    probing is determined by the PMTU_RAISE_TIMER.
    TEXT[!MUST,todo]: A node supporting DPLPMTUD
    TEXT[!MUST,todo]:    MUST therefore appropriately validate the payload of PTB messages to
    TEXT[!MUST,todo]:    ensure these are received in response to transmitted traffic (i.e., a
    TEXT[!MUST,todo]:    reported error condition that corresponds to a datagram actually sent
    TEXT[!MUST,todo]:    by the path layer, see Section 4.6.1).
    TEXT[!SHOULD,todo]: This processing
    TEXT[!SHOULD,todo]:    SHOULD be limited to avoid a denial-of-service attack when arbitrary
    TEXT[!SHOULD,todo]:    headers are included.
    TEXT[!SHOULD]: The
    TEXT[!SHOULD]:    design of a PLPMTUD implementation SHOULD consider how to mitigate
    TEXT[!SHOULD]:    the effects of varying path information.

SPECIFICATION: https://www.rfc-editor.org/rfc/rfc9000
  SECTION: [Stream Types and Identifiers](#section-2.1)
    TEXT[!MUST,implementation]: A QUIC
    TEXT[!MUST,implementation]:    endpoint MUST NOT reuse a stream ID within a connection.
    TEXT[implementation]:    The least significant bit (0x01) of the stream ID identifies the
    TEXT[implementation]:    initiator of the stream.  Client-initiated streams have even-numbered
    TEXT[implementation]:    stream IDs (with the bit set to 0)
    TEXT[implementation]:    The second least significant bit (0x02) of the stream ID
    TEXT[implementation]:    distinguishes between bidirectional streams (with the bit set to 0)
    TEXT[implementation]:    and unidirectional streams (with the bit set to 1).
    TEXT[implementation]:    The two least significant bits from a stream ID therefore identify a
    TEXT[implementation]:    stream as one of four types, as summarized in Table 1.
    TEXT[implementation]:                 +======+==================================+
    TEXT[implementation]:                 | Bits | Stream Type                      |
    TEXT[implementation]:                 +======+==================================+
    TEXT[implementation]:                 | 0x00 | Client-Initiated, Bidirectional  |
    TEXT[implementation]:                 +------+----------------------------------+
    TEXT[implementation]:                 | 0x01 | Server-Initiated, Bidirectional  |
    TEXT[implementation]:                 +------+----------------------------------+
    TEXT[implementation]:                 | 0x02 | Client-Initiated, Unidirectional |
    TEXT[implementation]:                 +------+----------------------------------+
    TEXT[implementation]:                 | 0x03 | Server-Initiated, Unidirectional |
    TEXT[implementation]:                 +------+----------------------------------+

  SECTION: [Sending and Receiving Data](#section-2.2)
    TEXT[!MUST,implementation]:    Endpoints MUST be able to deliver stream data to an application as an
    TEXT[!MUST,implementation]:    ordered byte stream.
    TEXT[!MAY,exception]: However, implementations MAY choose to offer the ability to
    TEXT[!MAY,exception]:    deliver data out of order to a receiving application.
    TEXT[!MUST]: The data at a given offset MUST NOT change if it is sent
    TEXT[!MUST]:    multiple times
    TEXT[!MUST,exception]: ; an endpoint MAY treat receipt of different data at
    TEXT[!MUST,exception]:    the same offset within a stream as a connection error of type
    TEXT[!MUST,exception]:    PROTOCOL_VIOLATION.
    TEXT[!MUST,implementation]:    An endpoint MUST NOT send data on any stream without ensuring that it
    TEXT[!MUST,implementation]:    is within the flow control limits set by its peer.

  SECTION: [Stream Prioritization](#section-2.3)
    TEXT[!SHOULD,todo]:    A QUIC implementation SHOULD provide ways in which an application can
    TEXT[!SHOULD,todo]:    indicate the relative priority of streams.

  SECTION: [Sending Stream States](#section-3.1)
    TEXT[implementation]:           | Create Stream (Sending)
    TEXT[implementation]:           | Peer Creates Bidirectional Stream
    TEXT[implementation]:       +-------+
    TEXT[implementation]:       | Ready | Send RESET_STREAM
    TEXT[implementation]:       |       |-----------------------.
    TEXT[implementation]:       +-------+                       |
    TEXT[implementation]:           |                           |
    TEXT[implementation]:           | Send STREAM /             |
    TEXT[implementation]:           |      STREAM_DATA_BLOCKED  |
    TEXT[implementation]:           v                           |
    TEXT[implementation]:       +-------+                       |
    TEXT[implementation]:       | Send  | Send RESET_STREAM     |
    TEXT[implementation]:       |       |---------------------->|
    TEXT[implementation]:       +-------+                       |
    TEXT[implementation]:           |                           |
    TEXT[implementation]:           | Send STREAM + FIN         |
    TEXT[implementation]:           v                           v
    TEXT[implementation]:       +-------+                   +-------+
    TEXT[implementation]:       | Data  | Send RESET_STREAM | Reset |
    TEXT[implementation]:       | Sent  |------------------>| Sent  |
    TEXT[implementation]:       +-------+                   +-------+
    TEXT[implementation]:           |                           |
    TEXT[implementation]:           | Recv All ACKs             | Recv ACK
    TEXT[implementation]:           v                           v
    TEXT[implementation]:       +-------+                   +-------+
    TEXT[implementation]:       | Data  |                   | Reset |
    TEXT[implementation]:       | Recvd |                   | Recvd |
    TEXT[implementation]:       +-------+                   +-------+
    TEXT[!MAY,implementation]:    An endpoint MAY send a RESET_STREAM as the first frame that mentions
    TEXT[!MAY,implementation]:    a stream; this causes the sending part of that stream to open and
    TEXT[!MAY,implementation]:    then immediately transition to the "Reset Sent" state.

  SECTION: [Receiving Stream States](#section-3.2)
    TEXT[implementation]:           | Recv STREAM / STREAM_DATA_BLOCKED / RESET_STREAM
    TEXT[implementation]:           | Create Bidirectional Stream (Sending)
    TEXT[implementation]:           | Recv MAX_STREAM_DATA / STOP_SENDING (Bidirectional)
    TEXT[implementation]:           | Create Higher-Numbered Stream
    TEXT[implementation]:       +-------+
    TEXT[implementation]:       | Recv  | Recv RESET_STREAM
    TEXT[implementation]:       |       |-----------------------.
    TEXT[implementation]:       +-------+                       |
    TEXT[implementation]:           |                           |
    TEXT[implementation]:           | Recv STREAM + FIN         |
    TEXT[implementation]:           v                           |
    TEXT[implementation]:       +-------+                       |
    TEXT[implementation]:       | Size  | Recv RESET_STREAM     |
    TEXT[implementation]:       | Known |---------------------->|
    TEXT[implementation]:       +-------+                       |
    TEXT[implementation]:           |                           |
    TEXT[implementation]:           | Recv All Data             |
    TEXT[implementation]:           v                           v
    TEXT[implementation]:       +-------+ Recv RESET_STREAM +-------+
    TEXT[implementation]:       | Data  |--- (optional) --->| Reset |
    TEXT[implementation]:       | Recvd |  Recv All Data    | Recvd |
    TEXT[implementation]:       +-------+<-- (optional) ----+-------+
    TEXT[implementation]:           |                           |
    TEXT[implementation]:           | App Read All Data         | App Read Reset
    TEXT[implementation]:           v                           v
    TEXT[implementation]:       +-------+                   +-------+
    TEXT[implementation]:       | Data  |                   | Reset |
    TEXT[implementation]:       | Read  |                   | Read  |
    TEXT[implementation]:       +-------+                   +-------+
    TEXT[!MUST,implementation]:    Before a stream is created, all streams of the same type with lower-
    TEXT[!MUST,implementation]:    numbered stream IDs MUST be created.
    TEXT[implementation]:   This ensures that the creation
    TEXT[implementation]:    order for streams is consistent on both endpoints.
    TEXT[implementation]:    When a STREAM frame with a FIN bit is received, the final size of the
    TEXT[implementation]:    stream is known; see Section 4.5.  The receiving part of the stream
    TEXT[implementation]:    then enters the "Size Known" state.  In this state, the endpoint no
    TEXT[implementation]:    longer needs to send MAX_STREAM_DATA frames; it only receives any
    TEXT[implementation]:    retransmissions of stream data.
    TEXT[!MAY,implementation]: An
    TEXT[!MAY,implementation]:    implementation MAY interrupt delivery of stream data, discard any
    TEXT[!MAY,implementation]:    data that was not consumed, and signal the receipt of the
    TEXT[!MAY,implementation]:    RESET_STREAM.

  SECTION: [Permitted Frame Types](#section-3.3)
    TEXT[!MUST,implementation]:    A sender MUST NOT send any of these frames from a terminal state
    TEXT[!MUST,implementation]:    ("Data Recvd" or "Reset Recvd").
    TEXT[!MUST,implementation]: A sender MUST NOT send a STREAM or
    TEXT[!MUST,implementation]:    STREAM_DATA_BLOCKED frame for a stream in the "Reset Sent" state or
    TEXT[!MUST,implementation]:    any terminal state -- that is, after sending a RESET_STREAM frame.
    TEXT[!MAY,implementation]:    A receiver MAY send a STOP_SENDING frame in any state where it has
    TEXT[!MAY,implementation]:    not received a RESET_STREAM frame -- that is, states other than
    TEXT[!MAY,implementation]:    "Reset Recvd" or "Reset Read".

  SECTION: [Solicited State Transitions](#section-3.5)
    TEXT[!SHOULD,implementation]:    If the stream is in the "Recv" or "Size Known" state, the transport
    TEXT[!SHOULD,implementation]:    SHOULD signal this by sending a STOP_SENDING frame to prompt closure
    TEXT[!SHOULD,implementation]:    of the stream in the opposite direction.
    TEXT[implementation]:    A STOP_SENDING frame requests that the receiving endpoint send a
    TEXT[implementation]:    RESET_STREAM frame.
    TEXT[!MUST,implementation]: An endpoint that receives a STOP_SENDING frame
    TEXT[!MUST,implementation]:    MUST send a RESET_STREAM frame if the stream is in the "Ready" or
    TEXT[!MUST,implementation]:    "Send" state.
    TEXT[!MAY,implementation]: If the stream is in the "Data Sent" state, the
    TEXT[!MAY,implementation]:    endpoint MAY defer sending the RESET_STREAM frame until the packets
    TEXT[!MAY,implementation]:    containing outstanding data are acknowledged or declared lost.
    TEXT[!SHOULD,implementation]: If
    TEXT[!SHOULD,implementation]:    any outstanding data is declared lost, the endpoint SHOULD send a
    TEXT[!SHOULD,implementation]:    RESET_STREAM frame instead of retransmitting the data.
    TEXT[!SHOULD,implementation]:    An endpoint SHOULD copy the error code from the STOP_SENDING frame to
    TEXT[!SHOULD,implementation]:    the RESET_STREAM frame it sends, but it can use any application error
    TEXT[!SHOULD,implementation]:    code.
    TEXT[!MAY,exception]: An endpoint that sends a STOP_SENDING frame MAY ignore the
    TEXT[!MAY,exception]:    error code in any RESET_STREAM frames subsequently received for that
    TEXT[!MAY,exception]:    stream.
    TEXT[!SHOULD,implementation]:    STOP_SENDING SHOULD only be sent for a stream that has not been reset
    TEXT[!SHOULD,implementation]:    by the peer.

  SECTION: [Flow Control](#section-4)
    TEXT[!SHOULD,todo]:    To avoid excessive buffering at multiple layers, QUIC implementations
    TEXT[!SHOULD,todo]:    SHOULD provide an interface for the cryptographic protocol
    TEXT[!SHOULD,todo]:    implementation to communicate its buffering limits.

  SECTION: [Data Flow Control](#section-4.1)
    TEXT[!MUST,implementation]:    Senders MUST NOT send data in excess of either limit.
    TEXT[!MUST,implementation]:    A receiver MUST close the connection with an error of type
    TEXT[!MUST,implementation]:    FLOW_CONTROL_ERROR if the sender violates the advertised connection
    TEXT[!MUST,implementation]:    or stream data limits; see Section 11 for details on error handling.
    TEXT[!MUST,implementation,test]:    A sender MUST ignore any MAX_STREAM_DATA or MAX_DATA frames that do
    TEXT[!MUST,implementation,test]:    not increase flow control limits.
    TEXT[!SHOULD,implementation,test]: A sender SHOULD send a
    TEXT[!SHOULD,implementation,test]:    STREAM_DATA_BLOCKED or DATA_BLOCKED frame to indicate to the receiver
    TEXT[!SHOULD,implementation,test]:    that it has data to write but is blocked by flow control limits.
    TEXT[!SHOULD,implementation,test]: To keep the
    TEXT[!SHOULD,implementation,test]:    connection from closing, a sender that is flow control limited SHOULD
    TEXT[!SHOULD,implementation,test]:    periodically send a STREAM_DATA_BLOCKED or DATA_BLOCKED frame when it
    TEXT[!SHOULD,implementation,test]:    has no ack-eliciting packets in flight.

  SECTION: [Increasing Flow Control Limits](#section-4.2)
    TEXT[!MAY,todo]:    To avoid blocking a sender, a receiver MAY send a MAX_STREAM_DATA or
    TEXT[!MAY,todo]:    MAX_DATA frame multiple times within a round trip or send it early
    TEXT[!MAY,todo]:    enough to allow time for loss of the frame and subsequent recovery.
    TEXT[!MUST,implementation]: Therefore, a receiver MUST NOT wait for a
    TEXT[!MUST,implementation]:    STREAM_DATA_BLOCKED or DATA_BLOCKED frame before sending a
    TEXT[!MUST,implementation]:    MAX_STREAM_DATA or MAX_DATA frame; doing so could result in the
    TEXT[!MUST,implementation]:    sender being blocked for the rest of the connection.

  SECTION: [Handling Stream Cancellation](#section-4.4)
    TEXT[!MUST,implementation]: Both endpoints MUST maintain flow control state
    TEXT[!MUST,implementation]:    for the stream in the unterminated direction until that direction
    TEXT[!MUST,implementation]:    enters a terminal state.

  SECTION: [Stream Final Size](#section-4.5)
    TEXT[!MUST,implementation]: The receiver MUST use the final size of the stream to
    TEXT[!MUST,implementation]:    account for all bytes sent on the stream in its connection-level flow
    TEXT[!MUST,implementation]:    controller.
    TEXT[!MUST,implementation]:    An endpoint MUST NOT send data on a stream at or beyond the final
    TEXT[!MUST,implementation]:    size.
    TEXT[implementation]:    Once a final size for a stream is known, it cannot change.
    TEXT[!SHOULD,implementation]: If a
    TEXT[!SHOULD,implementation]:    RESET_STREAM or STREAM frame is received indicating a change in the
    TEXT[!SHOULD,implementation]:    final size for the stream, an endpoint SHOULD respond with an error
    TEXT[!SHOULD,implementation]:    of type FINAL_SIZE_ERROR; see Section 11 for details on error
    TEXT[!SHOULD,implementation]:    handling.
    TEXT[!SHOULD,implementation]: A receiver SHOULD treat receipt of data at or beyond the
    TEXT[!SHOULD,implementation]:    final size as an error of type FINAL_SIZE_ERROR, even after a stream
    TEXT[!SHOULD,implementation]:    is closed.

  SECTION: [Controlling Concurrency](#section-4.6)
    TEXT[implementation]:    If a max_streams transport parameter or a MAX_STREAMS frame is
    TEXT[implementation]:    received with a value greater than 2^60, this would allow a maximum
    TEXT[implementation]:    stream ID that cannot be expressed as a variable-length integer; see
    TEXT[implementation]:    Section 16.
    TEXT[!MUST,implementation]: If either is received, the connection MUST be closed
    TEXT[!MUST,implementation]:    immediately with a connection error of type TRANSPORT_PARAMETER_ERROR
    TEXT[!MUST,implementation]:    if the offending value was received in a transport parameter or of
    TEXT[!MUST,implementation]:    type FRAME_ENCODING_ERROR if it was received in a frame; see
    TEXT[!MUST,implementation]:    Section 10.2.
    TEXT[!MUST,implementation,test]:    Endpoints MUST NOT exceed the limit set by their peer.
    TEXT[!MUST,implementation,test]: An endpoint
    TEXT[!MUST,implementation,test]:    that receives a frame with a stream ID exceeding the limit it has
    TEXT[!MUST,implementation,test]:    sent MUST treat this as a connection error of type
    TEXT[!MUST,implementation,test]:    STREAM_LIMIT_ERROR; see Section 11 for details on error handling.
    TEXT[!MUST,implementation,test]: MAX_STREAMS frames
    TEXT[!MUST,implementation,test]:    that do not increase the stream limit MUST be ignored.
    TEXT[!SHOULD,implementation,test]:    An endpoint that is unable to open a new stream due to the peer's
    TEXT[!SHOULD,implementation,test]:    limits SHOULD send a STREAMS_BLOCKED frame (Section 19.14).
    TEXT[!MUST,implementation,test]: An endpoint MUST NOT wait
    TEXT[!MUST,implementation,test]:    to receive this signal before advertising additional credit, since
    TEXT[!MUST,implementation,test]:    doing so will mean that the peer will be blocked for at least an
    TEXT[!MUST,implementation,test]:    entire round trip
    TEXT[!MUST]: , and potentially indefinitely if the peer chooses
    TEXT[!MUST]:    not to send STREAMS_BLOCKED frames.

  SECTION: [Connection ID](#section-5.1)
    TEXT[implementation]:    Each connection possesses a set of connection identifiers, or
    TEXT[implementation]:    connection IDs, each of which can identify the connection.
    TEXT[implementation]:    Connection IDs are independently selected by endpoints; each endpoint
    TEXT[implementation]:    selects the connection IDs that its peer uses.
    TEXT[!MUST,exception]:    Connection IDs MUST NOT contain any information that can be used by
    TEXT[!MUST,exception]:    an external observer (that is, one that does not cooperate with the
    TEXT[!MUST,exception]:    issuer) to correlate them with other connection IDs for the same
    TEXT[!MUST,exception]:    connection.
    TEXT[!MUST,implementation,test]: As a trivial example, this means the same connection ID
    TEXT[!MUST,implementation,test]:    MUST NOT be issued more than once on the same connection.
    TEXT[!MUST,exception]: An
    TEXT[!MUST,exception]:    endpoint MUST NOT use the same IP address and port for multiple
    TEXT[!MUST,exception]:    concurrent connections with zero-length connection IDs, unless it is
    TEXT[!MUST,exception]:    certain that those protocol features are not in use.

  SECTION: [Issuing Connection IDs](#section-5.1.1)
    TEXT[implementation]:    Each connection ID has an associated sequence number to assist in
    TEXT[implementation]:    detecting when NEW_CONNECTION_ID or RETIRE_CONNECTION_ID frames refer
    TEXT[implementation]:    to the same value.
    TEXT[implementation]: The sequence number of the
    TEXT[implementation]:    initial connection ID is 0.
    TEXT[!MUST,implementation,test]: The sequence number on
    TEXT[!MUST,implementation,test]:    each newly issued connection ID MUST increase by 1.
    TEXT[!MUST,implementation,test]:    When an endpoint issues a connection ID, it MUST accept packets that
    TEXT[!MUST,implementation,test]:    carry this connection ID for the duration of the connection or until
    TEXT[!MUST,implementation,test]:    its peer invalidates the connection ID via a RETIRE_CONNECTION_ID
    TEXT[!MUST,implementation,test]:    frame (Section 19.16).
    TEXT[!SHOULD,implementation,test]:    An endpoint SHOULD ensure that its peer has a sufficient number of
    TEXT[!SHOULD,implementation,test]:    available and unused connection IDs.
    TEXT[!MUST,implementation,test]: An endpoint MUST NOT
    TEXT[!MUST,implementation,test]:    provide more connection IDs than the peer's limit.
    TEXT[!MAY,implementation,test]: An endpoint MAY
    TEXT[!MAY,implementation,test]:    send connection IDs that temporarily exceed a peer's limit if the
    TEXT[!MAY,implementation,test]:    NEW_CONNECTION_ID frame also requires the retirement of any excess,
    TEXT[!MAY,implementation,test]:    by including a sufficiently large value in the Retire Prior To field.
    TEXT[!MUST,implementation,test]: After processing a NEW_CONNECTION_ID frame and
    TEXT[!MUST,implementation,test]:    adding and retiring active connection IDs, if the number of active
    TEXT[!MUST,implementation,test]:    connection IDs exceeds the value advertised in its
    TEXT[!MUST,implementation,test]:    active_connection_id_limit transport parameter, an endpoint MUST
    TEXT[!MUST,implementation,test]:    close the connection with an error of type CONNECTION_ID_LIMIT_ERROR.
    TEXT[!SHOULD,implementation,test]:    An endpoint SHOULD supply a new connection ID when the peer retires a
    TEXT[!SHOULD,implementation,test]:    connection ID.
    TEXT[!MAY,exception]: If an endpoint provided fewer connection IDs than the
    TEXT[!MAY,exception]:    peer's active_connection_id_limit, it MAY supply a new connection ID
    TEXT[!MAY,exception]:    when it receives a packet with a previously unused connection ID.
    TEXT[!MAY,exception]: An
    TEXT[!MAY,exception]:    endpoint MAY limit the total number of connection IDs issued for each
    TEXT[!MAY,exception]:    connection to avoid the risk of running out of connection IDs; see
    TEXT[!MAY,exception]:    Section 10.3.2.
    TEXT[!MAY,implementation,test]: An endpoint MAY also limit the issuance of
    TEXT[!MAY,implementation,test]:    connection IDs to reduce the amount of per-path state it maintains,
    TEXT[!MAY,implementation,test]:    such as path validation status, as its peer might interact with it
    TEXT[!MAY,implementation,test]:    over as many paths as there are issued connection IDs.
    TEXT[!SHOULD,implementation,test]:    An endpoint that initiates migration and requires non-zero-length
    TEXT[!SHOULD,implementation,test]:    connection IDs SHOULD ensure that the pool of connection IDs
    TEXT[!SHOULD,implementation,test]:    available to its peer allows the peer to use a new connection ID on
    TEXT[!SHOULD,implementation,test]:    migration, as the peer will be unable to respond if the pool is
    TEXT[!SHOULD,implementation,test]:    exhausted.

  SECTION: [Consuming and Retiring Connection IDs](#section-5.1.2)
    TEXT[!SHOULD,todo]: Endpoints SHOULD retire connection IDs when
    TEXT[!SHOULD,todo]:    they are no longer actively using either the local or destination
    TEXT[!SHOULD,todo]:    address for which the connection ID was used.
    TEXT[!SHOULD,implementation,test]: The endpoint SHOULD continue to
    TEXT[!SHOULD,implementation,test]:    accept the previously issued connection IDs until they are retired by
    TEXT[!SHOULD,implementation,test]:    the peer.
    TEXT[!MAY,exception]: If the endpoint can no longer process the indicated
    TEXT[!MAY,exception]:    connection IDs, it MAY close the connection.
    TEXT[!MUST,implementation,test]:    Upon receipt of an increased Retire Prior To field, the peer MUST
    TEXT[!MUST,implementation,test]:    stop using the corresponding connection IDs and retire them with
    TEXT[!MUST,implementation,test]:    RETIRE_CONNECTION_ID frames before adding the newly provided
    TEXT[!MUST,implementation,test]:    connection ID to the set of active connection IDs.
    TEXT[!SHOULD,implementation,test]:    An endpoint SHOULD limit the number of connection IDs it has retired
    TEXT[!SHOULD,implementation,test]:    locally for which RETIRE_CONNECTION_ID frames have not yet been
    TEXT[!SHOULD,implementation,test]:    acknowledged.
    TEXT[!SHOULD,implementation,test]: An endpoint SHOULD allow for sending and tracking a
    TEXT[!SHOULD,implementation,test]:    number of RETIRE_CONNECTION_ID frames of at least twice the value of
    TEXT[!SHOULD,implementation,test]:    the active_connection_id_limit transport parameter.
    TEXT[!MUST,implementation,test]: An endpoint MUST
    TEXT[!MUST,implementation,test]:    NOT forget a connection ID without retiring it, though it MAY choose
    TEXT[!MUST,implementation,test]:    to treat having connection IDs in need of retirement that exceed this
    TEXT[!MUST,implementation,test]:    limit as a connection error of type CONNECTION_ID_LIMIT_ERROR.
    TEXT[!SHOULD,todo]:    Endpoints SHOULD NOT issue updates of the Retire Prior To field
    TEXT[!SHOULD,todo]:    before receiving RETIRE_CONNECTION_ID frames that retire all
    TEXT[!SHOULD,todo]:    connection IDs indicated by the previous Retire Prior To value.

  SECTION: [Matching Packets to Connections](#section-5.2)
    TEXT[!MAY,todo]:    Invalid packets that lack strong integrity protection, such as
    TEXT[!MAY,todo]:    Initial, Retry, or Version Negotiation, MAY be discarded.
    TEXT[!MUST]: An
    TEXT[!MUST]:    endpoint MUST generate a connection error if processing the contents
    TEXT[!MUST]:    of these packets prior to discovering an error, or fully revert any
    TEXT[!MUST]:    changes made during that processing.

  SECTION: [Client Packet Handling](#section-5.2.1)
    TEXT[implementation]:    Due to packet reordering or loss, a client might receive packets for
    TEXT[implementation]:    a connection that are encrypted with a key it has not yet computed.
    TEXT[!MAY,implementation,todo]:    The client MAY drop these packets, or it MAY buffer them in
    TEXT[!MAY,implementation,todo]:    anticipation of later packets that allow it to compute the key.
    TEXT[!MUST,implementation]:    If a client receives a packet that uses a different version than it
    TEXT[!MUST,implementation]:    initially selected, it MUST discard that packet.

  SECTION: [Server Packet Handling](#section-5.2.2)
    TEXT[!SHOULD,implementation]:    If a server receives a packet that indicates an unsupported version
    TEXT[!SHOULD,implementation]:    and if the packet is large enough to initiate a new connection for
    TEXT[!SHOULD,implementation]:    any supported version, the server SHOULD send a Version Negotiation
    TEXT[!SHOULD,implementation]:    packet as described in Section 6.1.
    TEXT[!MAY,implementation]: A server MAY limit the number of
    TEXT[!MAY,implementation]:    packets to which it responds with a Version Negotiation packet.
    TEXT[!MUST,implementation]:    Servers MUST drop smaller packets that specify unsupported versions.
    TEXT[!SHOULD,implementation]: Servers SHOULD respond with a Version
    TEXT[!SHOULD,implementation]:    Negotiation packet, provided that the datagram is sufficiently long.
    TEXT[!SHOULD,todo]:    If a server refuses to accept a new connection, it SHOULD send an
    TEXT[!SHOULD,todo]:    Initial packet containing a CONNECTION_CLOSE frame with error code
    TEXT[!SHOULD,todo]:    CONNECTION_REFUSED.
    TEXT[!MAY,todo]:    If the packet is a 0-RTT packet, the server MAY buffer a limited
    TEXT[!MAY,todo]:    number of these packets in anticipation of a late-arriving Initial
    TEXT[!MAY,todo]:    packet.
    TEXT[!SHOULD,todo]: Clients are not able to send Handshake packets prior to
    TEXT[!SHOULD,todo]:    receiving a server response, so servers SHOULD ignore any such
    TEXT[!SHOULD,todo]:    packets.
    TEXT[!MUST,implementation]:    Servers MUST drop incoming packets under all other circumstances.

  SECTION: [Considerations for Simple Load Balancers](#section-5.2.3)
    TEXT[!SHOULD,exception]:    A server in a deployment that does not implement a solution to
    TEXT[!SHOULD,exception]:    maintain connection continuity when the client address changes SHOULD
    TEXT[!SHOULD,exception]:    indicate that migration is not supported by using the
    TEXT[!SHOULD,exception]:    disable_active_migration transport parameter.
    TEXT[!MUST,exception]:    Server deployments that use this simple form of load balancing MUST
    TEXT[!MUST,exception]:    avoid the creation of a stateless reset oracle; see Section 21.11.

  SECTION: [Version Negotiation](#section-6)
    TEXT[!SHOULD,todo]: Clients that support
    TEXT[!SHOULD,todo]:    multiple QUIC versions SHOULD ensure that the first UDP datagram they
    TEXT[!SHOULD,todo]:    send is sized to the largest of the minimum datagram sizes from all
    TEXT[!SHOULD,todo]:    versions they support, using PADDING frames (Section 19.1) as
    TEXT[!SHOULD,todo]:    necessary.
    TEXT[implementation]: A server might not send a Version
    TEXT[implementation]:    Negotiation packet if the datagram it receives is smaller than the
    TEXT[implementation]:    minimum size specified in a different version;

  SECTION: [Sending Version Negotiation Packets](#section-6.1)
    TEXT[!MUST,implementation]: An endpoint MUST NOT send a Version Negotiation packet
    TEXT[!MUST,implementation]:    in response to receiving a Version Negotiation packet.
    TEXT[!MAY,implementation]:    A server MAY limit the number of Version Negotiation packets it
    TEXT[!MAY,implementation]:    sends.
    TEXT[implementation]: a server that is able to recognize packets as
    TEXT[implementation]:    0-RTT might choose not to send Version Negotiation packets in
    TEXT[implementation]:    response to 0-RTT packets with the expectation that it will
    TEXT[implementation]:    eventually receive an Initial packet.

  SECTION: [Handling Version Negotiation Packets](#section-6.2)
    TEXT[!MUST,todo]:    A client that supports only this version of QUIC MUST abandon the
    TEXT[!MUST,todo]:    current connection attempt if it receives a Version Negotiation
    TEXT[!MUST,todo]:    packet, with the following two exceptions.
    TEXT[!MUST,todo]: A client MUST discard any
    TEXT[!MUST,todo]:    Version Negotiation packet if it has received and successfully
    TEXT[!MUST,todo]:    processed any other packet, including an earlier Version Negotiation
    TEXT[!MUST,todo]:    packet.
    TEXT[!MUST,todo]: A client MUST discard a Version Negotiation packet that
    TEXT[!MUST,todo]:    lists the QUIC version selected by the client.

  SECTION: [Using Reserved Versions](#section-6.3)
    TEXT[implementation]:    For a server to use a new version in the future, clients need to
    TEXT[implementation]:    correctly handle unsupported versions.  Some version numbers
    TEXT[implementation]:    (0x?a?a?a?a, as defined in Section 15) are reserved for inclusion in
    TEXT[implementation]:    fields that contain version numbers.
    TEXT[!MAY,implementation]:    Endpoints MAY add reserved versions to any field where unknown or
    TEXT[!MAY,implementation]:    unsupported versions are ignored to test that a peer correctly
    TEXT[!MAY,implementation]:    ignores the value.
    TEXT[!MAY,implementation]:    Endpoints MAY send packets with a reserved version to test that a
    TEXT[!MAY,implementation]:    peer correctly discards the packet.

  SECTION: [Cryptographic and Transport Handshake](#section-7)
    TEXT[!MUST,exception]: The cryptographic handshake MUST
    TEXT[!MUST,exception]:    provide the following properties:
    TEXT[!MUST,implementation]:    Endpoints MUST explicitly negotiate an application protocol.

  SECTION: [Example Handshake Flows](#section-7.1)
    TEXT[implementation]:    Client                                                  Server
    TEXT[implementation]:    Initial[0]: CRYPTO[CH] ->
    TEXT[implementation]:                                     Initial[0]: CRYPTO[SH] ACK[0]
    TEXT[implementation]:                           Handshake[0]: CRYPTO[EE, CERT, CV, FIN]
    TEXT[implementation]:                                     <- 1-RTT[0]: STREAM[1, "..."]
    TEXT[implementation]:    Initial[1]: ACK[0]
    TEXT[implementation]:    Handshake[0]: CRYPTO[FIN], ACK[0]
    TEXT[implementation]:    1-RTT[0]: STREAM[0, "..."], ACK[0] ->
    TEXT[implementation]:                                              Handshake[1]: ACK[0]
    TEXT[implementation]:             <- 1-RTT[1]: HANDSHAKE_DONE, STREAM[3, "..."], ACK[0]
    TEXT[implementation]:                      Figure 5: Example 1-RTT Handshake

  SECTION: [Negotiating Connection IDs](#section-7.2)
    TEXT[implementation]:    When an Initial packet is sent by a client that has not previously
    TEXT[implementation]:    received an Initial or Retry packet from the server, the client
    TEXT[implementation]:    populates the Destination Connection ID field with an unpredictable
    TEXT[implementation]:    value.
    TEXT[!MUST,implementation]: This Destination Connection ID MUST be at least 8 bytes in
    TEXT[!MUST,implementation]:    length.
    TEXT[!MUST,implementation,test,todo]: Until a packet is received from the server, the client MUST
    TEXT[!MUST,implementation,test,todo]:    use the same Destination Connection ID value on all packets in this
    TEXT[!MUST,implementation,test,todo]:    connection.
    TEXT[implementation]:    The Destination Connection ID field from the first Initial packet
    TEXT[implementation]:    sent by a client is used to determine packet protection keys for
    TEXT[implementation]:    Initial packets.
    TEXT[!MUST,implementation,todo]: Once a
    TEXT[!MUST,implementation,todo]:    client has received a valid Initial packet from the server, it MUST
    TEXT[!MUST,implementation,todo]:    discard any subsequent packet it receives on that connection with a
    TEXT[!MUST,implementation,todo]:    different Source Connection ID.
    TEXT[!MUST,implementation,todo]:    A client MUST change the Destination Connection ID it uses for
    TEXT[!MUST,implementation,todo]:    sending packets in response to only the first received Initial or
    TEXT[!MUST,implementation,todo]:    Retry packet.
    TEXT[!MUST,implementation]: A server MUST set the Destination Connection ID it
    TEXT[!MUST,implementation]:    uses for sending packets based on the first received Initial packet.
    TEXT[!MUST,implementation,todo]:    Any further changes to the Destination Connection ID are only
    TEXT[!MUST,implementation,todo]:    permitted if the values are taken from NEW_CONNECTION_ID frames; if
    TEXT[!MUST,implementation,todo]:    subsequent Initial packets include a different Source Connection ID,
    TEXT[!MUST,implementation,todo]:    they MUST be discarded.

  SECTION: [Authenticating Connection IDs](#section-7.3)
    TEXT[implementation]:    Each endpoint includes the value of the Source Connection ID field
    TEXT[implementation]:    from the first Initial packet it sent in the
    TEXT[implementation]:    initial_source_connection_id transport parameter
    TEXT[implementation]:    A server includes the Destination Connection ID field from the first
    TEXT[implementation]:    Initial packet it received from the client in the
    TEXT[implementation]:    original_destination_connection_id transport parameter; if the server
    TEXT[implementation]:    sent a Retry packet, this refers to the first Initial packet received
    TEXT[implementation]:    before sending the Retry packet.  If it sends a Retry packet, a
    TEXT[implementation]:    server also includes the Source Connection ID field from the Retry
    TEXT[implementation]:    packet in the retry_source_connection_id transport parameter.
    TEXT[!MUST,implementation]:    The values provided by a peer for these transport parameters MUST
    TEXT[!MUST,implementation]:    match the values that an endpoint used in the Destination and Source
    TEXT[!MUST,implementation]:    Connection ID fields of Initial packets that it sent (and received,
    TEXT[!MUST,implementation]:    for servers).
    TEXT[!MUST,implementation]: Endpoints MUST validate that received transport
    TEXT[!MUST,implementation]:    parameters match received connection ID values.
    TEXT[!MUST,implementation]:    An endpoint MUST treat the absence of the
    TEXT[!MUST,implementation]:    initial_source_connection_id transport parameter from either endpoint
    TEXT[!MUST,implementation]:    or the absence of the original_destination_connection_id transport
    TEXT[!MUST,implementation]:    parameter from the server as a connection error of type
    TEXT[!MUST,implementation]:    TRANSPORT_PARAMETER_ERROR.
    TEXT[!MUST,implementation]:    An endpoint MUST treat the following as a connection error of type
    TEXT[!MUST,implementation]:    TRANSPORT_PARAMETER_ERROR or PROTOCOL_VIOLATION:
    TEXT[implementation]:    *  absence of the retry_source_connection_id transport parameter from
    TEXT[implementation]:       the server after receiving a Retry packet,
    TEXT[implementation]:    *  presence of the retry_source_connection_id transport parameter
    TEXT[implementation]:       when no Retry packet was received, or
    TEXT[implementation]:    *  a mismatch between values received from a peer in these transport
    TEXT[implementation]:       parameters and the value sent in the corresponding Destination or
    TEXT[implementation]:       Source Connection ID fields of Initial packets.

  SECTION: [Transport Parameters](#section-7.4)
    TEXT[!MUST,implementation]:    An endpoint MUST treat receipt of a transport parameter with an
    TEXT[!MUST,implementation]:    invalid value as a connection error of type
    TEXT[!MUST,implementation]:    TRANSPORT_PARAMETER_ERROR.
    TEXT[!MUST,implementation]:    An endpoint MUST NOT send a parameter more than once in a given
    TEXT[!MUST,implementation]:    transport parameters extension.
    TEXT[!SHOULD,implementation]: An endpoint SHOULD treat receipt of
    TEXT[!SHOULD,implementation]:    duplicate transport parameters as a connection error of type
    TEXT[!SHOULD,implementation]:    TRANSPORT_PARAMETER_ERROR.

  SECTION: [Values of Transport Parameters for 0-RTT](#section-7.4.1)
    TEXT[implementation]: To
    TEXT[implementation]:    enable 0-RTT, endpoints store the values of the server transport
    TEXT[implementation]:    parameters with any session tickets it receives on the connection.
    TEXT[!MUST,exception]:    The definition of a new transport parameter (Section 7.4.2) MUST
    TEXT[!MUST,exception]:    specify whether storing the transport parameter for 0-RTT is
    TEXT[!MUST,exception]:    mandatory, optional, or prohibited.
    TEXT[!MUST,implementation]:    A client MUST NOT use remembered values for the following parameters:
    TEXT[!MUST,implementation]:    ack_delay_exponent, max_ack_delay, initial_source_connection_id,
    TEXT[!MUST,implementation]:    original_destination_connection_id, preferred_address,
    TEXT[!MUST,implementation]:    retry_source_connection_id, and stateless_reset_token.
    TEXT[!MUST,todo]: The client
    TEXT[!MUST,todo]:    MUST use the server's new values in the handshake instead; if the
    TEXT[!MUST,todo]:    server does not provide new values, the default values are used.
    TEXT[!MUST,todo]:    A client that attempts to send 0-RTT data MUST remember all other
    TEXT[!MUST,todo]:    transport parameters used by the server that it is able to process.
    TEXT[!MUST,todo]:    If 0-RTT data is accepted by the server, the server MUST NOT reduce
    TEXT[!MUST,todo]:    any limits or alter any values that might be violated by the client
    TEXT[!MUST,todo]:    with its 0-RTT data.
    TEXT[!MUST,todo]: In particular, a server that accepts 0-RTT data
    TEXT[!MUST,todo]:    MUST NOT set values for the following parameters (Section 18.2) that
    TEXT[!MUST,todo]:    are smaller than the remembered values of the parameters.
    TEXT[implementation]:    *  active_connection_id_limit
    TEXT[implementation]:    *  initial_max_data
    TEXT[implementation]:    *  initial_max_stream_data_bidi_local
    TEXT[implementation]:    *  initial_max_stream_data_bidi_remote
    TEXT[implementation]:    *  initial_max_stream_data_uni
    TEXT[implementation]:    *  initial_max_streams_bidi
    TEXT[implementation]:    *  initial_max_streams_uni
    TEXT[!SHOULD,todo]: The applicable
    TEXT[!SHOULD,todo]:    subset of transport parameters that permit the sending of application
    TEXT[!SHOULD,todo]:    data SHOULD be set to non-zero values for 0-RTT.
    TEXT[!MAY,todo]:    A server MAY store and recover the previously sent values of the
    TEXT[!MAY,todo]:    max_idle_timeout, max_udp_payload_size, and disable_active_migration
    TEXT[!MAY,todo]:    parameters and reject 0-RTT if it selects smaller values.
    TEXT[!MUST,todo]:    A server MUST reject 0-RTT data if the restored values for transport
    TEXT[!MUST,todo]:    parameters cannot be supported.
    TEXT[!MUST,todo]:    When sending frames in 0-RTT packets, a client MUST only use
    TEXT[!MUST,todo]:    remembered transport parameters;
    TEXT[!MUST,todo]: importantly, it MUST NOT use updated
    TEXT[!MUST,todo]:    values that it learns from the server's updated transport parameters
    TEXT[!MUST,todo]:    or from frames received in 1-RTT packets.
    TEXT[!MAY,todo]:    server MAY treat the use of updated transport parameters in 0-RTT as
    TEXT[!MAY,todo]:    a connection error of type PROTOCOL_VIOLATION.

  SECTION: [New Transport Parameters](#section-7.4.2)
    TEXT[!MUST,implementation,test]: An endpoint MUST ignore transport parameters that it does
    TEXT[!MUST,implementation,test]:    not support.

  SECTION: [Cryptographic Message Buffering](#section-7.5)
    TEXT[!MUST,todo]:    Implementations MUST support buffering at least 4096 bytes of data
    TEXT[!MUST,todo]:    received in out-of-order CRYPTO frames.
    TEXT[!MAY,todo]: Endpoints MAY choose to
    TEXT[!MAY,todo]:    allow more data to be buffered during the handshake.
    TEXT[!MUST,implementation]: If an endpoint does not expand its buffer, it MUST close
    TEXT[!MUST,implementation]:    the connection with a CRYPTO_BUFFER_EXCEEDED error code.
    TEXT[!MAY]:    Once the handshake completes, if an endpoint is unable to buffer all
    TEXT[!MAY]:    data in a CRYPTO frame, it MAY discard that CRYPTO frame and all
    TEXT[!MAY]:    CRYPTO frames received in the future, or it MAY close the connection
    TEXT[!MAY]:    with a CRYPTO_BUFFER_EXCEEDED error code.
    TEXT[!MUST,implementation]: Packets containing
    TEXT[!MUST,implementation]:    discarded CRYPTO frames MUST be acknowledged because the packet has
    TEXT[!MUST,implementation]:    been received and processed by the transport even though the CRYPTO
    TEXT[!MUST,implementation]:    frame was discarded.

  SECTION: [Address Validation](#section-8)
    TEXT[!MUST]: Therefore, after receiving packets from an address that is
    TEXT[!MUST]:    not yet validated, an endpoint MUST limit the amount of data it sends
    TEXT[!MUST]:    to the unvalidated address to three times the amount of data received
    TEXT[!MUST]:    from that address.

  SECTION: [Address Validation during Connection Establishment](#section-8.1)
    TEXT[implementation]: Once an endpoint has successfully processed a
    TEXT[implementation]:    Handshake packet from the peer, it can consider the peer address to
    TEXT[implementation]:    have been validated.
    TEXT[!MAY,todo]:    Additionally, an endpoint MAY consider the peer address validated if
    TEXT[!MAY,todo]:    the peer uses a connection ID chosen by the endpoint and the
    TEXT[!MAY,todo]:    connection ID contains at least 64 bits of entropy
    TEXT[!MAY]: .
    TEXT[!MUST,implementation,test]:    Prior to validating the client address, servers MUST NOT send more
    TEXT[!MUST,implementation,test]:    than three times as many bytes as the number of bytes they have
    TEXT[!MUST,implementation,test]:    received.
    TEXT[!MUST,implementation,test]: For the purposes of
    TEXT[!MUST,implementation,test]:    avoiding amplification prior to address validation, servers MUST
    TEXT[!MUST,implementation,test]:    count all of the payload bytes received in datagrams that are
    TEXT[!MUST,implementation,test]:    uniquely attributed to a single connection.
    TEXT[!MUST,todo]:    Clients MUST ensure that UDP datagrams containing Initial packets
    TEXT[!MUST,todo]:    have UDP payloads of at least 1200 bytes, adding PADDING frames as
    TEXT[!MUST,todo]:    necessary.
    TEXT[!MUST,todo]: To
    TEXT[!MUST,todo]:    prevent this deadlock, clients MUST send a packet on a Probe Timeout
    TEXT[!MUST,todo]:    (PTO); see Section 6.2 of [QUIC-RECOVERY].
    TEXT[!MUST,todo]: Specifically, the client
    TEXT[!MUST,todo]:    MUST send an Initial packet in a UDP datagram that contains at least
    TEXT[!MUST,todo]:    1200 bytes if it does not have Handshake keys, and otherwise send a
    TEXT[!MUST,todo]:    Handshake packet.
    TEXT[implementation]: Clients are only constrained by the
    TEXT[implementation]:    congestion controller.

  SECTION: [Token Construction](#section-8.1.1)
    TEXT[!MUST,implementation,test]:    A token sent in a NEW_TOKEN frame or a Retry packet MUST be
    TEXT[!MUST,implementation,test]:    constructed in a way that allows the server to identify how it was
    TEXT[!MUST,implementation,test]:    provided to a client.
    TEXT[implementation]:   These tokens are carried in the same field but
    TEXT[implementation]:    require different handling from servers.

  SECTION: [Address Validation Using Retry Packets](#section-8.1.2)
    TEXT[implementation]:    Upon receiving the client's Initial packet, the server can request
    TEXT[implementation]:    address validation by sending a Retry packet (Section 17.2.5)
    TEXT[implementation]:    containing a token.
    TEXT[!MUST,todo]: This token MUST be repeated by the client in all
    TEXT[!MUST,todo]:    Initial packets it sends for that connection after it receives the
    TEXT[!MUST,todo]:    Retry packet.
    TEXT[implementation]:    In response to processing an Initial packet containing a token that
    TEXT[implementation]:    was provided in a Retry packet, a server cannot send another Retry
    TEXT[implementation]:    packet; it can only refuse the connection or permit it to proceed.
    TEXT[implementation]:    A server can also use a Retry packet to defer the state and
    TEXT[implementation]:    processing costs of connection establishment.  Requiring the server
    TEXT[implementation]:    to provide a different connection ID, along with the
    TEXT[implementation]:    original_destination_connection_id transport parameter defined in
    TEXT[implementation]:    Section 18.2, forces the server to demonstrate that it, or an entity
    TEXT[implementation]:    it cooperates with, received the original Initial packet from the
    TEXT[implementation]:    client.
    TEXT[!SHOULD,todo]: Instead, the
    TEXT[!SHOULD,todo]:    server SHOULD immediately close (Section 10.2) the connection with an
    TEXT[!SHOULD,todo]:    INVALID_TOKEN error.

  SECTION: [Address Validation for Future Connections](#section-8.1.3)
    TEXT[!MAY,todo]:    A server MAY provide clients with an address validation token during
    TEXT[!MAY,todo]:    one connection that can be used on a subsequent connection.
    TEXT[!MUST]: The client
    TEXT[!MUST]:    MUST include the token in all Initial packets it sends, unless a
    TEXT[!MUST]:    Retry replaces the token with a newer one.
    TEXT[!MUST]: The client MUST NOT use
    TEXT[!MUST]:    the token provided in a Retry for future connections.
    TEXT[!MAY,implementation]: Servers MAY
    TEXT[!MAY,implementation]:    discard any Initial packet that does not carry the expected token.
    TEXT[!SHOULD,implementation,test]: Thus, a token SHOULD have an
    TEXT[!SHOULD,implementation,test]:    expiration time, which could be either an explicit expiration time or
    TEXT[!SHOULD,implementation,test]:    an issued timestamp that can be used to dynamically calculate the
    TEXT[!SHOULD,implementation,test]:    expiration time.
    TEXT[!MUST,todo]:    A token issued with NEW_TOKEN MUST NOT include information that would
    TEXT[!MUST,todo]:    allow values to be linked by an observer to the connection on which
    TEXT[!MUST,todo]:    it was issued.
    TEXT[!MUST,todo]: A server MUST ensure that every NEW_TOKEN frame it sends
    TEXT[!MUST,todo]:    is unique across all clients, with the exception of those sent to
    TEXT[!MUST,todo]:    repair losses of previously sent NEW_TOKEN frames.
    TEXT[!MAY,implementation]: Information that
    TEXT[!MAY,implementation]:    allows the server to distinguish between tokens from Retry and
    TEXT[!MAY,implementation]:    NEW_TOKEN MAY be accessible to entities other than the server.
    TEXT[!SHOULD,todo]: When connecting to a server for
    TEXT[!SHOULD,todo]:    which the client retains an applicable and unused token, it SHOULD
    TEXT[!SHOULD,todo]:    include that token in the Token field of its Initial packet.
    TEXT[!MUST,todo]: A client MUST NOT include
    TEXT[!MUST,todo]:    a token that is not applicable to the server that it is connecting
    TEXT[!MUST,todo]:    to, unless the client has the knowledge that the server that issued
    TEXT[!MUST,todo]:    the token and the server the client is connecting to are jointly
    TEXT[!MUST,todo]:    managing the tokens.
    TEXT[!MAY,todo]: A client MAY use a token from any previous
    TEXT[!MAY,todo]:    connection to that server.
    TEXT[todo]:    Clients that want to break continuity of identity with a server can
    TEXT[todo]:    discard tokens provided using the NEW_TOKEN frame.
    TEXT[!MUST,todo]: In comparison, a
    TEXT[!MUST,todo]:    token obtained in a Retry packet MUST be used immediately during the
    TEXT[!MUST,todo]:    connection attempt and cannot be used in subsequent connection
    TEXT[!MUST,todo]:    attempts.
    TEXT[!SHOULD,todo]:    A client SHOULD NOT reuse a token from a NEW_TOKEN frame for
    TEXT[!SHOULD,todo]:    different connection attempts.
    TEXT[!MUST,implementation]:    When a server receives an Initial packet with an address validation
    TEXT[!MUST,implementation]:    token, it MUST attempt to validate the token, unless it has already
    TEXT[!MUST,implementation]:    completed address validation.
    TEXT[!SHOULD,todo]: If the token is invalid, then the
    TEXT[!SHOULD,todo]:    server SHOULD proceed as if the client did not have a validated
    TEXT[!SHOULD,todo]:    address, including potentially sending a Retry packet.
    TEXT[!SHOULD,implementation]: If the validation succeeds, the server SHOULD then allow
    TEXT[!SHOULD,implementation]:    the handshake to proceed.
    TEXT[!MAY]:    Clients MAY use tokens obtained on one connection for any connection
    TEXT[!MAY]:    attempt using the same version.

  SECTION: [Address Validation Token Integrity](#section-8.1.4)
    TEXT[!MUST,implementation]:    An address validation token MUST be difficult to guess.
    TEXT[implementation]:   Including a
    TEXT[implementation]:    random value with at least 128 bits of entropy in the token would be
    TEXT[implementation]:    sufficient, but this depends on the server remembering the value it
    TEXT[implementation]:    sends to clients.
    TEXT[implementation]:    A token-based scheme allows the server to offload any state
    TEXT[implementation]:    associated with validation to the client.
    TEXT[!MUST,implementation,test]: For this design to work,
    TEXT[!MUST,implementation,test]:    the token MUST be covered by integrity protection against
    TEXT[!MUST,implementation,test]:    modification or falsification by clients.
    TEXT[implementation]:   Without integrity
    TEXT[implementation]:    protection, malicious clients could generate or guess values for
    TEXT[implementation]:    tokens that would be accepted by the server.  Only the server
    TEXT[implementation]:    requires access to the integrity protection key for tokens.
    TEXT[implementation]:    There is no need for a single well-defined format for the token
    TEXT[implementation]:    because the server that generates the token also consumes it.
    TEXT[!SHOULD,implementation,test]: Tokens
    TEXT[!SHOULD,implementation,test]:    sent in Retry packets SHOULD include information that allows the
    TEXT[!SHOULD,implementation,test]:    server to verify that the source IP address and port in client
    TEXT[!SHOULD,implementation,test]:    packets remain constant.
    TEXT[!MUST,todo]:    Tokens sent in NEW_TOKEN frames MUST include information that allows
    TEXT[!MUST,todo]:    the server to verify that the client IP address has not changed from
    TEXT[!MUST,todo]:    when the token was issued.
    TEXT[!MUST,implementation,test]: If the client IP address has changed, the
    TEXT[!MUST,implementation,test]:    server MUST adhere to the anti-amplification limit; see Section 8.
    TEXT[!MUST,implementation,test]: To protect against such attacks, servers MUST ensure that
    TEXT[!MUST,implementation,test]:    replay of tokens is prevented or limited.
    TEXT[!SHOULD,implementation,test]: Servers SHOULD ensure that
    TEXT[!SHOULD,implementation,test]:    tokens sent in Retry packets are only accepted for a short time,
    TEXT[!SHOULD]:  as
    TEXT[!SHOULD]:    they are returned immediately by clients.
    TEXT[!SHOULD,todo]: Tokens that are provided
    TEXT[!SHOULD,todo]:    in NEW_TOKEN frames (Section 19.7) need to be valid for longer but
    TEXT[!SHOULD,todo]:    SHOULD NOT be accepted multiple times.
    TEXT[!MAY,exception]: Servers are encouraged to
    TEXT[!MAY,exception]:    allow tokens to be used only once, if possible; tokens MAY include
    TEXT[!MAY,exception]:    additional information about clients to further narrow applicability
    TEXT[!MAY,exception]:    or reuse.

  SECTION: [Path Validation](#section-8.2)
    TEXT[!MAY,implementation,todo]:    An endpoint MAY include other frames with the PATH_CHALLENGE and
    TEXT[!MAY,implementation,todo]:    PATH_RESPONSE frames used for path validation.

  SECTION: [Initiating Path Validation](#section-8.2.1)
    TEXT[!MAY,implementation,test,todo]:    An endpoint MAY send multiple PATH_CHALLENGE frames to guard against
    TEXT[!MAY,implementation,test,todo]:    packet loss.
    TEXT[!SHOULD,implementation,test,todo]: However, an endpoint SHOULD NOT send multiple
    TEXT[!SHOULD,implementation,test,todo]:    PATH_CHALLENGE frames in a single packet.
    TEXT[!SHOULD,implementation,test,todo]:    An endpoint SHOULD NOT probe a new path with packets containing a
    TEXT[!SHOULD,implementation,test,todo]:    PATH_CHALLENGE frame more frequently than it would send an Initial
    TEXT[!SHOULD,implementation,test,todo]:    packet.
    TEXT[!MUST,implementation,test]:    The endpoint MUST use unpredictable data in every PATH_CHALLENGE
    TEXT[!MUST,implementation,test]:    frame so that it can associate the peer's response with the
    TEXT[!MUST,implementation,test]:    corresponding PATH_CHALLENGE.
    TEXT[!MUST,implementation,todo]:    An endpoint MUST expand datagrams that contain a PATH_CHALLENGE frame
    TEXT[!MUST,implementation,todo]:    to at least the smallest allowed maximum datagram size of 1200 bytes,
    TEXT[!MUST]:    unless the anti-amplification limit for the path does not permit
    TEXT[!MUST]:    sending a datagram of this size.
    TEXT[!MUST]: To ensure that the path MTU is large enough, the endpoint
    TEXT[!MUST]:    MUST perform a second path validation by sending a PATH_CHALLENGE
    TEXT[!MUST]:    frame in a datagram of at least 1200 bytes.
    TEXT[!MUST]:    Unlike other cases where datagrams are expanded, endpoints MUST NOT
    TEXT[!MUST]:    discard datagrams that appear to be too small when they contain
    TEXT[!MUST]:    PATH_CHALLENGE or PATH_RESPONSE.

  SECTION: [Path Validation Responses](#section-8.2.2)
    TEXT[!MUST,implementation,test]:    On receiving a PATH_CHALLENGE frame, an endpoint MUST respond by
    TEXT[!MUST,implementation,test]:    echoing the data contained in the PATH_CHALLENGE frame in a
    TEXT[!MUST,implementation,test]:    PATH_RESPONSE frame.
    TEXT[!MUST,implementation]: An endpoint MUST NOT delay transmission of a
    TEXT[!MUST,implementation]:    packet containing a PATH_RESPONSE frame unless constrained by
    TEXT[!MUST,implementation]:    congestion control.
    TEXT[!MUST,implementation,todo]:    A PATH_RESPONSE frame MUST be sent on the network path where the
    TEXT[!MUST,implementation,todo]:    PATH_CHALLENGE frame was received.
    TEXT[!MUST,implementation,test,todo]:    This requirement MUST NOT be enforced by the endpoint that initiates
    TEXT[!MUST,implementation,test,todo]:    path validation, as that would enable an attack on migration; see
    TEXT[!MUST,implementation,test,todo]:    Section 9.3.3.
    TEXT[!MUST,implementation,todo]:    An endpoint MUST expand datagrams that contain a PATH_RESPONSE frame
    TEXT[!MUST,implementation,todo]:    to at least the smallest allowed maximum datagram size of 1200 bytes.
    TEXT[!MUST]: However, an endpoint MUST NOT expand the
    TEXT[!MUST]:    datagram containing the PATH_RESPONSE if the resulting data exceeds
    TEXT[!MUST]:    the anti-amplification limit.
    TEXT[!MUST,implementation,test]:    An endpoint MUST NOT send more than one PATH_RESPONSE frame in
    TEXT[!MUST,implementation,test]:    response to one PATH_CHALLENGE frame; see Section 13.3.

  SECTION: [Successful Path Validation](#section-8.2.3)
    TEXT[implementation]:    Path validation succeeds when a PATH_RESPONSE frame is received that
    TEXT[implementation]:    contains the data that was sent in a previous PATH_CHALLENGE frame.
    TEXT[implementation,test]:    A PATH_RESPONSE frame received on any network path validates the path
    TEXT[implementation,test]:    on which the PATH_CHALLENGE was sent.
    TEXT[!MUST,exception]: However, the endpoint MUST initiate
    TEXT[!MUST,exception]:    another path validation with an expanded datagram to verify that the
    TEXT[!MUST,exception]:    path supports the required MTU.

  SECTION: [Failed Path Validation](#section-8.2.4)
    TEXT[!SHOULD,implementation,test]:    Endpoints SHOULD abandon path validation based on a timer.
    TEXT[implementation,test]: When
    TEXT[implementation,test]:    setting this timer, implementations are cautioned that the new path
    TEXT[implementation,test]:    could have a longer round-trip time than the original.
    TEXT[!SHOULD,implementation,test,exception]: A value of
    TEXT[!SHOULD,implementation,test,exception]:    three times the larger of the current PTO or the PTO for the new path
    TEXT[!SHOULD,implementation,test,exception]:    (using kInitialRtt, as defined in [QUIC-RECOVERY]) is RECOMMENDED.
    TEXT[!MAY]: An endpoint
    TEXT[!MAY]:    that has no valid network path to its peer MAY signal this using the
    TEXT[!MAY]:    NO_VIABLE_PATH connection error, noting that this is only possible if
    TEXT[!MAY]:    the network path exists but does not support the required MTU
    TEXT[!MAY]:    (Section 14).

  SECTION: [Connection Migration](#section-9)
    TEXT[implementation]:    The design of QUIC relies on endpoints retaining a stable address for
    TEXT[implementation]:    the duration of the handshake.
    TEXT[!MUST,implementation]: An endpoint MUST NOT initiate
    TEXT[!MUST,implementation]:    connection migration before the handshake is confirmed, as defined in
    TEXT[!MUST,implementation]:    Section 4.1.2 of [QUIC-TLS].
    TEXT[!MUST]:    If the peer sent the disable_active_migration transport parameter, an
    TEXT[!MUST]:    endpoint also MUST NOT send packets (including probing packets; see
    TEXT[!MUST]:    Section 9.1) from a different local address to the address the peer
    TEXT[!MUST]:    used during the handshake, unless the endpoint has acted on a
    TEXT[!MUST]:    preferred_address transport parameter from the peer.
    TEXT[!MUST,implementation]: If the peer
    TEXT[!MUST,implementation]:    violates this requirement, the endpoint MUST either drop the incoming
    TEXT[!MUST,implementation]:    packets on that path without generating a Stateless Reset or proceed
    TEXT[!MUST,implementation]:    with path validation and allow the peer to migrate.
    TEXT[implementation]:   Generating a
    TEXT[implementation]:    Stateless Reset or closing the connection would allow third parties
    TEXT[implementation]:    in the network to cause connections to close by spoofing or otherwise
    TEXT[implementation]:    manipulating observed traffic.
    TEXT[!MUST,implementation,test]: An endpoint MUST
    TEXT[!MUST,implementation,test]:    perform path validation (Section 8.2) if it detects any change to a
    TEXT[!MUST,implementation,test]:    peer's address, unless it has previously validated that address.
    TEXT[!MAY,implementation,test]:    When an endpoint has no validated path on which to send packets, it
    TEXT[!MAY,implementation,test]:    MAY discard connection state.
    TEXT[!MAY,todo]: An endpoint capable of connection
    TEXT[!MAY,todo]:    migration MAY wait for a new path to become available before
    TEXT[!MAY,todo]:    discarding connection state.
    TEXT[implementation]: Clients are
    TEXT[implementation]:    responsible for initiating all migrations.
    TEXT[implementation]: Servers do not send non-
    TEXT[implementation]:    probing packets (see Section 9.1) toward a client address until they
    TEXT[implementation]:    see a non-probing packet from that address.
    TEXT[!MUST,implementation,test]: If a client receives
    TEXT[!MUST,implementation,test]:    packets from an unknown server address, the client MUST discard these
    TEXT[!MUST,implementation,test]:    packets.

  SECTION: [Probing a New Path](#section-9.1)
    TEXT[!MAY]:    An endpoint MAY probe for peer reachability from a new local address
    TEXT[!MAY]:    using path validation (Section 8.2) prior to migrating the connection
    TEXT[!MAY]:    to the new local address.
    TEXT[implementation]:    PATH_CHALLENGE, PATH_RESPONSE, NEW_CONNECTION_ID, and PADDING frames
    TEXT[implementation]:    are "probing frames", and all other frames are "non-probing frames".
    TEXT[implementation,test]:    A packet containing only probing frames is a "probing packet", and a
    TEXT[implementation,test]:    packet containing any other frame is a "non-probing packet".

  SECTION: [Initiating Connection Migration](#section-9.2)
    TEXT[implementation,test]:    An endpoint can migrate a connection to a new local address by
    TEXT[implementation,test]:    sending packets containing non-probing frames from that address.
    TEXT[!MAY]: An endpoint MAY defer path
    TEXT[!MAY]:    validation until after a peer sends the next non-probing frame to its
    TEXT[!MAY]:    new address.

  SECTION: [Responding to Connection Migration](#section-9.3)
    TEXT[!MUST,implementation]:    If the recipient permits the migration, it MUST send subsequent
    TEXT[!MUST,implementation]:    packets to the new peer address and MUST initiate path validation
    TEXT[!MUST,implementation]:    (Section 8.2) to verify the peer's ownership of the address if
    TEXT[!MUST,implementation]:    validation is not already underway.
    TEXT[!MUST,implementation]:    An endpoint MAY send data to an unvalidated peer address, but it MUST
    TEXT[!MUST,implementation]:    protect against potential attacks as described in Sections 9.3.1 and
    TEXT[!MUST,implementation]:    9.3.2.
    TEXT[!MAY,todo]: An endpoint MAY skip validation of a peer address if that
    TEXT[!MAY,todo]:    address has been seen recently.
    TEXT[implementation,test]:    After changing the address to which it sends non-probing packets, an
    TEXT[implementation,test]:    endpoint can abandon any path validation for other addresses.
    TEXT[!SHOULD,todo]:    After verifying a new client address, the server SHOULD send new
    TEXT[!SHOULD,todo]:    address validation tokens (Section 8) to the client.

  SECTION: [Peer Address Spoofing](#section-9.3.1)
    TEXT[implementation]: Until a peer's address is deemed valid, an endpoint limits
    TEXT[implementation]:    the amount of data it sends to that address; see Section 8.

  SECTION: [On-Path Address Spoofing](#section-9.3.2)
    TEXT[!MUST,implementation,test]:    To protect the connection from failing due to such a spurious
    TEXT[!MUST,implementation,test]:    migration, an endpoint MUST revert to using the last validated peer
    TEXT[!MUST,implementation,test]:    address when validation of a new peer address fails.
    TEXT[!MUST,implementation,test]:    If an endpoint has no state about the last validated peer address, it
    TEXT[!MUST,implementation,test]:    MUST close the connection silently by discarding all connection
    TEXT[!MUST,implementation,test]:    state.
    TEXT[!MAY,implementation]: For instance, an endpoint MAY send a Stateless Reset in
    TEXT[!MAY,implementation]:    response to any further incoming packets.

  SECTION: [Off-Path Packet Forwarding](#section-9.3.3)
    TEXT[!MUST,implementation]:    In response to an apparent migration, endpoints MUST validate the
    TEXT[!MUST,implementation]:    previously active path using a PATH_CHALLENGE frame.
    TEXT[!SHOULD,implementation]:    An endpoint that receives a PATH_CHALLENGE on an active path SHOULD
    TEXT[!SHOULD,implementation]:    send a non-probing packet in response.

  SECTION: [Loss Detection and Congestion Control](#section-9.4)
    TEXT[!MUST,implementation,test]: Packets sent on the old path MUST NOT contribute to
    TEXT[!MUST,implementation,test]:    congestion control or RTT estimation for the new path.
    TEXT[!MUST,implementation,exception]:    On confirming a peer's ownership of its new address, an endpoint MUST
    TEXT[!MUST,implementation,exception]:    immediately reset the congestion controller and round-trip time
    TEXT[!MUST,implementation,exception]:    estimator for the new path to initial values (see Appendices A.3 and
    TEXT[!MUST,implementation,exception]:    B.3 of [QUIC-RECOVERY]) unless the only change in the peer's address
    TEXT[!MUST,implementation,exception]:    is its port number.
    TEXT[!MAY,exception,todo]: Because port-only changes are commonly the
    TEXT[!MAY,exception,todo]:    result of NAT rebinding or other middlebox activity, the endpoint MAY
    TEXT[!MAY,exception,todo]:    instead retain its congestion control state and round-trip estimate
    TEXT[!MAY,exception,todo]:    in those cases instead of reverting to initial values.
    TEXT[!MUST,exception]:    This timer SHOULD be set as described in Section 6.2.1 of
    TEXT[!MUST,exception]:    [QUIC-RECOVERY] and MUST NOT be more aggressive.

  SECTION: [Privacy Implications of Connection Migration](#section-9.5)
    TEXT[!MAY]:    At any time, endpoints MAY change the Destination Connection ID they
    TEXT[!MAY]:    transmit with to a value that has not been used on another path.
    TEXT[!MUST]:    An endpoint MUST NOT reuse a connection ID when sending from more
    TEXT[!MUST]:    than one local address -- for example, when initiating connection
    TEXT[!MUST]:    migration as described in Section 9.2 or when probing a new network
    TEXT[!MUST]:    path as described in Section 9.1.
    TEXT[!MUST,implementation]:    Similarly, an endpoint MUST NOT reuse a connection ID when sending to
    TEXT[!MUST,implementation]:    more than one destination address.
    TEXT[!MAY,implementation]: Due to network changes outside
    TEXT[!MAY,implementation]:    the control of its peer, an endpoint might receive packets from a new
    TEXT[!MAY,implementation]:    source address with the same Destination Connection ID field value,
    TEXT[!MAY,implementation]:    in which case it MAY continue to use the current connection ID with
    TEXT[!MAY,implementation]:    the new remote address while still sending from the same local
    TEXT[!MAY,implementation]:    address.
    TEXT[!SHOULD]:    An endpoint SHOULD NOT initiate migration with a peer that has
    TEXT[!SHOULD]:    requested a zero-length connection ID, because traffic over the new
    TEXT[!SHOULD]:    path might be trivially linkable to traffic over the old one.
    TEXT[!SHOULD]: Changing address
    TEXT[!SHOULD]:    can cause a peer to reset its congestion control state (see
    TEXT[!SHOULD]:    Section 9.4), so addresses SHOULD only be changed infrequently.
    TEXT[!SHOULD,implementation,test]: To ensure that migration is possible and
    TEXT[!SHOULD,implementation,test]:    packets sent on different paths cannot be correlated, endpoints
    TEXT[!SHOULD,implementation,test]:    SHOULD provide new connection IDs before peers migrate; see
    TEXT[!SHOULD,implementation,test]:    Section 5.1.1.

  SECTION: [Server's Preferred Address](#section-9.6)
    TEXT[!SHOULD]: If a
    TEXT[!SHOULD]:    client receives packets from a new server address when the client has
    TEXT[!SHOULD]:    not initiated a migration to that address, the client SHOULD discard
    TEXT[!SHOULD]:    these packets.

  SECTION: [Communicating a Preferred Address](#section-9.6.1)
    TEXT[!MAY]:    Servers MAY communicate a preferred address of each address family
    TEXT[!MAY]:    (IPv4 and IPv6) to allow clients to pick the one most suited to their
    TEXT[!MAY]:    network attachment.
    TEXT[!SHOULD]:    Once the handshake is confirmed, the client SHOULD select one of the
    TEXT[!SHOULD]:    two addresses provided by the server and initiate path validation
    TEXT[!SHOULD]:    (see Section 8.2).
    TEXT[!SHOULD]:    As soon as path validation succeeds, the client SHOULD begin sending
    TEXT[!SHOULD]:    all future packets to the new server address using the new connection
    TEXT[!SHOULD]:    ID and discontinue use of the old server address.
    TEXT[!MUST]: If path validation
    TEXT[!MUST]:    fails, the client MUST continue sending all future packets to the
    TEXT[!MUST]:    server's original IP address.

  SECTION: [Migration to a Preferred Address](#section-9.6.2)
    TEXT[!MUST]:    A client that migrates to a preferred address MUST validate the
    TEXT[!MUST]:    address it chooses before migrating; see Section 21.5.3.
    TEXT[!MUST]: The server MUST send non-
    TEXT[!MUST]:    probing packets from its original address until it receives a non-
    TEXT[!MUST]:    probing packet from the client at its preferred address and until the
    TEXT[!MUST]:    server has validated the new path.
    TEXT[!MUST]:    The server MUST probe on the path toward the client from its
    TEXT[!MUST]:    preferred address.
    TEXT[!SHOULD]: The server SHOULD drop
    TEXT[!SHOULD]:    newer packets for this connection that are received on the old IP
    TEXT[!SHOULD]:    address.
    TEXT[!MAY]: The server MAY continue to process delayed packets that are
    TEXT[!MAY]:    received on the old IP address.
    TEXT[!MUST]: A client MUST NOT use these for other connections,
    TEXT[!MUST]:    including connections that are resumed from the current connection.

  SECTION: [Interaction of Client Migration and Preferred Address](#section-9.6.3)
    TEXT[!SHOULD]: In this case, the client
    TEXT[!SHOULD]:    SHOULD perform path validation to both the original and preferred
    TEXT[!SHOULD]:    server address from the client's new address concurrently.
    TEXT[!MUST]:    If path validation of the server's preferred address succeeds, the
    TEXT[!MUST]:    client MUST abandon validation of the original address and migrate to
    TEXT[!MUST]:    using the server's preferred address.
    TEXT[!MAY]: If path validation of the
    TEXT[!MAY]:    server's preferred address fails but validation of the server's
    TEXT[!MAY]:    original address succeeds, the client MAY migrate to its new address
    TEXT[!MAY]:    and continue sending to the server's original address.
    TEXT[!MUST]:    If packets received at the server's preferred address have a
    TEXT[!MUST]:    different source address than observed from the client during the
    TEXT[!MUST]:    handshake, the server MUST protect against potential attacks as
    TEXT[!MUST]:    described in Sections 9.3.1 and 9.3.2.
    TEXT[!SHOULD,implementation]:    Servers SHOULD initiate path validation to the client's new address
    TEXT[!SHOULD,implementation]:    upon receiving a probe packet from a different address;
    TEXT[!SHOULD]:  see
    TEXT[!SHOULD]:    Section 8.
    TEXT[!SHOULD]:    A client that migrates to a new address SHOULD use a preferred
    TEXT[!SHOULD]:    address from the same address family for the server.
    TEXT[!MAY]: This
    TEXT[!MAY]:    connection ID is provided to ensure that the client has a connection
    TEXT[!MAY]:    ID available for migration, but the client MAY use this connection ID
    TEXT[!MAY]:    on any path.

  SECTION: [Use of IPv6 Flow Label and Migration](#section-9.7)
    TEXT[!SHOULD]:    Endpoints that send data using IPv6 SHOULD apply an IPv6 flow label
    TEXT[!SHOULD]:    in compliance with [RFC6437], unless the local API does not allow
    TEXT[!SHOULD]:    setting IPv6 flow labels.
    TEXT[!MUST]:    The flow label generation MUST be designed to minimize the chances of
    TEXT[!MUST]:    linkability with a previously used flow label, as a stable flow label
    TEXT[!MUST]:    would enable correlating activity on multiple paths; see Section 9.5.

  SECTION: [Connection Termination](#section-10)
    TEXT[!MAY,implementation,test]:    An endpoint MAY discard connection state if it does not have a
    TEXT[!MAY,implementation,test]:    validated path on which it can send packets; see Section 8.2
    TEXT[!MAY]: .

  SECTION: [Idle Timeout](#section-10.1)
    TEXT[implementation]:    Each endpoint advertises a max_idle_timeout, but the effective value
    TEXT[implementation]:    at an endpoint is computed as the minimum of the two advertised
    TEXT[implementation]:    values (or the sole advertised value, if only one endpoint advertises
    TEXT[implementation]:    a non-zero value).  By announcing a max_idle_timeout, an endpoint
    TEXT[implementation]:    commits to initiating an immediate close (Section 10.2) if it
    TEXT[implementation]:    abandons the connection prior to the effective value.
    TEXT[implementation]:    An endpoint restarts its idle timer when a packet from its peer is
    TEXT[implementation]:    received and processed successfully.
    TEXT[implementation]: An endpoint also restarts its
    TEXT[implementation]:    idle timer when sending an ack-eliciting packet if no other ack-
    TEXT[implementation]:    eliciting packets have been sent since last receiving and processing
    TEXT[implementation]:    a packet.
    TEXT[!MUST,implementation]:    To avoid excessively small idle timeout periods, endpoints MUST
    TEXT[!MUST,implementation]:    increase the idle timeout period to be at least three times the
    TEXT[!MUST,implementation]:    current Probe Timeout (PTO).
    TEXT[implementation]:   This allows for multiple PTOs to
    TEXT[implementation]:    expire, and therefore multiple probes to be sent and lost, prior to
    TEXT[implementation]:    idle timeout.

  SECTION: [Deferring Idle Timeout](#section-10.1.2)
    TEXT[!SHOULD]:    Application protocols that use QUIC SHOULD provide guidance on when
    TEXT[!SHOULD]:    deferring an idle timeout is appropriate.
    TEXT[implementation]:    A connection will time out if no packets are sent or received for a
    TEXT[implementation]:    period longer than the time negotiated using the max_idle_timeout
    TEXT[implementation]:    transport parameter; see Section 10.  However, state in middleboxes
    TEXT[implementation]:    might time out earlier than that.  Though REQ-5 in [RFC4787]
    TEXT[implementation]:    recommends a 2-minute timeout interval, experience shows that sending
    TEXT[implementation]:    packets every 30 seconds is necessary to prevent the majority of
    TEXT[implementation]:    middleboxes from losing state for UDP flows [GATEWAY].

  SECTION: [Immediate Close](#section-10.2)
    TEXT[implementation]: A CONNECTION_CLOSE frame
    TEXT[implementation]:    causes all streams to immediately become closed; open streams can be
    TEXT[implementation]:    assumed to be implicitly reset.
    TEXT[implementation]:    The closing and draining connection states exist to ensure that
    TEXT[implementation]:    connections close cleanly and that delayed or reordered packets are
    TEXT[implementation]:    properly discarded.
    TEXT[!SHOULD,implementation]: These states SHOULD persist for at least three
    TEXT[!SHOULD,implementation]:    times the current PTO interval as defined in [QUIC-RECOVERY].
    TEXT[!MAY]:    Endpoints that have some alternative means to ensure that late-
    TEXT[!MAY]:    arriving packets do not induce a response, such as those that are
    TEXT[!MAY]:    able to close the UDP socket, MAY end these states earlier to allow
    TEXT[!MAY]:    for faster resource recovery.
    TEXT[!SHOULD]: Servers that retain an open socket for
    TEXT[!SHOULD]:    accepting new connections SHOULD NOT end the closing or draining
    TEXT[!SHOULD]:    state early.
    TEXT[!SHOULD,implementation]:    Once its closing or draining state ends, an endpoint SHOULD discard
    TEXT[!SHOULD,implementation]:    all connection state.
    TEXT[!MAY]: The endpoint MAY send a Stateless Reset in
    TEXT[!MAY]:    response to any further incoming packets belonging to this
    TEXT[!MAY]:    connection.

  SECTION: [Closing Connection State](#section-10.2.1)
    TEXT[implementation]:    An endpoint enters the closing state after initiating an immediate
    TEXT[implementation]:    close.
    TEXT[implementation]:    In the closing state, an endpoint retains only enough information to
    TEXT[implementation]:    generate a packet containing a CONNECTION_CLOSE frame and to identify
    TEXT[implementation]:    packets as belonging to the connection.
    TEXT[implementation]: An endpoint in the closing
    TEXT[implementation]:    state sends a packet containing a CONNECTION_CLOSE frame in response
    TEXT[implementation]:    to any incoming packet that it attributes to the connection.
    TEXT[!SHOULD,implementation]:    An endpoint SHOULD limit the rate at which it generates packets in
    TEXT[!SHOULD,implementation]:    the closing state.
    TEXT[implementation]:   For instance, an endpoint could wait for a
    TEXT[implementation]:    progressively increasing number of received packets or amount of time
    TEXT[implementation]:    before responding to received packets.
    TEXT[!MAY,implementation]:    An endpoint's selected connection ID and the QUIC version are
    TEXT[!MAY,implementation]:    sufficient information to identify packets for a closing connection;
    TEXT[!MAY,implementation]:    the endpoint MAY discard all other connection state.
    TEXT[implementation]: An endpoint
    TEXT[implementation]:    that is closing is not required to process any received frame.
    TEXT[!MAY]: An
    TEXT[!MAY]:    endpoint MAY retain packet protection keys for incoming packets to
    TEXT[!MAY]:    allow it to read and process a CONNECTION_CLOSE frame.
    TEXT[!MAY]:    An endpoint MAY drop packet protection keys when entering the closing
    TEXT[!MAY]:    state and send a packet containing a CONNECTION_CLOSE frame in
    TEXT[!MAY]:    response to any UDP datagram that is received.
    TEXT[!MUST]: To avoid being used for an amplification attack,
    TEXT[!MUST]:    such endpoints MUST limit the cumulative size of packets it sends to
    TEXT[!MUST]:    three times the cumulative size of the packets that are received and
    TEXT[!MUST]:    attributed to the connection.
    TEXT[!MAY]: To minimize the state that an endpoint
    TEXT[!MAY]:    maintains for a closing connection, endpoints MAY send the exact same
    TEXT[!MAY]:    packet in response to any received packet.
    TEXT[implementation]:       |  Note: Allowing retransmission of a closing packet is an
    TEXT[implementation]:       |  exception to the requirement that a new packet number be used
    TEXT[implementation]:       |  for each packet; see Section 12.3.  Sending new packet numbers
    TEXT[implementation]:       |  is primarily of advantage to loss recovery and congestion
    TEXT[implementation]:       |  control, which are not expected to be relevant for a closed
    TEXT[implementation]:       |  connection.  Retransmitting the final packet requires less
    TEXT[implementation]:       |  state.
    TEXT[!MUST,implementation]: An endpoint in the closing state MUST either discard
    TEXT[!MUST,implementation]:    packets received from an unvalidated address or limit the cumulative
    TEXT[!MUST,implementation]:    size of packets it sends to an unvalidated address to three times the
    TEXT[!MUST,implementation]:    size of packets it receives from that address.

  SECTION: [Draining Connection State](#section-10.2.2)
    TEXT[implementation]:    The draining state is entered once an endpoint receives a
    TEXT[implementation]:    CONNECTION_CLOSE frame, which indicates that its peer is closing or
    TEXT[implementation]:    draining.
    TEXT[!MUST,implementation]: While otherwise identical to the closing state, an
    TEXT[!MUST,implementation]:    endpoint in the draining state MUST NOT send any packets.
    TEXT[!MAY]:    An endpoint that receives a CONNECTION_CLOSE frame MAY send a single
    TEXT[!MAY]:    packet containing a CONNECTION_CLOSE frame before entering the
    TEXT[!MAY]:    draining state, using a NO_ERROR code if appropriate.
    TEXT[!MUST]: An endpoint
    TEXT[!MUST]:    MUST NOT send further packets.
    TEXT[!MAY]:    An endpoint MAY enter the draining state from the closing state if it
    TEXT[!MAY]:    receives a CONNECTION_CLOSE frame, which indicates that the peer is
    TEXT[!MAY]:    also closing or draining.

  SECTION: [Immediate Close during the Handshake](#section-10.2.3)
    TEXT[implementation]:    When sending a CONNECTION_CLOSE frame, the goal is to ensure that the
    TEXT[implementation]:    peer will process the frame.  Generally, this means sending the frame
    TEXT[implementation]:    in a packet with the highest level of packet protection to avoid the
    TEXT[implementation]:    packet being discarded.
    TEXT[!MUST,implementation]: After the handshake is confirmed (see
    TEXT[!MUST,implementation]:    Section 4.1.2 of [QUIC-TLS]), an endpoint MUST send any
    TEXT[!MUST,implementation]:    CONNECTION_CLOSE frames in a 1-RTT packet.
    TEXT[!MAY]: However, prior to
    TEXT[!MAY]:    confirming the handshake, it is possible that more advanced packet
    TEXT[!MAY]:    protection keys are not available to the peer, so another
    TEXT[!MAY]:    CONNECTION_CLOSE frame MAY be sent in a packet that uses a lower
    TEXT[!MAY]:    packet protection level.
    TEXT[implementation]: A client will always know whether the server has Handshake keys
    TEXT[implementation]:       (see Section 17.2.2.1), but it is possible that a server does not
    TEXT[implementation]:       know whether the client has Handshake keys.
    TEXT[!SHOULD,implementation]: Under these
    TEXT[!SHOULD,implementation]:       circumstances, a server SHOULD send a CONNECTION_CLOSE frame in
    TEXT[!SHOULD,implementation]:       both Handshake and Initial packets to ensure that at least one of
    TEXT[!SHOULD,implementation]:       them is processable by the client.
    TEXT[!SHOULD]:    *  Prior to confirming the handshake, a peer might be unable to
    TEXT[!SHOULD]:       process 1-RTT packets, so an endpoint SHOULD send a
    TEXT[!SHOULD]:       CONNECTION_CLOSE frame in both Handshake and 1-RTT packets.
    TEXT[!SHOULD]:       server SHOULD also send a CONNECTION_CLOSE frame in an Initial
    TEXT[!SHOULD]:       packet.
    TEXT[implementation]:    Sending a CONNECTION_CLOSE of type 0x1d in an Initial or Handshake
    TEXT[implementation]:    packet could expose application state or be used to alter application
    TEXT[implementation]:    state.
    TEXT[!MUST,implementation]: A CONNECTION_CLOSE of type 0x1d MUST be replaced by a
    TEXT[!MUST,implementation]:    CONNECTION_CLOSE of type 0x1c when sending the frame in Initial or
    TEXT[!MUST,implementation]:    Handshake packets.
    TEXT[implementation]:   Otherwise, information about the application
    TEXT[implementation]:    state might be revealed.
    TEXT[!MUST,implementation]: Endpoints MUST clear the value of the
    TEXT[!MUST,implementation]:    Reason Phrase field and SHOULD use the APPLICATION_ERROR code when
    TEXT[!MUST,implementation]:    converting to a CONNECTION_CLOSE of type 0x1c.
    TEXT[!MAY]: For this
    TEXT[!MAY]:    reason, endpoints MAY discard packets rather than immediately close
    TEXT[!MAY]:    if errors are detected in packets that lack authentication.

  SECTION: [Stateless Reset](#section-10.3)
    TEXT[!MAY,implementation]: An
    TEXT[!MAY,implementation]:    endpoint MAY send a Stateless Reset in response to receiving a packet
    TEXT[!MAY,implementation]:    that it cannot associate with an active connection.
    TEXT[!MUST,implementation]: An endpoint that wishes to communicate a fatal
    TEXT[!MUST,implementation]:    connection error MUST use a CONNECTION_CLOSE frame if it is able.
    TEXT[implementation]: Servers
    TEXT[implementation]:    can also issue a stateless_reset_token transport parameter during the
    TEXT[implementation]:    handshake that applies to the connection ID that it selected during
    TEXT[implementation]:    the handshake.  These exchanges are protected by encryption, so only
    TEXT[implementation]:    client and server know their value.  Note that clients cannot use the
    TEXT[implementation]:    stateless_reset_token transport parameter because their transport
    TEXT[implementation]:    parameters do not have confidentiality protection.
    TEXT[implementation]:    Tokens are invalidated when their associated connection ID is retired
    TEXT[implementation]:    via a RETIRE_CONNECTION_ID frame (Section 19.16).
    TEXT[implementation]:    Stateless Reset {
    TEXT[implementation]:      Fixed Bits (2) = 1,
    TEXT[implementation]:      Unpredictable Bits (38..),
    TEXT[implementation]:      Stateless Reset Token (128),
    TEXT[!SHOULD,implementation,test]: The remainder of the first byte
    TEXT[!SHOULD,implementation,test]:    and an arbitrary number of bytes following it are set to values that
    TEXT[!SHOULD,implementation,test]:    SHOULD be indistinguishable from random.
    TEXT[!SHOULD,implementation]: To achieve that end,
    TEXT[!SHOULD,implementation]:    the endpoint SHOULD ensure that all packets it sends are at least 22
    TEXT[!SHOULD,implementation]:    bytes longer than the minimum connection ID length that it requests
    TEXT[!SHOULD,implementation]:    the peer to include in its packets, adding PADDING frames as
    TEXT[!SHOULD,implementation]:    necessary.
    TEXT[!SHOULD,exception]: An
    TEXT[!SHOULD,exception]:    endpoint that sends a Stateless Reset in response to a packet that is
    TEXT[!SHOULD,exception]:    43 bytes or shorter SHOULD send a Stateless Reset that is one byte
    TEXT[!SHOULD,exception]:    shorter than the packet it responds to.
    TEXT[implementation]:    These values assume that the stateless reset token is the same length
    TEXT[implementation]:    as the minimum expansion of the packet protection AEAD.  Additional
    TEXT[implementation]:    unpredictable bytes are necessary if the endpoint could have
    TEXT[implementation]:    negotiated a packet protection scheme with a larger minimum
    TEXT[implementation]:    expansion.
    TEXT[!MUST,implementation,test]:    An endpoint MUST NOT send a Stateless Reset that is three times or
    TEXT[!MUST,implementation,test]:    more larger than the packet it receives to avoid being used for
    TEXT[!MUST,implementation,test]:    amplification.
    TEXT[!MUST,todo]:    Endpoints MUST discard packets that are too small to be valid QUIC
    TEXT[!MUST,todo]:    packets.
    TEXT[!MUST,implementation,test]:    Endpoints MUST send Stateless Resets formatted as a packet with a
    TEXT[!MUST,implementation,test]:    short header.
    TEXT[!MUST,implementation]: However, endpoints MUST treat any packet ending in a
    TEXT[!MUST,implementation]:    valid stateless reset token as a Stateless Reset, as other QUIC
    TEXT[!MUST,implementation]:    versions might allow the use of a long header.
    TEXT[!MAY,exception]:    An endpoint MAY send a Stateless Reset in response to a packet with a
    TEXT[!MAY,exception]:    long header.
    TEXT[implementation]: Because the stateless reset token is not available
    TEXT[implementation]:    until connection establishment is complete or near completion,
    TEXT[implementation]:    ignoring an unknown packet with a long header might be as effective
    TEXT[implementation]:    as sending a Stateless Reset.

  SECTION: [Detecting a Stateless Reset](#section-10.3.1)
    TEXT[implementation,exception]: The endpoint
    TEXT[implementation,exception]:    identifies a received datagram as a Stateless Reset by comparing the
    TEXT[implementation,exception]:    last 16 bytes of the datagram with all stateless reset tokens
    TEXT[implementation,exception]:    associated with the remote address on which the datagram was
    TEXT[implementation,exception]:    received.
    TEXT[!MAY,implementation]:    Endpoints MAY skip this check if any packet from a datagram is
    TEXT[!MAY,implementation]:    successfully processed.
    TEXT[!MUST,implementation]: However, the comparison MUST be performed
    TEXT[!MUST,implementation]:    when the first packet in an incoming datagram either cannot be
    TEXT[!MUST,implementation]:    associated with a connection or cannot be decrypted.
    TEXT[!MUST,implementation,test]:    An endpoint MUST NOT check for any stateless reset tokens associated
    TEXT[!MUST,implementation,test]:    with connection IDs it has not used or for connection IDs that have
    TEXT[!MUST,implementation,test]:    been retired.
    TEXT[!MUST,implementation,test]:    When comparing a datagram to stateless reset token values, endpoints
    TEXT[!MUST,implementation,test]:    MUST perform the comparison without leaking information about the
    TEXT[!MUST,implementation,test]:    value of the token.
    TEXT[!MUST,implementation]:    If the last 16 bytes of the datagram are identical in value to a
    TEXT[!MUST,implementation]:    stateless reset token, the endpoint MUST enter the draining period
    TEXT[!MUST,implementation]:    and not send any further packets on this connection.

  SECTION: [Calculating a Stateless Reset Token](#section-10.3.2)
    TEXT[!MUST,exception]:    The stateless reset token MUST be difficult to guess.
    TEXT[!MUST,implementation,test]: An endpoint that uses this design MUST
    TEXT[!MUST,implementation,test]:    either use the same connection ID length for all connections or
    TEXT[!MUST,implementation,test]:    encode the length of the connection ID such that it can be recovered
    TEXT[!MUST,implementation,test]:    without state.
    TEXT[!MUST,exception]: This method for
    TEXT[!MUST,exception]:    choosing the stateless reset token means that the combination of
    TEXT[!MUST,exception]:    connection ID and static key MUST NOT be used for another connection.
    TEXT[!MUST,exception]: A connection ID from a connection
    TEXT[!MUST,exception]:    that is reset by revealing the stateless reset token MUST NOT be
    TEXT[!MUST,exception]:    reused for new connections at nodes that share a static key.
    TEXT[!MUST,exception]:    The same stateless reset token MUST NOT be used for multiple
    TEXT[!MUST,exception]:    connection IDs.
    TEXT[!MAY,implementation,test]: Endpoints are not required to compare new values
    TEXT[!MAY,implementation,test]:    against all previous values, but a duplicate value MAY be treated as
    TEXT[!MAY,implementation,test]:    a connection error of type PROTOCOL_VIOLATION.

  SECTION: [Looping](#section-10.3.3)
    TEXT[!MUST,implementation,test]:    An endpoint MUST ensure that every Stateless Reset that it sends is
    TEXT[!MUST,implementation,test]:    smaller than the packet that triggered it, unless it maintains state
    TEXT[!MUST,implementation,test]:    sufficient to prevent looping.

  SECTION: [Error Handling](#section-11)
    TEXT[!SHOULD]:    An endpoint that detects an error SHOULD signal the existence of that
    TEXT[!SHOULD]:    error to its peer.
    TEXT[!SHOULD]:    The most appropriate error code (Section 20) SHOULD be included in
    TEXT[!SHOULD]:    the frame that signals the error.
    TEXT[!MAY]: In particular, an endpoint MAY use any applicable error
    TEXT[!MAY]:    code when it detects an error condition; a generic error code (such
    TEXT[!MAY]:    as PROTOCOL_VIOLATION or INTERNAL_ERROR) can always be used in place
    TEXT[!MAY]:    of specific error codes.
    TEXT[!MUST]:    stateless reset MUST NOT be used by an endpoint that has the state
    TEXT[!MUST]:    necessary to send a frame on the connection.

  SECTION: [Connection Errors](#section-11.1)
    TEXT[!MUST]:    Errors that result in the connection being unusable, such as an
    TEXT[!MUST]:    obvious violation of protocol semantics or corruption of state that
    TEXT[!MUST]:    affects an entire connection, MUST be signaled using a
    TEXT[!MUST]:    CONNECTION_CLOSE frame (Section 19.19).
    TEXT[!SHOULD]: An
    TEXT[!SHOULD]:    endpoint SHOULD be prepared to retransmit a packet containing a
    TEXT[!SHOULD]:    CONNECTION_CLOSE frame if it receives more packets on a terminated
    TEXT[!SHOULD]:    connection.
    TEXT[!MAY]:    As the AEAD for Initial packets does not provide strong
    TEXT[!MAY]:    authentication, an endpoint MAY discard an invalid Initial packet.

  SECTION: [Stream Errors](#section-11.2)
    TEXT[!MUST]: RESET_STREAM MUST only be instigated by the
    TEXT[!MUST]:    application protocol that uses QUIC.
    TEXT[!SHOULD]:    Application protocols SHOULD define rules for handling streams that
    TEXT[!SHOULD]:    are prematurely canceled by either endpoint.

  SECTION: [Coalescing Packets](#section-12.2)
    TEXT[!MUST]: Receivers MUST be able to
    TEXT[!MUST]:    process coalesced packets.
    TEXT[!SHOULD]:    An endpoint SHOULD include multiple frames in a single packet if they
    TEXT[!SHOULD]:    are to be sent at the same encryption level, instead of coalescing
    TEXT[!SHOULD]:    multiple packets at the same encryption level.
    TEXT[!MAY]:    Receivers MAY route based on the information in the first packet
    TEXT[!MAY]:    contained in a UDP datagram.
    TEXT[!MUST,implementation]: Senders MUST NOT coalesce QUIC packets
    TEXT[!MUST,implementation]:    with different connection IDs into a single UDP datagram.
    TEXT[!SHOULD,implementation]: Receivers
    TEXT[!SHOULD,implementation]:    SHOULD ignore any subsequent packets with a different Destination
    TEXT[!SHOULD,implementation]:    Connection ID than the first packet in the datagram.
    TEXT[implementation]:    Every QUIC packet that is coalesced into a single UDP datagram is
    TEXT[implementation]:    separate and complete.
    TEXT[!MUST,implementation]: The receiver of coalesced QUIC packets MUST
    TEXT[!MUST,implementation]:    individually process each QUIC packet and separately acknowledge
    TEXT[!MUST,implementation]:    them, as if they were received as the payload of different UDP
    TEXT[!MUST,implementation]:    datagrams.
    TEXT[!MUST,implementation]: For example, if decryption fails (because the keys are
    TEXT[!MUST,implementation]:    not available or for any other reason), the receiver MAY either
    TEXT[!MUST,implementation]:    discard or buffer the packet for later processing and MUST attempt to
    TEXT[!MUST,implementation]:    process the remaining packets.

  SECTION: [Packet Numbers](#section-12.3)
    TEXT[implementation]:    The packet number is an integer in the range 0 to 2^62-1.  This
    TEXT[implementation]:    number is used in determining the cryptographic nonce for packet
    TEXT[implementation]:    protection.  Each endpoint maintains a separate packet number for
    TEXT[implementation]:    sending and receiving.
    TEXT[implementation]:    Packet numbers are limited to this range because they need to be
    TEXT[implementation]:    representable in whole in the Largest Acknowledged field of an ACK
    TEXT[implementation]:    frame (Section 19.3).  When present in a long or short header,
    TEXT[implementation]:    however, packet numbers are reduced and encoded in 1 to 4 bytes; see
    TEXT[implementation]:    Section 17.1.
    TEXT[implementation]:    Initial space:  All Initial packets (Section 17.2.2) are in this
    TEXT[implementation]:       space.
    TEXT[implementation]:    Handshake space:  All Handshake packets (Section 17.2.4) are in this
    TEXT[implementation]:       space.
    TEXT[implementation]:    Application data space:  All 0-RTT (Section 17.2.3) and 1-RTT
    TEXT[implementation]:       (Section 17.3.1) packets are in this space.
    TEXT[!MUST]: Subsequent packets sent in the same packet
    TEXT[!MUST]:    number space MUST increase the packet number by at least one.
    TEXT[!MUST,implementation]:    A QUIC endpoint MUST NOT reuse a packet number within the same packet
    TEXT[!MUST,implementation]:    number space in one connection.
    TEXT[!MUST,implementation]: If the packet number for sending
    TEXT[!MUST,implementation]:    reaches 2^62-1, the sender MUST close the connection without sending
    TEXT[!MUST,implementation]:    a CONNECTION_CLOSE frame or any further packets; an endpoint MAY send
    TEXT[!MUST,implementation]:    a Stateless Reset (Section 10.3) in response to further packets that
    TEXT[!MUST,implementation]:    it receives.
    TEXT[!MUST]:    A receiver MUST discard a newly unprotected packet unless it is
    TEXT[!MUST]:    certain that it has not processed another packet with the same packet
    TEXT[!MUST]:    number from the same packet number space.
    TEXT[!MUST]: Duplicate suppression MUST
    TEXT[!MUST]:    happen after removing packet protection for the reasons described in
    TEXT[!MUST]:    Section 9.5 of [QUIC-TLS].

  SECTION: [Frames and Frame Types](#section-12.4)
    TEXT[!MUST,implementation]:    The payload of a packet that contains frames MUST contain at least
    TEXT[!MUST,implementation]:    one frame, and MAY contain multiple frames and multiple frame types.
    TEXT[!MUST,implementation]:    An endpoint MUST treat receipt of a packet containing no frames as a
    TEXT[!MUST,implementation]:    connection error of type PROTOCOL_VIOLATION.
    TEXT[!MUST]: An endpoint MUST treat
    TEXT[!MUST]:    receipt of a frame in a packet type that is not permitted as a
    TEXT[!MUST]:    connection error of type PROTOCOL_VIOLATION.
    TEXT[!MUST]:    An endpoint MUST treat the receipt of a frame of unknown type as a
    TEXT[!MUST]:    connection error of type FRAME_ENCODING_ERROR.
    TEXT[!MUST]: To ensure simple and efficient
    TEXT[!MUST]:    implementations of frame parsing, a frame type MUST use the shortest
    TEXT[!MUST]:    possible encoding.
    TEXT[!MAY]: An endpoint MAY treat the
    TEXT[!MAY]:    receipt of a frame type that uses a longer encoding than necessary as
    TEXT[!MAY]:    a connection error of type PROTOCOL_VIOLATION.

  SECTION: [Frames and Number Spaces](#section-12.5)
    TEXT[!MAY]:    *  PADDING, PING, and CRYPTO frames MAY appear in any packet number
    TEXT[!MAY]:       space.
    TEXT[!MAY]:    *  CONNECTION_CLOSE frames signaling errors at the QUIC layer (type
    TEXT[!MAY]:       0x1c) MAY appear in any packet number space.
    TEXT[!MUST]: CONNECTION_CLOSE
    TEXT[!MUST]:       frames signaling application errors (type 0x1d) MUST only appear
    TEXT[!MUST]:       in the application data packet number space.
    TEXT[!MAY]:    *  ACK frames MAY appear in any packet number space but can only
    TEXT[!MAY]:       acknowledge packets that appeared in that packet number space.
    TEXT[!MUST]:    *  All other frame types MUST only be sent in the application data
    TEXT[!MUST]:       packet number space.
    TEXT[!MAY]: A server MAY treat receipt
    TEXT[!MAY]:    of these frames in 0-RTT packets as a connection error of type
    TEXT[!MAY]:    PROTOCOL_VIOLATION.

  SECTION: [Packetization and Reliability](#section-13)
    TEXT[!MAY]: A sender
    TEXT[!MAY]:    MAY wait for a short period of time to collect multiple frames before
    TEXT[!MAY]:    sending a packet that is not maximally packed, to avoid sending out
    TEXT[!MAY]:    large numbers of small packets.
    TEXT[!MAY]: An implementation MAY use knowledge
    TEXT[!MAY]:    about application sending behavior or heuristics to determine whether
    TEXT[!MAY]:    and for how long to wait.

  SECTION: [Packet Processing](#section-13.1)
    TEXT[!MUST,implementation]:    A packet MUST NOT be acknowledged until packet protection has been
    TEXT[!MUST,implementation]:    successfully removed and all frames contained in the packet have been
    TEXT[!MUST,implementation]:    processed.
    TEXT[implementation]:   For STREAM frames, this means the data has been enqueued
    TEXT[implementation]:    in preparation to be received by the application protocol, but it
    TEXT[implementation]:    does not require that data be delivered and consumed.
    TEXT[implementation]:    Once the packet has been fully processed, a receiver acknowledges
    TEXT[implementation]:    receipt by sending one or more ACK frames containing the packet
    TEXT[implementation]:    number of the received packet.
    TEXT[!SHOULD,implementation]:    An endpoint SHOULD treat receipt of an acknowledgment for a packet it
    TEXT[!SHOULD,implementation]:    did not send as a connection error of type PROTOCOL_VIOLATION, if it
    TEXT[!SHOULD,implementation]:    is able to detect the condition.

  SECTION: [Generating Acknowledgments](#section-13.2)
    TEXT[implementation]:    Endpoints acknowledge all packets they receive and process.  However,
    TEXT[implementation]:    only ack-eliciting packets cause an ACK frame to be sent within the
    TEXT[implementation]:    maximum ack delay.  Packets that are not ack-eliciting are only
    TEXT[implementation]:    acknowledged when an ACK frame is sent for other reasons.
    TEXT[!SHOULD,implementation]:    When sending a packet for any reason, an endpoint SHOULD attempt to
    TEXT[!SHOULD,implementation]:    include an ACK frame if one has not been sent recently.
    TEXT[implementation]:   Doing so
    TEXT[implementation]:    helps with timely loss detection at the peer.
    TEXT[implementation]:    In general, frequent feedback from a receiver improves loss and
    TEXT[implementation]:    congestion response, but this has to be balanced against excessive
    TEXT[implementation]:    load generated by a receiver that sends an ACK frame in response to
    TEXT[implementation]:    every ack-eliciting packet.  The guidance offered below seeks to
    TEXT[implementation]:    strike this balance.

  SECTION: [Sending ACK Frames](#section-13.2.1)
    TEXT[!MUST]:    Every packet SHOULD be acknowledged at least once, and ack-eliciting
    TEXT[!MUST]:    packets MUST be acknowledged at least once within the maximum delay
    TEXT[!MUST]:    an endpoint communicated using the max_ack_delay transport parameter;
    TEXT[!MUST]:    see Section 18.2.
    TEXT[!MUST,implementation]:    An endpoint MUST acknowledge all ack-eliciting Initial and Handshake
    TEXT[!MUST,implementation]:    packets immediately
    TEXT[!MUST]:  and all ack-eliciting 0-RTT and 1-RTT packets
    TEXT[!MUST]:    within its advertised max_ack_delay, with the following exception.
    TEXT[!MUST]:    Since packets containing only ACK frames are not congestion
    TEXT[!MUST]:    controlled, an endpoint MUST NOT send more than one such packet in
    TEXT[!MUST]:    response to receiving an ack-eliciting packet.
    TEXT[!MUST]:    An endpoint MUST NOT send a non-ack-eliciting packet in response to a
    TEXT[!MUST]:    non-ack-eliciting packet, even if there are packet gaps that precede
    TEXT[!MUST]:    the received packet.
    TEXT[!SHOULD]: An endpoint SHOULD
    TEXT[!SHOULD]:    send an ACK frame with other frames when there are new ack-eliciting
    TEXT[!SHOULD]:    packets to acknowledge.
    TEXT[!MAY]: When only non-ack-eliciting packets need to
    TEXT[!MAY]:    be acknowledged, an endpoint MAY choose not to send an ACK frame with
    TEXT[!MAY]:    outgoing frames until an ack-eliciting packet has been received.
    TEXT[!MUST]: In
    TEXT[!MUST]:    that case, an endpoint MUST NOT send an ack-eliciting frame in all
    TEXT[!MUST]:    packets that would otherwise be non-ack-eliciting, to avoid an
    TEXT[!MUST]:    infinite feedback loop of acknowledgments.
    TEXT[!SHOULD,implementation]:    In order to assist loss detection at the sender, an endpoint SHOULD
    TEXT[!SHOULD,implementation]:    generate and send an ACK frame without delay when it receives an ack-
    TEXT[!SHOULD,implementation]:    eliciting packet either:
    TEXT[implementation]:    *  when the received packet has a packet number less than another
    TEXT[implementation]:       ack-eliciting packet that has been received, or
    TEXT[implementation]:    *  when the packet has a packet number larger than the highest-
    TEXT[implementation]:       numbered ack-eliciting packet that has been received and there are
    TEXT[implementation]:       missing packets between that packet and this packet.
    TEXT[!SHOULD,implementation]:    Similarly, packets marked with the ECN Congestion Experienced (CE)
    TEXT[!SHOULD,implementation]:    codepoint in the IP header SHOULD be acknowledged immediately, to
    TEXT[!SHOULD,implementation]:    reduce the peer's response time to congestion events.

  SECTION: [Acknowledgment Frequency](#section-13.2.2)
    TEXT[!SHOULD]:    A receiver SHOULD send an ACK frame after receiving at least two ack-
    TEXT[!SHOULD]:    eliciting packets.
    TEXT[!MAY]:    A receiver MAY process multiple available packets before determining
    TEXT[!MAY]:    whether to send an ACK frame in response.

  SECTION: [Managing ACK Ranges](#section-13.2.3)
    TEXT[!SHOULD]:    ACK frames SHOULD always acknowledge the most recently received
    TEXT[!SHOULD]:    packets, and the more out of order the packets are, the more
    TEXT[!SHOULD]:    important it is to send an updated ACK frame quickly, to prevent the
    TEXT[!SHOULD]:    peer from declaring a packet as lost and spuriously retransmitting
    TEXT[!SHOULD]:    the frames it contains.
    TEXT[!SHOULD]: After receiving
    TEXT[!SHOULD]:    acknowledgments for an ACK frame, the receiver SHOULD stop tracking
    TEXT[!SHOULD]:    those acknowledged ACK Ranges.
    TEXT[!MAY]: Receivers MAY also limit ACK
    TEXT[!MAY]:    frame size further to preserve space for other frames or to limit the
    TEXT[!MAY]:    capacity that acknowledgments consume.
    TEXT[!MUST]:    A receiver MUST retain an ACK Range unless it can ensure that it will
    TEXT[!MUST]:    not subsequently accept packets with numbers in that range.
    TEXT[!MUST]:    Receivers can discard all ACK Ranges, but they MUST retain the
    TEXT[!MUST]:    largest packet number that has been successfully processed, as that
    TEXT[!MUST]:    is used to recover packet numbers from subsequent packets; see
    TEXT[!MUST]:    Section 17.1.
    TEXT[!SHOULD]:    A receiver SHOULD include an ACK Range containing the largest
    TEXT[!SHOULD]:    received packet number in every ACK frame.

  SECTION: [Limiting Ranges by Tracking ACK Frames](#section-13.2.4)
    TEXT[implementation]:    When a packet containing an ACK frame is sent, the Largest
    TEXT[implementation]:    Acknowledged field in that frame can be saved.
    TEXT[implementation]: When a packet
    TEXT[implementation]:    containing an ACK frame is acknowledged, the receiver can stop
    TEXT[implementation]:    acknowledging packets less than or equal to the Largest Acknowledged
    TEXT[implementation]:    field in the sent ACK frame.
    TEXT[implementation]:    A receiver that sends only non-ack-eliciting packets, such as ACK
    TEXT[implementation]:    frames, might not receive an acknowledgment for a long period of
    TEXT[implementation]:    time.  This could cause the receiver to maintain state for a large
    TEXT[implementation]:    number of ACK frames for a long period of time, and ACK frames it
    TEXT[implementation]:    sends could be unnecessarily large.  In such a case, a receiver could
    TEXT[implementation]:    send a PING or other small ack-eliciting frame occasionally, such as
    TEXT[implementation]:    once per round trip, to elicit an ACK from the peer.

  SECTION: [Measuring and Reporting Host Delay](#section-13.2.5)
    TEXT[implementation]:    An endpoint measures the delays intentionally introduced between the
    TEXT[implementation]:    time the packet with the largest packet number is received and the
    TEXT[implementation]:    time an acknowledgment is sent.  The endpoint encodes this
    TEXT[implementation]:    acknowledgment delay in the ACK Delay field of an ACK frame; see
    TEXT[implementation]:    Section 19.3.  This allows the receiver of the ACK frame to adjust
    TEXT[implementation]:    for any intentional delays, which is important for getting a better
    TEXT[implementation]:    estimate of the path RTT when acknowledgments are delayed.
    TEXT[!MUST]: An endpoint MUST NOT include delays that it
    TEXT[!MUST]:    does not control when populating the ACK Delay field in an ACK frame.
    TEXT[!SHOULD]:    However, endpoints SHOULD include buffering delays caused by
    TEXT[!SHOULD]:    unavailability of decryption keys, since these delays can be large
    TEXT[!SHOULD]:    and are likely to be non-repeating.
    TEXT[!SHOULD]:    When the measured acknowledgment delay is larger than its
    TEXT[!SHOULD]:    max_ack_delay, an endpoint SHOULD report the measured delay.

  SECTION: [ACK Frames and Packet Protection](#section-13.2.6)
    TEXT[!MUST]:    ACK frames MUST only be carried in a packet that has the same packet
    TEXT[!MUST]:    number space as the packet being acknowledged; see Section 12.1.
    TEXT[!MUST]: For
    TEXT[!MUST]:    instance, packets that are protected with 1-RTT keys MUST be
    TEXT[!MUST]:    acknowledged in packets that are also protected with 1-RTT keys.
    TEXT[!MUST]:    Packets that a client sends with 0-RTT packet protection MUST be
    TEXT[!MUST]:    acknowledged by the server in packets protected by 1-RTT keys.

  SECTION: [PADDING Frames Consume Congestion Window](#section-13.2.7)
    TEXT[!SHOULD]: To
    TEXT[!SHOULD]:    avoid a deadlock, a sender SHOULD ensure that other frames are sent
    TEXT[!SHOULD]:    periodically in addition to PADDING frames to elicit acknowledgments
    TEXT[!SHOULD]:    from the receiver.

  SECTION: [Retransmission of Information](#section-13.3)
    TEXT[!MUST]:       The content of a RESET_STREAM frame MUST NOT change when it is
    TEXT[!MUST]:       sent again.
    TEXT[!SHOULD]: An endpoint SHOULD stop sending
    TEXT[!SHOULD]:       MAX_STREAM_DATA frames when the receiving part of the stream
    TEXT[!SHOULD]:       enters a "Size Known" or "Reset Recvd" state.
    TEXT[!MUST]:    *
    TEXT[!MUST,implementation,test]: The HANDSHAKE_DONE frame MUST be retransmitted until it is
    TEXT[!MUST,implementation,test]:       acknowledged.
    TEXT[!SHOULD]:    Endpoints SHOULD prioritize retransmission of data over sending new
    TEXT[!SHOULD]:    data, unless priorities specified by the application indicate
    TEXT[!SHOULD]:    otherwise; see Section 2.3.
    TEXT[!MUST]: A receiver MUST accept packets containing an
    TEXT[!MUST]:    outdated frame, such as a MAX_DATA frame carrying a smaller maximum
    TEXT[!MUST]:    data value than one found in an older packet.
    TEXT[!SHOULD]:    A sender SHOULD avoid retransmitting information from packets once
    TEXT[!SHOULD]:    they are acknowledged.
    TEXT[!MUST]:    Upon detecting losses, a sender MUST take appropriate congestion
    TEXT[!MUST]:    control action.

  SECTION: [Reporting ECN Counts](#section-13.4.1)
    TEXT[!MUST,implementation]:    Even if an endpoint does not set an ECT field in packets it sends,
    TEXT[!MUST,implementation]:    the endpoint MUST provide feedback about ECN markings it receives, if
    TEXT[!MUST,implementation]:    these are accessible.
    TEXT[implementation]:    ECN counts are only incremented when QUIC packets from the received
    TEXT[implementation]:    IP packet are processed.  As such, duplicate QUIC packets are not
    TEXT[implementation]:    processed and do not increase ECN counts; see Section 21.10 for
    TEXT[implementation]:    relevant security concerns.

  SECTION: [ECN Validation](#section-13.4.2)
    TEXT[implementation]:    If an endpoint has cause to expect that IP packets with an ECT
    TEXT[implementation]:    codepoint might be dropped by a faulty network element, the endpoint
    TEXT[implementation]:    could set an ECT codepoint for only the first ten outgoing packets on
    TEXT[implementation]:    a path, or for a period of three PTOs
    TEXT[!MAY]: Implementations MAY use other methods
    TEXT[!MAY]:    defined in RFCs; see [RFC8311].

  SECTION: [Receiving ACK Frames with ECN Counts](#section-13.4.2.1)
    TEXT[implementation,test]:    If an ACK frame newly acknowledges a packet that the endpoint sent
    TEXT[implementation,test]:    with either the ECT(0) or ECT(1) codepoint set, ECN validation fails
    TEXT[implementation,test]:    if the corresponding ECN counts are not present in the ACK frame.
    TEXT[implementation,test]:    This check detects a network element that zeroes the ECN field or a
    TEXT[implementation,test]:    peer that does not report ECN markings.
    TEXT[implementation,test]:    ECN validation also fails if the sum of the increase in ECT(0) and
    TEXT[implementation,test]:    ECN-CE counts is less than the number of newly acknowledged packets
    TEXT[implementation,test]:    that were originally sent with an ECT(0) marking.
    TEXT[implementation,test]:    Validating ECN counts from reordered ACK frames can result in
    TEXT[implementation,test]:    failure.
    TEXT[!MUST,implementation,test]: An endpoint MUST NOT fail ECN validation as a result of
    TEXT[!MUST,implementation,test]:    processing an ACK frame that does not increase the largest
    TEXT[!MUST,implementation,test]:    acknowledged packet number.
    TEXT[implementation,test]:    ECN validation can fail if the received total count for either ECT(0)
    TEXT[implementation,test]:    or ECT(1) exceeds the total number of packets sent with each
    TEXT[implementation,test]:    corresponding ECT codepoint.

  SECTION: [ECN Validation Outcomes](#section-13.4.2.2)
    TEXT[!MUST,implementation,test]:    If validation fails, then the endpoint MUST disable ECN.
    TEXT[implementation,test]:   It stops
    TEXT[implementation,test]:    setting the ECT codepoint in IP packets that it sends, assuming that
    TEXT[implementation,test]:    either the network path or the peer does not support ECN.
    TEXT[!MAY,implementation]:    Even if validation fails, an endpoint MAY revalidate ECN for the same
    TEXT[!MAY,implementation]:    path at any later time in the connection.
    TEXT[implementation]:   An endpoint could continue
    TEXT[implementation]:    to periodically attempt validation.
    TEXT[!MAY,implementation,test]:    Upon successful validation, an endpoint MAY continue to set an ECT
    TEXT[!MAY,implementation,test]:    codepoint in subsequent packets it sends, with the expectation that
    TEXT[!MAY,implementation,test]:    the path is ECN capable.
    TEXT[!MUST,implementation]: Network routing and path elements can
    TEXT[!MUST,implementation]:    change mid-connection; an endpoint MUST disable ECN if validation
    TEXT[!MUST,implementation]:    later fails.

  SECTION: [Datagram Size](#section-14)
    TEXT[!MUST,implementation]: QUIC MUST NOT be used if the network path cannot support a
    TEXT[!MUST,implementation]:    maximum datagram size of at least 1200 bytes.
    TEXT[!MUST,implementation]:    UDP datagrams MUST NOT be fragmented at the IP layer.
    TEXT[!MUST,implementation]: In IPv4
    TEXT[!MUST,implementation]:    [IPv4], the Don't Fragment (DF) bit MUST be set if possible, to
    TEXT[!MUST,implementation]:    prevent fragmentation on the path.
    TEXT[!MUST]: Therefore, an endpoint MUST NOT close a connection
    TEXT[!MUST]:    when it receives a datagram that does not meet size constraints; the
    TEXT[!MUST]:    endpoint MAY discard such datagrams.

  SECTION: [Initial Datagram Size](#section-14.1)
    TEXT[!MUST,implementation]:    A client MUST expand the payload of all UDP datagrams carrying
    TEXT[!MUST,implementation]:    Initial packets to at least the smallest allowed maximum datagram
    TEXT[!MUST,implementation]:    size of 1200 bytes by adding PADDING frames to the Initial packet or
    TEXT[!MUST,implementation]:    by coalescing the Initial packet; see Section 12.2.
    TEXT[!MUST,implementation]: Similarly, a server MUST expand the payload of all UDP
    TEXT[!MUST,implementation]:    datagrams carrying ack-eliciting Initial packets to at least the
    TEXT[!MUST,implementation]:    smallest allowed maximum datagram size of 1200 bytes.
    TEXT[!MAY,implementation,test]:    Datagrams containing Initial packets MAY exceed 1200 bytes if the
    TEXT[!MAY,implementation,test]:    sender believes that the network path and peer both support the size
    TEXT[!MAY,implementation,test]:    that it chooses.
    TEXT[!MUST,implementation]:    A server MUST discard an Initial packet that is carried in a UDP
    TEXT[!MUST,implementation]:    datagram with a payload that is smaller than the smallest allowed
    TEXT[!MUST,implementation]:    maximum datagram size of 1200 bytes.
    TEXT[!MAY,exception]: A server MAY also immediately
    TEXT[!MAY,exception]:    close the connection by sending a CONNECTION_CLOSE frame with an
    TEXT[!MAY,exception]:    error code of PROTOCOL_VIOLATION; see Section 10.2.3.
    TEXT[!MUST,implementation,test]:    The server MUST also limit the number of bytes it sends before
    TEXT[!MUST,implementation,test]:    validating the address of the client; see Section 8.

  SECTION: [Path Maximum Transmission Unit](#section-14.2)
    TEXT[!SHOULD]:    An endpoint SHOULD use DPLPMTUD (Section 14.3) or PMTUD
    TEXT[!SHOULD]:    (Section 14.2.1) to determine whether the path to a destination will
    TEXT[!SHOULD]:    support a desired maximum datagram size without fragmentation.
    TEXT[!SHOULD]: In
    TEXT[!SHOULD]:    the absence of these mechanisms, QUIC endpoints SHOULD NOT send
    TEXT[!SHOULD]:    datagrams larger than the smallest allowed maximum datagram size.
    TEXT[!SHOULD,implementation,test]: All QUIC
    TEXT[!SHOULD,implementation,test]:    packets that are not sent in a PMTU probe SHOULD be sized to fit
    TEXT[!SHOULD,implementation,test]:    within the maximum datagram size to avoid the datagram being
    TEXT[!SHOULD,implementation,test]:    fragmented or dropped [RFC8085].
    TEXT[!MUST]:    If a QUIC endpoint determines that the PMTU between any pair of local
    TEXT[!MUST]:    and remote IP addresses cannot support the smallest allowed maximum
    TEXT[!MUST]:    datagram size of 1200 bytes, it MUST immediately cease sending QUIC
    TEXT[!MUST]:    packets, except for those in PMTU probes or those containing
    TEXT[!MUST]:    CONNECTION_CLOSE frames, on the affected path.
    TEXT[!MAY]: An endpoint MAY
    TEXT[!MAY]:    terminate the connection if an alternative path cannot be found.
    TEXT[!SHOULD]:    QUIC implementations that implement any kind of PMTU discovery
    TEXT[!SHOULD]:    therefore SHOULD maintain a maximum datagram size for each
    TEXT[!SHOULD]:    combination of local and remote IP addresses.
    TEXT[!MAY]:    A QUIC implementation MAY be more conservative in computing the
    TEXT[!MAY]:    maximum datagram size to allow for unknown tunnel overheads or IP
    TEXT[!MAY]:    header options/extensions.

  SECTION: [Handling of ICMP Messages by PMTUD](#section-14.2.1)
    TEXT[!MUST,todo]:    An endpoint MUST ignore an ICMP message that claims the PMTU has
    TEXT[!MUST,todo]:    decreased below QUIC's smallest allowed maximum datagram size.
    TEXT[!SHOULD,todo]:    QUIC endpoints using PMTUD SHOULD validate ICMP messages to protect
    TEXT[!SHOULD,todo]:    from packet injection as specified in [RFC8201] and Section 5.2 of
    TEXT[!SHOULD,todo]:    [RFC8085].
    TEXT[!SHOULD,todo]: This validation SHOULD use the quoted packet supplied in
    TEXT[!SHOULD,todo]:    the payload of an ICMP message to associate the message with a
    TEXT[!SHOULD,todo]:    corresponding transport connection (see Section 4.6.1 of [DPLPMTUD]).
    TEXT[!MUST,todo]:    ICMP message validation MUST include matching IP addresses and UDP
    TEXT[!MUST,todo]:    ports [RFC8085] and, when possible, connection IDs to an active QUIC
    TEXT[!MUST,todo]:    session.
    TEXT[!SHOULD,todo]: The endpoint SHOULD ignore all ICMP messages that fail
    TEXT[!SHOULD,todo]:    validation.
    TEXT[!MUST,todo]:    An endpoint MUST NOT increase the PMTU based on ICMP messages; see
    TEXT[!MUST,todo]:    Item 6 in Section 3 of [DPLPMTUD].
    TEXT[!MAY,todo]: Any reduction in QUIC's maximum
    TEXT[!MAY,todo]:    datagram size in response to ICMP messages MAY be provisional until
    TEXT[!MAY,todo]:    QUIC's loss detection algorithm determines that the quoted packet has
    TEXT[!MAY,todo]:    actually been lost.

  SECTION: [Datagram Packetization Layer PMTU Discovery](#section-14.3)
    TEXT[!SHOULD,implementation]:    Endpoints SHOULD set the initial value of BASE_PLPMTU (Section 5.1 of
    TEXT[!SHOULD,implementation]:    [DPLPMTUD]) to be consistent with QUIC's smallest allowed maximum
    TEXT[!SHOULD,implementation]:    datagram size.

  SECTION: [Sending QUIC PMTU Probes](#section-14.4)
    TEXT[implementation,test]:    Endpoints could limit the content of PMTU probes to PING and PADDING
    TEXT[implementation,test]:    frames, since packets that are larger than the current maximum
    TEXT[implementation,test]:    datagram size are more likely to be dropped by the network.
    TEXT[!SHOULD,implementation,test]: Loss of
    TEXT[!SHOULD,implementation,test]:    a QUIC packet that is carried in a PMTU probe is therefore not a
    TEXT[!SHOULD,implementation,test]:    reliable indication of congestion and SHOULD NOT trigger a congestion
    TEXT[!SHOULD,implementation,test]:    control reaction; see Item 7 in Section 3 of [DPLPMTUD].

  SECTION: [Versions](#section-15)
    TEXT[implementation]:    This version of the specification is identified by the number
    TEXT[implementation]:    0x00000001.
    TEXT[!MAY]:    client or server MAY advertise support for any of these reserved
    TEXT[!MAY]:    versions.
    TEXT[!MAY]:    Reserved version numbers will never represent a real protocol; a
    TEXT[!MAY]:    client MAY use one of these version numbers with the expectation that
    TEXT[!MAY]:    the server will initiate version negotiation; a server MAY advertise
    TEXT[!MAY]:    support for one of these versions and can expect that clients ignore
    TEXT[!MAY]:    the value.

  SECTION: [Variable-Length Integer Encoding](#section-16)
    TEXT[implementation]:    QUIC packets and frames commonly use a variable-length encoding for
    TEXT[implementation]:    non-negative integer values.  This encoding ensures that smaller
    TEXT[implementation]:    integer values need fewer bytes to encode.
    TEXT[implementation,test]:    This means that integers are encoded on 1, 2, 4, or 8 bytes and can
    TEXT[implementation,test]:    encode 6-, 14-, 30-, or 62-bit values, respectively.  Table 4
    TEXT[implementation,test]:    summarizes the encoding properties.
    TEXT[implementation,test]:           +======+========+=============+=======================+
    TEXT[implementation,test]:           | 2MSB | Length | Usable Bits | Range                 |
    TEXT[implementation,test]:           +======+========+=============+=======================+
    TEXT[implementation,test]:           | 00   | 1      | 6           | 0-63                  |
    TEXT[implementation,test]:           +------+--------+-------------+-----------------------+
    TEXT[implementation,test]:           | 01   | 2      | 14          | 0-16383               |
    TEXT[implementation,test]:           +------+--------+-------------+-----------------------+
    TEXT[implementation,test]:           | 10   | 4      | 30          | 0-1073741823          |
    TEXT[implementation,test]:           +------+--------+-------------+-----------------------+
    TEXT[implementation,test]:           | 11   | 8      | 62          | 0-4611686018427387903 |
    TEXT[implementation,test]:           +------+--------+-------------+-----------------------+

  SECTION: [Packet Number Encoding and Decoding](#section-17.1)
    TEXT[implementation]:    Packet numbers are integers in the range 0 to 2^62-1 (Section 12.3).
    TEXT[implementation]:    When present in long or short packet headers, they are encoded in 1
    TEXT[implementation]:    to 4 bytes.  The number of bits required to represent the packet
    TEXT[implementation]:    number is reduced by including only the least significant bits of the
    TEXT[implementation]:    packet number.
    TEXT[!MUST]:    Prior to receiving an acknowledgment for a packet number space, the
    TEXT[!MUST]:    full packet number MUST be included; it is not to be truncated, as
    TEXT[!MUST]:    described below.
    TEXT[!MUST]:    After an acknowledgment is received for a packet number space,
    TEXT[!MUST,implementation]: the
    TEXT[!MUST,implementation]:    sender MUST use a packet number size able to represent more than
    TEXT[!MUST,implementation]:    twice as large a range as the difference between the largest
    TEXT[!MUST,implementation]:    acknowledged packet number and the packet number being sent.
    TEXT[implementation]:   A peer
    TEXT[implementation]:    receiving the packet will then correctly decode the packet number,
    TEXT[implementation]:    unless the packet is delayed in transit such that it arrives after
    TEXT[implementation]:    many higher-numbered packets have been received.
    TEXT[!SHOULD,implementation]: An endpoint SHOULD
    TEXT[!SHOULD,implementation]:    use a large enough packet number encoding to allow the packet number
    TEXT[!SHOULD,implementation]:    to be recovered even if the packet arrives after packets that are
    TEXT[!SHOULD,implementation]:    sent afterwards.
    TEXT[implementation]:    As a result, the size of the packet number encoding is at least one
    TEXT[implementation]:    bit more than the base-2 logarithm of the number of contiguous
    TEXT[implementation]:    unacknowledged packet numbers, including the new packet.
    TEXT[implementation]:    At a receiver, protection of the packet number is removed prior to
    TEXT[implementation]:    recovering the full packet number.  The full packet number is then
    TEXT[implementation]:    reconstructed based on the number of significant bits present, the
    TEXT[implementation]:    value of those bits, and the largest packet number received in a
    TEXT[implementation]:    successfully authenticated packet.  Recovering the full packet number
    TEXT[implementation]:    is necessary to successfully complete the removal of packet
    TEXT[implementation]:    protection.

  SECTION: [Long Header Packets](#section-17.2)
    TEXT[implementation]:    Long Header Packet {
    TEXT[implementation]:      Header Form (1) = 1,
    TEXT[implementation]:      Fixed Bit (1) = 1,
    TEXT[implementation]:      Long Packet Type (2),
    TEXT[implementation]:      Type-Specific Bits (4),
    TEXT[implementation]:      Version (32),
    TEXT[implementation]:      Destination Connection ID Length (8),
    TEXT[implementation]:      Destination Connection ID (0..160),
    TEXT[implementation]:      Source Connection ID Length (8),
    TEXT[implementation]:      Source Connection ID (0..160),
    TEXT[implementation]:    Header Form:  The most significant bit (0x80) of byte 0 (the first
    TEXT[implementation]:       byte) is set to 1 for long headers.
    TEXT[implementation]:    Fixed Bit:  The next bit (0x40) of byte 0 is set to 1,
    TEXT[!MUST]: Packets containing a zero
    TEXT[!MUST]:       value for this bit are not valid packets in this version and MUST
    TEXT[!MUST]:       be discarded.
    TEXT[implementation]:    Long Packet Type:  The next two bits (those with a mask of 0x30) of
    TEXT[implementation]:       byte 0 contain a packet type.  Packet types are listed in Table 5.
    TEXT[implementation]:    Type-Specific Bits:  The semantics of the lower four bits (those with
    TEXT[implementation]:       a mask of 0x0f) of byte 0 are determined by the packet type.
    TEXT[implementation]:    Version:  The QUIC Version is a 32-bit field that follows the first
    TEXT[implementation]:       byte.  This field indicates the version of QUIC that is in use and
    TEXT[implementation]:       determines how the rest of the protocol fields are interpreted.
    TEXT[implementation]:    Destination Connection ID Length:  The byte following the version
    TEXT[implementation]:       contains the length in bytes of the Destination Connection ID
    TEXT[implementation]:       field that follows it.  This length is encoded as an 8-bit
    TEXT[implementation]:       unsigned integer.
    TEXT[!MUST,implementation]: In QUIC version 1, this value MUST NOT exceed
    TEXT[!MUST,implementation]:       20
    TEXT[!MUST]:  bytes.
    TEXT[!MUST,implementation]: Endpoints that receive a version 1 long header with a
    TEXT[!MUST,implementation]:       value larger than 20 MUST drop the packet.
    TEXT[!SHOULD,implementation]: In order to properly
    TEXT[!SHOULD,implementation]:       form a Version Negotiation packet, servers SHOULD be able to read
    TEXT[!SHOULD,implementation]:       longer connection IDs from other QUIC versions.
    TEXT[implementation]:    Destination Connection ID:  The Destination Connection ID field
    TEXT[implementation]:       follows the Destination Connection ID Length field, which
    TEXT[implementation]:       indicates the length of this field.  Section 7.2 describes the use
    TEXT[implementation]:       of this field in more detail.
    TEXT[implementation]:    Source Connection ID Length:  The byte following the Destination
    TEXT[implementation]:       Connection ID contains the length in bytes of the Source
    TEXT[implementation]:       Connection ID field that follows it.  This length is encoded as an
    TEXT[implementation]:       8-bit unsigned integer.  In QUIC version 1, this value MUST NOT
    TEXT[implementation]:       exceed 20 bytes.
    TEXT[implementation]:    Source Connection ID:  The Source Connection ID field follows the
    TEXT[implementation]:       Source Connection ID Length field, which indicates the length of
    TEXT[implementation]:       this field.  Section 7.2 describes the use of this field in more
    TEXT[implementation]:       detail.
    TEXT[implementation]:    In this version of QUIC, the following packet types with the long
    TEXT[implementation]:    header are defined:
    TEXT[implementation]:                    +======+===========+================+
    TEXT[implementation]:                    | Type | Name      | Section        |
    TEXT[implementation]:                    +======+===========+================+
    TEXT[implementation]:                    | 0x00 | Initial   | Section 17.2.2 |
    TEXT[implementation]:                    +------+-----------+----------------+
    TEXT[implementation]:                    | 0x01 | 0-RTT     | Section 17.2.3 |
    TEXT[implementation]:                    +------+-----------+----------------+
    TEXT[implementation]:                    | 0x02 | Handshake | Section 17.2.4 |
    TEXT[implementation]:                    +------+-----------+----------------+
    TEXT[implementation]:                    | 0x03 | Retry     | Section 17.2.5 |
    TEXT[implementation]:                    +------+-----------+----------------+
    TEXT[implementation]:                      Table 5: Long Header Packet Types
    TEXT[implementation]:    Reserved Bits:  Two bits (those with a mask of 0x0c) of byte 0 are
    TEXT[implementation]:       reserved across multiple packet types.  These bits are protected
    TEXT[implementation]:       using header protection; see Section 5.4 of [QUIC-TLS].
    TEXT[!MUST,implementation]: The value
    TEXT[!MUST,implementation]:       included prior to protection MUST be set to 0.
    TEXT[!MUST,implementation]: An endpoint MUST
    TEXT[!MUST,implementation]:       treat receipt of a packet that has a non-zero value for these bits
    TEXT[!MUST,implementation]:       after removing both packet and header protection as a connection
    TEXT[!MUST,implementation]:       error of type PROTOCOL_VIOLATION.
    TEXT[implementation]:    Packet Number Length:  In packet types that contain a Packet Number
    TEXT[implementation]:       field, the least significant two bits (those with a mask of 0x03)
    TEXT[implementation]:       of byte 0 contain the length of the Packet Number field, encoded
    TEXT[implementation]:       as an unsigned two-bit integer that is one less than the length of
    TEXT[implementation]:       the Packet Number field in bytes.
    TEXT[implementation]:    Length:  This is the length of the remainder of the packet (that is,
    TEXT[implementation]:       the Packet Number and Payload fields) in bytes, encoded as a
    TEXT[implementation]:       variable-length integer (Section 16).
    TEXT[implementation]:    Packet Number:  This field is 1 to 4 bytes long.  The packet number
    TEXT[implementation]:       is protected using header protection; see Section 5.4 of
    TEXT[implementation]:       [QUIC-TLS].  The length of the Packet Number field is encoded in
    TEXT[implementation]:       the Packet Number Length bits of byte 0; see above.

  SECTION: [Version Negotiation Packet](#section-17.2.1)
    TEXT[implementation]:    Version Negotiation Packet {
    TEXT[implementation]:      Header Form (1) = 1,
    TEXT[implementation]:      Unused (7),
    TEXT[implementation]:      Version (32) = 0,
    TEXT[implementation]:      Destination Connection ID Length (8),
    TEXT[implementation]:      Destination Connection ID (0..2040),
    TEXT[implementation]:      Source Connection ID Length (8),
    TEXT[implementation]:      Source Connection ID (0..2040),
    TEXT[implementation]:      Supported Version (32) ...,
    TEXT[implementation]:    The value in the Unused field is set to an arbitrary value by the
    TEXT[implementation]:    server.
    TEXT[!MUST,implementation]: Clients MUST ignore the value of this field.
    TEXT[!SHOULD,implementation]: Where QUIC
    TEXT[!SHOULD,implementation]:    might be multiplexed with other protocols (see [RFC7983]), servers
    TEXT[!SHOULD,implementation]:    SHOULD set the most significant bit of this field (0x40) to 1 so that
    TEXT[!SHOULD,implementation]:    Version Negotiation packets appear to have the Fixed Bit field.
    TEXT[!MUST,implementation]:    The Version field of a Version Negotiation packet MUST be set to
    TEXT[!MUST,implementation]:    0x00000000.
    TEXT[!MUST,implementation]:    The server MUST include the value from the Source Connection ID field
    TEXT[!MUST,implementation]:    of the packet it receives in the Destination Connection ID field.
    TEXT[!MUST,implementation]:    The value for Source Connection ID MUST be copied from the
    TEXT[!MUST,implementation]:    Destination Connection ID of the received packet, which is initially
    TEXT[!MUST,implementation]:    randomly selected by a client.
    TEXT[!MUST]: Version-
    TEXT[!MUST]:    specific rules for the connection ID therefore MUST NOT influence a
    TEXT[!MUST]:    decision about whether to send a Version Negotiation packet.
    TEXT[!MUST]:    A server MUST NOT send more than one Version Negotiation packet in
    TEXT[!MUST]:    response to a single UDP datagram.

  SECTION: [Initial Packet](#section-17.2.2)
    TEXT[implementation]:    An Initial packet uses long headers with a type value of 0x00.
    TEXT[implementation]:    Initial Packet {
    TEXT[implementation]:      Header Form (1) = 1,
    TEXT[implementation]:      Fixed Bit (1) = 1,
    TEXT[implementation]:      Long Packet Type (2) = 0,
    TEXT[implementation]:      Reserved Bits (2),
    TEXT[implementation]:      Packet Number Length (2),
    TEXT[implementation]:      Version (32),
    TEXT[implementation]:      Destination Connection ID Length (8),
    TEXT[implementation]:      Destination Connection ID (0..160),
    TEXT[implementation]:      Source Connection ID Length (8),
    TEXT[implementation]:      Source Connection ID (0..160),
    TEXT[implementation]:      Token Length (i),
    TEXT[implementation]:      Token (..),
    TEXT[implementation]:      Length (i),
    TEXT[implementation]:      Packet Number (8..32),
    TEXT[implementation]:      Packet Payload (8..),
    TEXT[implementation]:    Token Length:  A variable-length integer specifying the length of the
    TEXT[implementation]:       Token field, in bytes.  This value is 0 if no token is present.
    TEXT[!MUST,implementation]:       Initial packets sent by the server MUST set the Token Length field
    TEXT[!MUST,implementation]:       to 0; clients that receive an Initial packet with a non-zero Token
    TEXT[!MUST,implementation]:       Length field MUST either discard the packet or generate a
    TEXT[!MUST,implementation]:       connection error of type PROTOCOL_VIOLATION.
    TEXT[implementation]:    Token:  The value of the token that was previously provided in a
    TEXT[implementation]:       Retry packet or NEW_TOKEN frame; see Section 8.1.
    TEXT[!MAY]: A server MAY send multiple Initial packets.
    TEXT[implementation]:    The payload of an Initial packet includes a CRYPTO frame (or frames)
    TEXT[implementation]:    containing a cryptographic handshake message, ACK frames, or both.
    TEXT[implementation]:    PING, PADDING, and CONNECTION_CLOSE frames of type 0x1c are also
    TEXT[implementation]:    permitted.  An endpoint that receives an Initial packet containing
    TEXT[implementation]:    other frames can either discard the packet as spurious or treat it as
    TEXT[implementation]:    a connection error.

  SECTION: [0-RTT](#section-17.2.3)
    TEXT[implementation]:    A 0-RTT packet uses long headers with a type value of 0x01,
    TEXT[implementation]:    0-RTT Packet {
    TEXT[implementation]:      Header Form (1) = 1,
    TEXT[implementation]:      Fixed Bit (1) = 1,
    TEXT[implementation]:      Long Packet Type (2) = 1,
    TEXT[implementation]:      Reserved Bits (2),
    TEXT[implementation]:      Packet Number Length (2),
    TEXT[implementation]:      Version (32),
    TEXT[implementation]:      Destination Connection ID Length (8),
    TEXT[implementation]:      Destination Connection ID (0..160),
    TEXT[implementation]:      Source Connection ID Length (8),
    TEXT[implementation]:      Source Connection ID (0..160),
    TEXT[implementation]:      Length (i),
    TEXT[implementation]:      Packet Number (8..32),
    TEXT[implementation]:      Packet Payload (8..),
    TEXT[!SHOULD]: A client SHOULD attempt
    TEXT[!SHOULD]:    to resend data in 0-RTT packets after it sends a new Initial packet.
    TEXT[!MUST]:    New packet numbers MUST be used for any new packets that are sent; as
    TEXT[!MUST]:    described in Section 17.2.5.3, reusing packet numbers could
    TEXT[!MUST]:    compromise packet protection.
    TEXT[!MUST]:    A client MUST NOT send 0-RTT packets once it starts processing 1-RTT
    TEXT[!MUST]:    packets from the server.
    TEXT[!MUST]: An acknowledgment for a 1-RTT
    TEXT[!MUST]:    packet MUST be carried in a 1-RTT packet.
    TEXT[!SHOULD]:    A server SHOULD treat a violation of remembered limits
    TEXT[!SHOULD]:    (Section 7.4.1) as a connection error of an appropriate type (for
    TEXT[!SHOULD]:    instance, a FLOW_CONTROL_ERROR for exceeding stream data limits).

  SECTION: [Handshake Packet](#section-17.2.4)
    TEXT[implementation]:    A Handshake packet uses long headers with a type value of 0x02
    TEXT[implementation]:    Handshake Packet {
    TEXT[implementation]:      Header Form (1) = 1,
    TEXT[implementation]:      Fixed Bit (1) = 1,
    TEXT[implementation]:      Long Packet Type (2) = 2,
    TEXT[implementation]:      Reserved Bits (2),
    TEXT[implementation]:      Packet Number Length (2),
    TEXT[implementation]:      Version (32),
    TEXT[implementation]:      Destination Connection ID Length (8),
    TEXT[implementation]:      Destination Connection ID (0..160),
    TEXT[implementation]:      Source Connection ID Length (8),
    TEXT[implementation]:      Source Connection ID (0..160),
    TEXT[implementation]:      Length (i),
    TEXT[implementation]:      Packet Number (8..32),
    TEXT[implementation]:      Packet Payload (8..),
    TEXT[implementation]:    The payload of this packet contains CRYPTO frames and could contain
    TEXT[implementation]:    PING, PADDING, or ACK frames.
    TEXT[!MAY,implementation]: Handshake packets MAY contain
    TEXT[!MAY,implementation]:    CONNECTION_CLOSE frames of type 0x1c.
    TEXT[!MUST,implementation]: Endpoints MUST treat receipt
    TEXT[!MUST,implementation]:    of Handshake packets with other frames as a connection error
    TEXT[!MUST]:  of type
    TEXT[!MUST]:    PROTOCOL_VIOLATION.

  SECTION: [Retry Packet](#section-17.2.5)
    TEXT[implementation]: a Retry packet uses a long packet header with
    TEXT[implementation]:    a type value of 0x03.
    TEXT[implementation]:    Retry Packet {
    TEXT[implementation]:      Header Form (1) = 1,
    TEXT[implementation]:      Fixed Bit (1) = 1,
    TEXT[implementation]:      Long Packet Type (2) = 3,
    TEXT[implementation]:      Unused (4),
    TEXT[implementation]:      Version (32),
    TEXT[implementation]:      Destination Connection ID Length (8),
    TEXT[implementation]:      Destination Connection ID (0..160),
    TEXT[implementation]:      Source Connection ID Length (8),
    TEXT[implementation]:      Source Connection ID (0..160),
    TEXT[implementation]:      Retry Token (..),
    TEXT[implementation]:      Retry Integrity Tag (128),
    TEXT[!MUST,implementation]: The value in
    TEXT[!MUST,implementation]:    the Unused field is set to an arbitrary value by the server; a client
    TEXT[!MUST,implementation]:    MUST ignore these bits.
    TEXT[implementation]:    Retry Token:  An opaque token that the server can use to validate the
    TEXT[implementation]:       client's address.
    TEXT[implementation]:    Retry Integrity Tag:  Defined in Section 5.8 ("Retry Packet
    TEXT[implementation]:       Integrity") of [QUIC-TLS].

  SECTION: [Sending a Retry Packet](#section-17.2.5.1)
    TEXT[!MUST,implementation,test]: This value MUST NOT be equal to the Destination
    TEXT[!MUST,implementation,test]:    Connection ID field of the packet sent by the client.
    TEXT[!MUST,implementation,todo]: A client MUST
    TEXT[!MUST,implementation,todo]:    discard a Retry packet that contains a Source Connection ID field
    TEXT[!MUST,implementation,todo]:    that is identical to the Destination Connection ID field of its
    TEXT[!MUST,implementation,todo]:    Initial packet.
    TEXT[!MUST,implementation]: The client MUST use the value from the Source
    TEXT[!MUST,implementation]:    Connection ID field of the Retry packet in the Destination Connection
    TEXT[!MUST,implementation]:    ID field of subsequent packets that it sends.
    TEXT[!MAY]:    A server MAY send Retry packets in response to Initial and 0-RTT
    TEXT[!MAY]:    packets.
    TEXT[!MUST,implementation]: A server MUST NOT send more than one Retry
    TEXT[!MUST,implementation]:    packet in response to a single UDP datagram.

  SECTION: [Handling a Retry Packet](#section-17.2.5.2)
    TEXT[!MUST,implementation,todo]:    A client MUST accept and process at most one Retry packet for each
    TEXT[!MUST,implementation,todo]:    connection attempt.
    TEXT[!MUST,implementation,todo]: After the client has received and processed an
    TEXT[!MUST,implementation,todo]:    Initial or Retry packet from the server, it MUST discard any
    TEXT[!MUST,implementation,todo]:    subsequent Retry packets that it receives.
    TEXT[!MUST,todo]:    Clients MUST discard Retry packets that have a Retry Integrity Tag
    TEXT[!MUST,todo]:    that cannot be validated; see Section 5.8 of [QUIC-TLS].
    TEXT[!MUST,implementation,test]: A client
    TEXT[!MUST,implementation,test]:    MUST discard a Retry packet with a zero-length Retry Token field.
    TEXT[implementation]: Changing the Destination Connection ID field also results in
    TEXT[implementation]:    a change to the keys used to protect the Initial packet.
    TEXT[!MUST]: The
    TEXT[!MUST]:    client MUST NOT change the Source Connection ID because the server
    TEXT[!MUST]:    could include the connection ID as part of its token validation
    TEXT[!MUST]:    logic; see Section 8.1.4.

  SECTION: [Continuing a Handshake after Retry](#section-17.2.5.3)
    TEXT[implementation]:    Subsequent Initial packets from the client include the connection ID
    TEXT[implementation]:    and token values from the Retry packet.
    TEXT[implementation]:    Other than updating the Destination Connection ID and Token fields,
    TEXT[implementation]:    the Initial packet sent by the client is subject to the same
    TEXT[implementation]:    restrictions as the first Initial packet.
    TEXT[!MUST,implementation]: A client MUST use the same
    TEXT[!MUST,implementation]:    cryptographic handshake message it included in this packet.
    TEXT[!MAY]: A server
    TEXT[!MAY]:    MAY treat a packet that contains a different cryptographic handshake
    TEXT[!MAY]:    message as a connection error or discard it.
    TEXT[!MAY]:    A client MAY attempt 0-RTT after receiving a Retry packet by sending
    TEXT[!MAY]:    0-RTT packets to the connection ID provided by the server.
    TEXT[!MUST]:    A client MUST NOT reset the packet number for any packet number space
    TEXT[!MUST]:    after processing a Retry packet.
    TEXT[!MAY]: A server MAY abort the connection if it
    TEXT[!MAY]:    detects that the client reset the packet number.

  SECTION: [1-RTT Packet](#section-17.3.1)
    TEXT[implementation]:    1-RTT Packet {
    TEXT[implementation]:      Header Form (1) = 0,
    TEXT[implementation]:      Fixed Bit (1) = 1,
    TEXT[implementation]:      Spin Bit (1),
    TEXT[implementation]:      Reserved Bits (2),
    TEXT[implementation]:      Key Phase (1),
    TEXT[implementation]:      Packet Number Length (2),
    TEXT[implementation]:      Destination Connection ID (0..160),
    TEXT[implementation]:      Packet Number (8..32),
    TEXT[implementation]:      Packet Payload (8..),
    TEXT[implementation]:    Header Form:  The most significant bit (0x80) of byte 0 is set to 0
    TEXT[implementation]:       for the short header.
    TEXT[implementation]:    Fixed Bit:  The next bit (0x40) of byte 0 is set to 1.
    TEXT[!MUST]: Packets
    TEXT[!MUST]:       containing a zero value for this bit are not valid packets in this
    TEXT[!MUST]:       version and MUST be discarded.
    TEXT[implementation]:    Spin Bit:  The third most significant bit (0x20) of byte 0 is the
    TEXT[implementation]:       latency spin bit, set as described in Section 17.4.
    TEXT[implementation]:    Reserved Bits:  The next two bits (those with a mask of 0x18) of byte
    TEXT[implementation]:       0 are reserved.  These bits are protected using header protection;
    TEXT[implementation]:       see Section 5.4 of [QUIC-TLS].
    TEXT[!MUST]: The value included prior to
    TEXT[!MUST]:       protection MUST be set to 0.
    TEXT[!MUST,implementation]: An endpoint MUST treat receipt of a
    TEXT[!MUST,implementation]:       packet that has a non-zero value for these bits, after removing
    TEXT[!MUST,implementation]:       both packet and header protection, as a connection error of type
    TEXT[!MUST,implementation]:       PROTOCOL_VIOLATION.
    TEXT[implementation]:    Key Phase:  The next bit (0x04) of byte 0 indicates the key phase,
    TEXT[implementation]:       which allows a recipient of a packet to identify the packet
    TEXT[implementation]:       protection keys that are used to protect the packet.
    TEXT[implementation]:    Packet Number Length:  The least significant two bits (those with a
    TEXT[implementation]:       mask of 0x03) of byte 0 contain the length of the Packet Number
    TEXT[implementation]:       field, encoded as an unsigned two-bit integer that is one less
    TEXT[implementation]:       than the length of the Packet Number field in bytes.
    TEXT[implementation]:    Destination Connection ID:  The Destination Connection ID is a
    TEXT[implementation]:       connection ID that is chosen by the intended recipient of the
    TEXT[implementation]:       packet.
    TEXT[implementation]:    Packet Number:  The Packet Number field is 1 to 4 bytes long.  The
    TEXT[implementation]:       packet number is protected using header protection; see
    TEXT[implementation]:       Section 5.4 of [QUIC-TLS].  The length of the Packet Number field
    TEXT[implementation]:       is encoded in Packet Number Length field.  See Section 17.1 for
    TEXT[implementation]:       details.
    TEXT[implementation]:    Packet Payload:  1-RTT packets always include a 1-RTT protected
    TEXT[implementation]:       payload.

  SECTION: [Latency Spin Bit](#section-17.4)
    TEXT[!MAY,todo]:    The spin bit is an OPTIONAL feature of this version of QUIC.
    TEXT[!MUST]: An
    TEXT[!MUST]:    endpoint that does not support this feature MUST disable it, as
    TEXT[!MUST]:    defined below.
    TEXT[!MUST,todo]: Implementations MUST allow administrators
    TEXT[!MUST,todo]:    of clients and servers to disable the spin bit either globally or on
    TEXT[!MUST,todo]:    a per-connection basis.
    TEXT[!MUST,todo]: Even when the spin bit is not disabled by
    TEXT[!MUST,todo]:    the administrator, endpoints MUST disable their use of the spin bit
    TEXT[!MUST,todo]:    for a random selection of at least one in every 16 network paths, or
    TEXT[!MUST,todo]:    for one in every 16 connection IDs,
    TEXT[!MUST]:  in order to ensure that QUIC
    TEXT[!MUST]:    connections that disable the spin bit are commonly observed on the
    TEXT[!MUST]:    network.
    TEXT[!MUST,todo]:    When the spin bit is disabled, endpoints MAY set the spin bit to any
    TEXT[!MUST,todo]:    value and MUST ignore any incoming value.
    TEXT[!SHOULD,todo]: It is RECOMMENDED that
    TEXT[!SHOULD,todo]:    endpoints set the spin bit to a random value either chosen
    TEXT[!SHOULD,todo]:    independently for each packet or chosen independently for each
    TEXT[!SHOULD,todo]:    connection ID.

  SECTION: [Transport Parameter Encoding](#section-18)
    TEXT[implementation]:    The extension_data field of the quic_transport_parameters extension
    TEXT[implementation]:    defined in [QUIC-TLS] contains the QUIC transport parameters.  They
    TEXT[implementation]:    are encoded as a sequence of transport parameters, as shown in
    TEXT[implementation]:    Figure 20:
    TEXT[implementation]:    Transport Parameters {
    TEXT[implementation]:      Transport Parameter (..) ...,
    TEXT[implementation]:                 Figure 20: Sequence of Transport Parameters
    TEXT[implementation]:    Transport Parameter {
    TEXT[implementation]:      Transport Parameter ID (i),
    TEXT[implementation]:      Transport Parameter Length (i),
    TEXT[implementation]:      Transport Parameter Value (..),
    TEXT[implementation]:                   Figure 21: Transport Parameter Encoding
    TEXT[implementation]:    The Transport Parameter Length field contains the length of the
    TEXT[implementation]:    Transport Parameter Value field in bytes.
    TEXT[implementation]:    QUIC encodes transport parameters into a sequence of bytes, which is
    TEXT[implementation]:    then included in the cryptographic handshake.

  SECTION: [Transport Parameter Definitions](#section-18.2)
    TEXT[implementation]:    original_destination_connection_id (0x00):  This parameter is the
    TEXT[implementation]:       value of the Destination Connection ID field from the first
    TEXT[implementation]:       Initial packet sent by the client; see Section 7.3.  This
    TEXT[implementation]:       transport parameter is only sent by a server.
    TEXT[implementation]:    max_idle_timeout (0x01):  The maximum idle timeout is a value in
    TEXT[implementation]:       milliseconds that is encoded as an integer; see (Section 10.1).
    TEXT[implementation]:       Idle timeout is disabled when both endpoints omit this transport
    TEXT[implementation]:       parameter or specify a value of 0.
    TEXT[implementation]:    stateless_reset_token (0x02):  A stateless reset token is used in
    TEXT[implementation]:       verifying a stateless reset; see Section 10.3.  This parameter is
    TEXT[implementation]:       a sequence of 16 bytes.
    TEXT[!MUST,implementation]: This transport parameter MUST NOT be sent
    TEXT[!MUST,implementation]:       by a client but MAY be sent by a server.
    TEXT[implementation]:   A server that does not
    TEXT[implementation]:       send this transport parameter cannot use stateless reset
    TEXT[implementation]:       (Section 10.3) for the connection ID negotiated during the
    TEXT[implementation]:       handshake.
    TEXT[implementation]:    max_udp_payload_size (0x03):  The maximum UDP payload size parameter
    TEXT[implementation]:       is an integer value that limits the size of UDP payloads that the
    TEXT[implementation]:       endpoint is willing to receive.  UDP datagrams with payloads
    TEXT[implementation]:       larger than this limit are not likely to be processed by the
    TEXT[implementation]:       receiver.
    TEXT[implementation]:       The default for this parameter is the maximum permitted UDP
    TEXT[implementation]:       payload of 65527.  Values below 1200 are invalid.
    TEXT[implementation]:       This limit does act as an additional constraint on datagram size
    TEXT[implementation]:       in the same way as the path MTU, but it is a property of the
    TEXT[implementation]:       endpoint and not the path; see Section 14.  It is expected that
    TEXT[implementation]:       this is the space an endpoint dedicates to holding incoming
    TEXT[implementation]:       packets.
    TEXT[implementation]:    initial_max_data (0x04):  The initial maximum data parameter is an
    TEXT[implementation]:       integer value that contains the initial value for the maximum
    TEXT[implementation]:       amount of data that can be sent on the connection.  This is
    TEXT[implementation]:       equivalent to sending a MAX_DATA (Section 19.9) for the connection
    TEXT[implementation]:       immediately after completing the handshake.
    TEXT[implementation]:    initial_max_stream_data_bidi_local (0x05):  This parameter is an
    TEXT[implementation]:       integer value specifying the initial flow control limit for
    TEXT[implementation]:       locally initiated bidirectional streams.  This limit applies to
    TEXT[implementation]:       newly created bidirectional streams opened by the endpoint that
    TEXT[implementation]:       sends the transport parameter.  In client transport parameters,
    TEXT[implementation]:       this applies to streams with an identifier with the least
    TEXT[implementation]:       significant two bits set to 0x00; in server transport parameters,
    TEXT[implementation]:       this applies to streams with the least significant two bits set to
    TEXT[implementation]:       0x01.
    TEXT[implementation]:    initial_max_stream_data_bidi_remote (0x06):  This parameter is an
    TEXT[implementation]:       integer value specifying the initial flow control limit for peer-
    TEXT[implementation]:       initiated bidirectional streams.  This limit applies to newly
    TEXT[implementation]:       created bidirectional streams opened by the endpoint that receives
    TEXT[implementation]:       the transport parameter.  In client transport parameters, this
    TEXT[implementation]:       applies to streams with an identifier with the least significant
    TEXT[implementation]:       two bits set to 0x01; in server transport parameters, this applies
    TEXT[implementation]:       to streams with the least significant two bits set to 0x00.
    TEXT[implementation]:    initial_max_stream_data_uni (0x07):  This parameter is an integer
    TEXT[implementation]:       value specifying the initial flow control limit for unidirectional
    TEXT[implementation]:       streams.  This limit applies to newly created unidirectional
    TEXT[implementation]:       streams opened by the endpoint that receives the transport
    TEXT[implementation]:       parameter.  In client transport parameters, this applies to
    TEXT[implementation]:       streams with an identifier with the least significant two bits set
    TEXT[implementation]:       to 0x03; in server transport parameters, this applies to streams
    TEXT[implementation]:       with the least significant two bits set to 0x02.
    TEXT[implementation]:    initial_max_streams_bidi (0x08):  The initial maximum bidirectional
    TEXT[implementation]:       streams parameter is an integer value that contains the initial
    TEXT[implementation]:       maximum number of bidirectional streams the endpoint that receives
    TEXT[implementation]:       this transport parameter is permitted to initiate.  If this
    TEXT[implementation]:       parameter is absent or zero, the peer cannot open bidirectional
    TEXT[implementation]:       streams until a MAX_STREAMS frame is sent.  Setting this parameter
    TEXT[implementation]:       is equivalent to sending a MAX_STREAMS (Section 19.11) of the
    TEXT[implementation]:       corresponding type with the same value.
    TEXT[implementation]:    initial_max_streams_uni (0x09):  The initial maximum unidirectional
    TEXT[implementation]:       streams parameter is an integer value that contains the initial
    TEXT[implementation]:       maximum number of unidirectional streams the endpoint that
    TEXT[implementation]:       receives this transport parameter is permitted to initiate.  If
    TEXT[implementation]:       this parameter is absent or zero, the peer cannot open
    TEXT[implementation]:       unidirectional streams until a MAX_STREAMS frame is sent.  Setting
    TEXT[implementation]:       this parameter is equivalent to sending a MAX_STREAMS
    TEXT[implementation]:       (Section 19.11) of the corresponding type with the same value.
    TEXT[implementation]:    ack_delay_exponent (0x0a):  The acknowledgment delay exponent is an
    TEXT[implementation]:       integer value indicating an exponent used to decode the ACK Delay
    TEXT[implementation]:       field in the ACK frame (Section 19.3).  If this value is absent, a
    TEXT[implementation]:       default value of 3 is assumed (indicating a multiplier of 8).
    TEXT[implementation]:       Values above 20 are invalid.
    TEXT[implementation]:    max_ack_delay (0x0b):  The maximum acknowledgment delay is an integer
    TEXT[implementation]:       value indicating the maximum amount of time in milliseconds by
    TEXT[implementation]:       which the endpoint will delay sending acknowledgments.
    TEXT[!SHOULD,implementation]: This value
    TEXT[!SHOULD,implementation]:       SHOULD include the receiver's expected delays in alarms firing.
    TEXT[implementation]:       For example, if a receiver sets a timer for 5ms and alarms
    TEXT[implementation]:       commonly fire up to 1ms late, then it should send a max_ack_delay
    TEXT[implementation]:       of 6ms.  If this value is absent, a default of 25 milliseconds is
    TEXT[implementation]:       assumed.  Values of 2^14 or greater are invalid.
    TEXT[implementation]:    disable_active_migration (0x0c):  The disable active migration
    TEXT[implementation]:       transport parameter is included if the endpoint does not support
    TEXT[implementation]:       active connection migration (Section 9) on the address being used
    TEXT[implementation]:       during the handshake.
    TEXT[!MUST]: An endpoint that receives this transport
    TEXT[!MUST]:       parameter MUST NOT use a new local address when sending to the
    TEXT[!MUST]:       address that the peer used during the handshake.
    TEXT[implementation]:    preferred_address (0x0d):  The server's preferred address is used to
    TEXT[implementation]:       effect a change in server address at the end of the handshake, as
    TEXT[implementation]:       described in Section 9.6.  This transport parameter is only sent
    TEXT[implementation]:       by a server.
    TEXT[!MAY,implementation]: Servers MAY choose to only send a preferred address
    TEXT[!MAY,implementation]:       of one address family by sending an all-zero address and port
    TEXT[!MAY,implementation]:       (0.0.0.0:0 or [::]:0) for the other family.
    TEXT[implementation]:   IP addresses are
    TEXT[implementation]:       encoded in network byte order.
    TEXT[!MUST]: A server
    TEXT[!MUST]:       that chooses a zero-length connection ID MUST NOT provide a
    TEXT[!MUST]:       preferred address.
    TEXT[!MUST]: Similarly, a server MUST NOT include a zero-
    TEXT[!MUST]:       length connection ID in this transport parameter.
    TEXT[!MUST]: A client MUST
    TEXT[!MUST]:       treat a violation of these requirements as a connection error of
    TEXT[!MUST]:       type TRANSPORT_PARAMETER_ERROR.
    TEXT[implementation]:    Preferred Address {
    TEXT[implementation]:      IPv4 Address (32),
    TEXT[implementation]:      IPv4 Port (16),
    TEXT[implementation]:      IPv6 Address (128),
    TEXT[implementation]:      IPv6 Port (16),
    TEXT[implementation]:      Connection ID Length (8),
    TEXT[implementation]:      Connection ID (..),
    TEXT[implementation]:      Stateless Reset Token (128),
    TEXT[implementation]:    active_connection_id_limit (0x0e):  This is an integer value
    TEXT[implementation]:       specifying the maximum number of connection IDs from the peer that
    TEXT[implementation]:       an endpoint is willing to store.  This value includes the
    TEXT[implementation]:       connection ID received during the handshake, that received in the
    TEXT[implementation]:       preferred_address transport parameter, and those received in
    TEXT[implementation]:       NEW_CONNECTION_ID frames.
    TEXT[!MUST,implementation,test]: The value of the
    TEXT[!MUST,implementation,test]:       active_connection_id_limit parameter MUST be at least 2.
    TEXT[!MUST,implementation]: An
    TEXT[!MUST,implementation]:       endpoint that receives a value less than 2 MUST close the
    TEXT[!MUST,implementation]:       connection with an error of type TRANSPORT_PARAMETER_ERROR.
    TEXT[implementation]:   If
    TEXT[implementation]:       this transport parameter is absent, a default of 2 is assumed.  If
    TEXT[implementation]:       an endpoint issues a zero-length connection ID, it will never send
    TEXT[implementation]:       a NEW_CONNECTION_ID frame and therefore ignores the
    TEXT[implementation]:       active_connection_id_limit value received from its peer.
    TEXT[implementation]:    initial_source_connection_id (0x0f):  This is the value that the
    TEXT[implementation]:       endpoint included in the Source Connection ID field of the first
    TEXT[implementation]:       Initial packet it sends for the connection; see Section 7.3.
    TEXT[implementation]:    retry_source_connection_id (0x10):  This is the value that the server
    TEXT[implementation]:       included in the Source Connection ID field of a Retry packet; see
    TEXT[implementation]:       Section 7.3.  This transport parameter is only sent by a server.
    TEXT[implementation]:    If present, transport parameters that set initial per-stream flow
    TEXT[implementation]:    control limits (initial_max_stream_data_bidi_local,
    TEXT[implementation]:    initial_max_stream_data_bidi_remote, and initial_max_stream_data_uni)
    TEXT[implementation]:    are equivalent to sending a MAX_STREAM_DATA frame (Section 19.10) on
    TEXT[implementation]:    every stream of the corresponding type immediately after opening.  If
    TEXT[implementation]:    the transport parameter is absent, streams of that type start with a
    TEXT[implementation]:    flow control limit of 0.
    TEXT[!MUST,implementation]:    A client MUST NOT include any server-only transport parameter:
    TEXT[!MUST,implementation]:    original_destination_connection_id, preferred_address,
    TEXT[!MUST,implementation]:    retry_source_connection_id, or stateless_reset_token.
    TEXT[!MUST,implementation]: A server MUST
    TEXT[!MUST,implementation]:    treat receipt of any of these transport parameters as a connection
    TEXT[!MUST,implementation]:    error of type TRANSPORT_PARAMETER_ERROR.

  SECTION: [Frame Types and Formats](#section-19)
    TEXT[implementation]:    As described in Section 12.4, packets contain one or more frames.
    TEXT[implementation]:    This section describes the format and semantics of the core QUIC
    TEXT[implementation]:    frame types.

  SECTION: [PADDING Frames](#section-19.1)
    TEXT[implementation]:    A PADDING frame (type=0x00) has no semantic value.  PADDING frames
    TEXT[implementation]:    can be used to increase the size of a packet.  Padding can be used to
    TEXT[implementation]:    increase an Initial packet to the minimum required size or to provide
    TEXT[implementation]:    protection against traffic analysis for protected packets.
    TEXT[implementation]:    PADDING Frame {
    TEXT[implementation]:      Type (i) = 0x00,

  SECTION: [PING Frames](#section-19.2)
    TEXT[implementation]:    Endpoints can use PING frames (type=0x01) to verify that their peers
    TEXT[implementation]:    are still alive or to check reachability to the peer.
    TEXT[implementation]:    PING Frame {
    TEXT[implementation]:      Type (i) = 0x01,

  SECTION: [ACK Frames](#section-19.3)
    TEXT[implementation]:    Receivers send ACK frames (types 0x02 and 0x03) to inform senders of
    TEXT[implementation]:    packets they have received and processed.  The ACK frame contains one
    TEXT[implementation]:    or more ACK Ranges.  ACK Ranges identify acknowledged packets.  If
    TEXT[implementation]:    the frame type is 0x03, ACK frames also contain the cumulative count
    TEXT[implementation]:    of QUIC packets with associated ECN marks received on the connection
    TEXT[implementation]:    up until this point.
    TEXT[!MUST]: QUIC implementations MUST properly handle both
    TEXT[!MUST]:    types, and, if they have enabled ECN for packets they send, they
    TEXT[!MUST]:    SHOULD use the information in the ECN section to manage their
    TEXT[!MUST]:    congestion state.
    TEXT[implementation]:    ACK Frame {
    TEXT[implementation]:      Type (i) = 0x02..0x03,
    TEXT[implementation]:      Largest Acknowledged (i),
    TEXT[implementation]:      ACK Delay (i),
    TEXT[implementation]:      ACK Range Count (i),
    TEXT[implementation]:      First ACK Range (i),
    TEXT[implementation]:      ACK Range (..) ...,
    TEXT[implementation]:      [ECN Counts (..)],
    TEXT[implementation]:    ACK frames contain the following fields:
    TEXT[implementation]:    Largest Acknowledged:  A variable-length integer representing the
    TEXT[implementation]:       largest packet number the peer is acknowledging; this is usually
    TEXT[implementation]:       the largest packet number that the peer has received prior to
    TEXT[implementation]:       generating the ACK frame.  Unlike the packet number in the QUIC
    TEXT[implementation]:       long or short header, the value in an ACK frame is not truncated.
    TEXT[implementation]:    ACK Delay:  A variable-length integer encoding the acknowledgment
    TEXT[implementation]:       delay in microseconds; see Section 13.2.5.  It is decoded by
    TEXT[implementation]:       multiplying the value in the field by 2 to the power of the
    TEXT[implementation]:       ack_delay_exponent transport parameter sent by the sender of the
    TEXT[implementation]:       ACK frame; see Section 18.2.  Compared to simply expressing the
    TEXT[implementation]:       delay as an integer, this encoding allows for a larger range of
    TEXT[implementation]:       values within the same number of bytes, at the cost of lower
    TEXT[implementation]:       resolution.
    TEXT[implementation]:    ACK Range Count:  A variable-length integer specifying the number of
    TEXT[implementation]:       ACK Range fields in the frame.
    TEXT[implementation]:    First ACK Range:  A variable-length integer indicating the number of
    TEXT[implementation]:       contiguous packets preceding the Largest Acknowledged that are
    TEXT[implementation]:       being acknowledged.  That is, the smallest packet acknowledged in
    TEXT[implementation]:       the range is determined by subtracting the First ACK Range value
    TEXT[implementation]:       from the Largest Acknowledged field.
    TEXT[implementation]:    ACK Ranges:  Contains additional ranges of packets that are
    TEXT[implementation]:       alternately not acknowledged (Gap) and acknowledged (ACK Range);
    TEXT[implementation]:       see Section 19.3.1.
    TEXT[implementation]:    ECN Counts:  The three ECN counts; see Section 19.3.2.

  SECTION: [ACK Ranges](#section-19.3.1)
    TEXT[implementation]:    Each ACK Range consists of alternating Gap and ACK Range Length
    TEXT[implementation]:    values in descending packet number order.  ACK Ranges can be
    TEXT[implementation]:    repeated.  The number of Gap and ACK Range Length values is
    TEXT[implementation]:    determined by the ACK Range Count field; one of each value is present
    TEXT[implementation]:    for each value in the ACK Range Count field.
    TEXT[implementation]:    ACK Range {
    TEXT[implementation]:      Gap (i),
    TEXT[implementation]:      ACK Range Length (i),
    TEXT[implementation]:    The fields that form each ACK Range are:
    TEXT[implementation]:    Gap:  A variable-length integer indicating the number of contiguous
    TEXT[implementation]:       unacknowledged packets preceding the packet number one lower than
    TEXT[implementation]:       the smallest in the preceding ACK Range.
    TEXT[implementation]:    ACK Range Length:  A variable-length integer indicating the number of
    TEXT[implementation]:       contiguous acknowledged packets preceding the largest packet
    TEXT[implementation]:       number, as determined by the preceding Gap.
    TEXT[implementation]:    Gap and ACK Range Length values use a relative integer encoding for
    TEXT[implementation]:    efficiency.  Though each encoded value is positive, the values are
    TEXT[implementation]:    subtracted, so that each ACK Range describes progressively lower-
    TEXT[implementation]:    numbered packets.
    TEXT[implementation]:    Each ACK Range acknowledges a contiguous range of packets by
    TEXT[implementation]:    indicating the number of acknowledged packets that precede the
    TEXT[implementation]:    largest packet number in that range.  A value of 0 indicates that
    TEXT[implementation]:    only the largest packet number is acknowledged.  Larger ACK Range
    TEXT[implementation]:    values indicate a larger range, with corresponding lower values for
    TEXT[implementation]:    the smallest packet number in the range.  Thus, given a largest
    TEXT[implementation]:    packet number for the range, the smallest value is determined by the
    TEXT[implementation]:    following formula:
    TEXT[implementation]:    An ACK Range acknowledges all packets between the smallest packet
    TEXT[implementation]:    number and the largest, inclusive.
    TEXT[implementation]:    The largest value for an ACK Range is determined by cumulatively
    TEXT[implementation]:    subtracting the size of all preceding ACK Range Lengths and Gaps.
    TEXT[implementation]:    Each Gap indicates a range of packets that are not being
    TEXT[implementation]:    acknowledged.  The number of packets in the gap is one higher than
    TEXT[implementation]:    the encoded value of the Gap field.
    TEXT[implementation]:    The value of the Gap field establishes the largest packet number
    TEXT[implementation]:    value for the subsequent ACK Range using the following formula:
    TEXT[implementation]:       largest = previous_smallest - gap - 2
    TEXT[!MUST,implementation]:    If any computed packet number is negative, an endpoint MUST generate
    TEXT[!MUST,implementation]:    a connection error of type FRAME_ENCODING_ERROR.

  SECTION: [ECN Counts](#section-19.3.2)
    TEXT[implementation]:    The ACK frame uses the least significant bit of the type value (that
    TEXT[implementation]:    is, type 0x03) to indicate ECN feedback and report receipt of QUIC
    TEXT[implementation]:    packets with associated ECN codepoints of ECT(0), ECT(1), or ECN-CE
    TEXT[implementation]:    in the packet's IP header.  ECN counts are only present when the ACK
    TEXT[implementation]:    frame type is 0x03.
    TEXT[implementation]:    ECN Counts {
    TEXT[implementation]:      ECT0 Count (i),
    TEXT[implementation]:      ECT1 Count (i),
    TEXT[implementation]:      ECN-CE Count (i),
    TEXT[implementation]:    The ECN count fields are:
    TEXT[implementation]:    ECT0 Count:  A variable-length integer representing the total number
    TEXT[implementation]:       of packets received with the ECT(0) codepoint in the packet number
    TEXT[implementation]:       space of the ACK frame.
    TEXT[implementation]:    ECT1 Count:  A variable-length integer representing the total number
    TEXT[implementation]:       of packets received with the ECT(1) codepoint in the packet number
    TEXT[implementation]:       space of the ACK frame.
    TEXT[implementation]:    ECN-CE Count:  A variable-length integer representing the total
    TEXT[implementation]:       number of packets received with the ECN-CE codepoint in the packet
    TEXT[implementation]:       number space of the ACK frame.
    TEXT[implementation]:    ECN counts are maintained separately for each packet number space.

  SECTION: [RESET_STREAM Frames](#section-19.4)
    TEXT[implementation]:    An endpoint uses a RESET_STREAM frame (type=0x04) to abruptly
    TEXT[implementation]:    terminate the sending part of a stream.
    TEXT[!MUST]:    An endpoint that receives a RESET_STREAM frame for a send-only stream
    TEXT[!MUST]:    MUST terminate the connection with error STREAM_STATE_ERROR.
    TEXT[implementation]:    RESET_STREAM Frame {
    TEXT[implementation]:      Type (i) = 0x04,
    TEXT[implementation]:      Stream ID (i),
    TEXT[implementation]:      Application Protocol Error Code (i),
    TEXT[implementation]:      Final Size (i),
    TEXT[implementation]:    RESET_STREAM frames contain the following fields:
    TEXT[implementation]:    Stream ID:  A variable-length integer encoding of the stream ID of
    TEXT[implementation]:       the stream being terminated.
    TEXT[implementation]:    Application Protocol Error Code:  A variable-length integer
    TEXT[implementation]:       containing the application protocol error code (see Section 20.2)
    TEXT[implementation]:       that indicates why the stream is being closed.
    TEXT[implementation]:    Final Size:  A variable-length integer indicating the final size of
    TEXT[implementation]:       the stream by the RESET_STREAM sender, in units of bytes; see
    TEXT[implementation]:       Section 4.5.

  SECTION: [STOP_SENDING Frames](#section-19.5)
    TEXT[implementation]:    An endpoint uses a STOP_SENDING frame (type=0x05) to communicate that
    TEXT[implementation]:    incoming data is being discarded on receipt per application request.
    TEXT[implementation]:    STOP_SENDING requests that a peer cease transmission on a stream.
    TEXT[!MUST]: Receiving a STOP_SENDING frame for a
    TEXT[!MUST]:    locally initiated stream that has not yet been created MUST be
    TEXT[!MUST]:    treated as a connection error of type STREAM_STATE_ERROR.
    TEXT[!MUST]: An
    TEXT[!MUST]:    endpoint that receives a STOP_SENDING frame for a receive-only stream
    TEXT[!MUST]:    MUST terminate the connection with error STREAM_STATE_ERROR.
    TEXT[implementation]:    STOP_SENDING Frame {
    TEXT[implementation]:      Type (i) = 0x05,
    TEXT[implementation]:      Stream ID (i),
    TEXT[implementation]:      Application Protocol Error Code (i),
    TEXT[implementation]:    STOP_SENDING frames contain the following fields:
    TEXT[implementation]:    Stream ID:  A variable-length integer carrying the stream ID of the
    TEXT[implementation]:       stream being ignored.
    TEXT[implementation]:    Application Protocol Error Code:  A variable-length integer
    TEXT[implementation]:       containing the application-specified reason the sender is ignoring
    TEXT[implementation]:       the stream; see Section 20.2.

  SECTION: [CRYPTO Frames](#section-19.6)
    TEXT[implementation]:    A CRYPTO frame (type=0x06) is used to transmit cryptographic
    TEXT[implementation]:    handshake messages.
    TEXT[implementation]:    CRYPTO Frame {
    TEXT[implementation]:      Type (i) = 0x06,
    TEXT[implementation]:      Offset (i),
    TEXT[implementation]:      Length (i),
    TEXT[implementation]:      Crypto Data (..),
    TEXT[implementation]:    CRYPTO frames contain the following fields:
    TEXT[implementation]:    Offset:  A variable-length integer specifying the byte offset in the
    TEXT[implementation]:       stream for the data in this CRYPTO frame.
    TEXT[implementation]:    Length:  A variable-length integer specifying the length of the
    TEXT[implementation]:       Crypto Data field in this CRYPTO frame.
    TEXT[implementation]:    Crypto Data:  The cryptographic message data.
    TEXT[!MUST]: Receipt of a frame that exceeds
    TEXT[!MUST]:    this limit MUST be treated as a connection error of type
    TEXT[!MUST]:    FRAME_ENCODING_ERROR or CRYPTO_BUFFER_EXCEEDED.
    TEXT[implementation]: The stream does not have an explicit
    TEXT[implementation]:    end, so CRYPTO frames do not have a FIN bit.

  SECTION: [NEW_TOKEN Frames](#section-19.7)
    TEXT[implementation]:    A server sends a NEW_TOKEN frame (type=0x07) to provide the client
    TEXT[implementation]:    with a token to send in the header of an Initial packet for a future
    TEXT[implementation]:    connection.
    TEXT[implementation]:    NEW_TOKEN Frame {
    TEXT[implementation]:      Type (i) = 0x07,
    TEXT[implementation]:      Token Length (i),
    TEXT[implementation]:      Token (..),
    TEXT[implementation]:    NEW_TOKEN frames contain the following fields:
    TEXT[implementation]:    Token Length:  A variable-length integer specifying the length of the
    TEXT[implementation]:       token in bytes.
    TEXT[implementation]:    Token:  An opaque blob that the client can use with a future Initial
    TEXT[implementation]:       packet.
    TEXT[!MUST,implementation]: The token MUST NOT be empty.
    TEXT[!MUST,implementation]: A client MUST treat receipt
    TEXT[!MUST,implementation]:       of a NEW_TOKEN frame with an empty Token field as a connection
    TEXT[!MUST,implementation]:       error of type FRAME_ENCODING_ERROR.
    TEXT[!MUST,todo]:    Clients MUST NOT send NEW_TOKEN frames.
    TEXT[!MUST,implementation]: A server MUST treat receipt
    TEXT[!MUST,implementation]:    of a NEW_TOKEN frame as a connection error of type
    TEXT[!MUST,implementation]:    PROTOCOL_VIOLATION.

  SECTION: [STREAM Frames](#section-19.8)
    TEXT[implementation]:    STREAM frames implicitly create a stream and carry stream data.  The
    TEXT[implementation]:    Type field in the STREAM frame takes the form 0b00001XXX (or the set
    TEXT[implementation]:    of values from 0x08 to 0x0f).
    TEXT[implementation]:    *  The OFF bit (0x04) in the frame type is set to indicate that there
    TEXT[implementation]:       is an Offset field present.  When set to 1, the Offset field is
    TEXT[implementation]:       present.  When set to 0, the Offset field is absent and the Stream
    TEXT[implementation]:       Data starts at an offset of 0 (that is, the frame contains the
    TEXT[implementation]:       first bytes of the stream, or the end of a stream that includes no
    TEXT[implementation]:       data).
    TEXT[implementation]:    *  The LEN bit (0x02) in the frame type is set to indicate that there
    TEXT[implementation]:       is a Length field present.  If this bit is set to 0, the Length
    TEXT[implementation]:       field is absent and the Stream Data field extends to the end of
    TEXT[implementation]:       the packet.  If this bit is set to 1, the Length field is present.
    TEXT[implementation]:    *  The FIN bit (0x01) indicates that the frame marks the end of the
    TEXT[implementation]:       stream.  The final size of the stream is the sum of the offset and
    TEXT[implementation]:       the length of this frame.
    TEXT[!MUST]:    An endpoint MUST terminate the connection with error
    TEXT[!MUST]:    STREAM_STATE_ERROR if it receives a STREAM frame for a locally
    TEXT[!MUST]:    initiated stream that has not yet been created, or for a send-only
    TEXT[!MUST]:    stream.
    TEXT[implementation]:    STREAM Frame {
    TEXT[implementation]:      Type (i) = 0x08..0x0f,
    TEXT[implementation]:      Stream ID (i),
    TEXT[implementation]:      [Offset (i)],
    TEXT[implementation]:      [Length (i)],
    TEXT[implementation]:      Stream Data (..),
    TEXT[implementation]:    STREAM frames contain the following fields:
    TEXT[implementation]:    Stream ID:  A variable-length integer indicating the stream ID of the
    TEXT[implementation]:       stream; see Section 2.1.
    TEXT[implementation]:    Offset:  A variable-length integer specifying the byte offset in the
    TEXT[implementation]:       stream for the data in this STREAM frame.  This field is present
    TEXT[implementation]:       when the OFF bit is set to 1.  When the Offset field is absent,
    TEXT[implementation]:       the offset is 0.
    TEXT[implementation]:    Length:  A variable-length integer specifying the length of the
    TEXT[implementation]:       Stream Data field in this STREAM frame.  This field is present
    TEXT[implementation]:       when the LEN bit is set to 1.  When the LEN bit is set to 0, the
    TEXT[implementation]:       Stream Data field consumes all the remaining bytes in the packet.
    TEXT[implementation]:    Stream Data:  The bytes from the designated stream to be delivered.
    TEXT[!MUST]: Receipt of a frame that exceeds this limit
    TEXT[!MUST]:    MUST be treated as a connection error of type FRAME_ENCODING_ERROR or
    TEXT[!MUST]:    FLOW_CONTROL_ERROR.

  SECTION: [MAX_DATA Frames](#section-19.9)
    TEXT[implementation]:    A MAX_DATA frame (type=0x10) is used in flow control to inform the
    TEXT[implementation]:    peer of the maximum amount of data that can be sent on the connection
    TEXT[implementation]:    as a whole.
    TEXT[implementation]:    MAX_DATA Frame {
    TEXT[implementation]:      Type (i) = 0x10,
    TEXT[implementation]:      Maximum Data (i),
    TEXT[implementation]:    MAX_DATA frames contain the following field:
    TEXT[implementation]:    Maximum Data:  A variable-length integer indicating the maximum
    TEXT[implementation]:       amount of data that can be sent on the entire connection, in units
    TEXT[implementation]:       of bytes.
    TEXT[!MUST]: The sum of
    TEXT[!MUST]:    the final sizes on all streams -- including streams in terminal
    TEXT[!MUST]:    states -- MUST NOT exceed the value advertised by a receiver.
    TEXT[!MUST,implementation]: An
    TEXT[!MUST,implementation]:    endpoint MUST terminate a connection with an error of type
    TEXT[!MUST,implementation]:    FLOW_CONTROL_ERROR if it receives more data than the maximum data
    TEXT[!MUST,implementation]:    value that it has sent.
    TEXT[implementation]:   This includes violations of remembered
    TEXT[implementation]:    limits in Early Data; see Section 7.4.1.

  SECTION: [MAX_STREAM_DATA Frames](#section-19.10)
    TEXT[implementation]:    A MAX_STREAM_DATA frame (type=0x11) is used in flow control to inform
    TEXT[implementation]:    a peer of the maximum amount of data that can be sent on a stream.
    TEXT[!MUST]: Receiving a MAX_STREAM_DATA frame for a locally
    TEXT[!MUST]:    initiated stream that has not yet been created MUST be treated as a
    TEXT[!MUST]:    connection error of type STREAM_STATE_ERROR.
    TEXT[!MUST,implementation]: An endpoint that
    TEXT[!MUST,implementation]:    receives a MAX_STREAM_DATA frame for a receive-only stream MUST
    TEXT[!MUST,implementation]:    terminate the connection with error STREAM_STATE_ERROR.
    TEXT[implementation]:    MAX_STREAM_DATA Frame {
    TEXT[implementation]:      Type (i) = 0x11,
    TEXT[implementation]:      Stream ID (i),
    TEXT[implementation]:      Maximum Stream Data (i),
    TEXT[implementation]:    MAX_STREAM_DATA frames contain the following fields:
    TEXT[implementation]:    Stream ID:  The stream ID of the affected stream, encoded as a
    TEXT[implementation]:       variable-length integer.
    TEXT[implementation]:    Maximum Stream Data:  A variable-length integer indicating the
    TEXT[implementation]:       maximum amount of data that can be sent on the identified stream,
    TEXT[implementation]:       in units of bytes.
    TEXT[!MUST,implementation]:    The data sent on a stream MUST NOT exceed the largest maximum stream
    TEXT[!MUST,implementation]:    data value advertised by the receiver.
    TEXT[!MUST,implementation]: An endpoint MUST terminate a
    TEXT[!MUST,implementation]:    connection with an error of type FLOW_CONTROL_ERROR if it receives
    TEXT[!MUST,implementation]:    more data than the largest maximum stream data that it has sent for
    TEXT[!MUST,implementation]:    the affected stream.
    TEXT[implementation]:   This includes violations of remembered limits
    TEXT[implementation]:    in Early Data; see Section 7.4.1.

  SECTION: [MAX_STREAMS Frames](#section-19.11)
    TEXT[implementation]:    A MAX_STREAMS frame (type=0x12 or 0x13) informs the peer of the
    TEXT[implementation]:    cumulative number of streams of a given type it is permitted to open.
    TEXT[implementation]:    A MAX_STREAMS frame with a type of 0x12 applies to bidirectional
    TEXT[implementation]:    streams, and a MAX_STREAMS frame with a type of 0x13 applies to
    TEXT[implementation]:    unidirectional streams.
    TEXT[implementation]:    MAX_STREAMS Frame {
    TEXT[implementation]:      Type (i) = 0x12..0x13,
    TEXT[implementation]:      Maximum Streams (i),
    TEXT[implementation]:    MAX_STREAMS frames contain the following field:
    TEXT[implementation]:    Maximum Streams:  A count of the cumulative number of streams of the
    TEXT[implementation]:       corresponding type that can be opened over the lifetime of the
    TEXT[implementation]:       connection.  This value cannot exceed 2^60, as it is not possible
    TEXT[implementation]:       to encode stream IDs larger than 2^62-1.
    TEXT[!MUST,implementation]: Receipt of a frame that
    TEXT[!MUST,implementation]:       permits opening of a stream larger than this limit MUST be treated
    TEXT[!MUST,implementation]:       as a connection error of type FRAME_ENCODING_ERROR.
    TEXT[!MUST,implementation,test]:    MAX_STREAMS frames that do not increase the stream limit MUST be
    TEXT[!MUST,implementation,test]:    ignored.
    TEXT[!MUST,implementation,test]:    An endpoint MUST NOT open more streams than permitted by the current
    TEXT[!MUST,implementation,test]:    stream limit set by its peer.
    TEXT[!MUST,implementation,test]: An endpoint MUST terminate a connection
    TEXT[!MUST,implementation,test]:    with an error of type STREAM_LIMIT_ERROR if a peer opens more streams
    TEXT[!MUST,implementation,test]:    than was permitted.

  SECTION: [DATA_BLOCKED Frames](#section-19.12)
    TEXT[!SHOULD,implementation,test]:    A sender SHOULD send a DATA_BLOCKED frame (type=0x14) when it wishes
    TEXT[!SHOULD,implementation,test]:    to send data but is unable to do so due to connection-level flow
    TEXT[!SHOULD,implementation,test]:    control; see Section 4.
    TEXT[implementation]:   DATA_BLOCKED frames can be used as input to
    TEXT[implementation]:    tuning of flow control algorithms; see Section 4.2.
    TEXT[implementation]:    DATA_BLOCKED Frame {
    TEXT[implementation]:      Type (i) = 0x14,
    TEXT[implementation]:      Maximum Data (i),
    TEXT[implementation]:    DATA_BLOCKED frames contain the following field:
    TEXT[implementation]:    Maximum Data:  A variable-length integer indicating the connection-
    TEXT[implementation]:       level limit at which blocking occurred.

  SECTION: [STREAM_DATA_BLOCKED Frames](#section-19.13)
    TEXT[!SHOULD,implementation,test]:    A sender SHOULD send a STREAM_DATA_BLOCKED frame (type=0x15) when it
    TEXT[!SHOULD,implementation,test]:    wishes to send data but is unable to do so due to stream-level flow
    TEXT[!SHOULD,implementation,test]:    control.
    TEXT[implementation]: This frame is analogous to DATA_BLOCKED (Section 19.12).
    TEXT[!MUST]:    An endpoint that receives a STREAM_DATA_BLOCKED frame for a send-only
    TEXT[!MUST]:    stream MUST terminate the connection with error STREAM_STATE_ERROR.
    TEXT[implementation]:    STREAM_DATA_BLOCKED Frame {
    TEXT[implementation]:      Type (i) = 0x15,
    TEXT[implementation]:      Stream ID (i),
    TEXT[implementation]:      Maximum Stream Data (i),
    TEXT[implementation]:    STREAM_DATA_BLOCKED frames contain the following fields:
    TEXT[implementation]:    Stream ID:  A variable-length integer indicating the stream that is
    TEXT[implementation]:       blocked due to flow control.
    TEXT[implementation]:    Maximum Stream Data:  A variable-length integer indicating the offset
    TEXT[implementation]:       of the stream at which the blocking occurred.

  SECTION: [STREAMS_BLOCKED Frames](#section-19.14)
    TEXT[!SHOULD,implementation,test]:    A sender SHOULD send a STREAMS_BLOCKED frame (type=0x16 or 0x17) when
    TEXT[!SHOULD,implementation,test]:    it wishes to open a stream but is unable to do so due to the maximum
    TEXT[!SHOULD,implementation,test]:    stream limit set by its peer; see Section 19.11.
    TEXT[implementation]: A STREAMS_BLOCKED
    TEXT[implementation]:    frame of type 0x16 is used to indicate reaching the bidirectional
    TEXT[implementation]:    stream limit, and a STREAMS_BLOCKED frame of type 0x17 is used to
    TEXT[implementation]:    indicate reaching the unidirectional stream limit.
    TEXT[implementation]:    STREAMS_BLOCKED Frame {
    TEXT[implementation]:      Type (i) = 0x16..0x17,
    TEXT[implementation]:      Maximum Streams (i),
    TEXT[implementation]:    STREAMS_BLOCKED frames contain the following field:
    TEXT[implementation]:    Maximum Streams:  A variable-length integer indicating the maximum
    TEXT[implementation]:       number of streams allowed at the time the frame was sent.
    TEXT[implementation]: This
    TEXT[implementation]:       value cannot exceed 2^60, as it is not possible to encode stream
    TEXT[implementation]:       IDs larger than 2^62-1.
    TEXT[!MUST,implementation]: Receipt of a frame that encodes a larger
    TEXT[!MUST,implementation]:       stream ID MUST be treated as a connection error of type
    TEXT[!MUST,implementation]:       STREAM_LIMIT_ERROR or FRAME_ENCODING_ERROR.

  SECTION: [NEW_CONNECTION_ID Frames](#section-19.15)
    TEXT[implementation]:    An endpoint sends a NEW_CONNECTION_ID frame (type=0x18) to provide
    TEXT[implementation]:    its peer with alternative connection IDs that can be used to break
    TEXT[implementation]:    linkability when migrating connections; see Section 9.5.
    TEXT[implementation]:    NEW_CONNECTION_ID Frame {
    TEXT[implementation]:      Type (i) = 0x18,
    TEXT[implementation]:      Sequence Number (i),
    TEXT[implementation]:      Retire Prior To (i),
    TEXT[implementation]:      Length (8),
    TEXT[implementation]:      Connection ID (8..160),
    TEXT[implementation]:      Stateless Reset Token (128),
    TEXT[implementation]:    NEW_CONNECTION_ID frames contain the following fields:
    TEXT[implementation]:    Sequence Number:  The sequence number assigned to the connection ID
    TEXT[implementation]:       by the sender, encoded as a variable-length integer; see
    TEXT[implementation]:       Section 5.1.1.
    TEXT[implementation]:    Retire Prior To:  A variable-length integer indicating which
    TEXT[implementation]:       connection IDs should be retired; see Section 5.1.2.
    TEXT[implementation]:    Length:  An 8-bit unsigned integer containing the length of the
    TEXT[implementation]:       connection ID.
    TEXT[!MUST,implementation]: Values less than 1 and greater than 20 are invalid
    TEXT[!MUST,implementation]:       and MUST be treated as a connection error of type
    TEXT[!MUST,implementation]:       FRAME_ENCODING_ERROR.
    TEXT[implementation]:    Connection ID:  A connection ID of the specified length.
    TEXT[implementation]:    Stateless Reset Token:  A 128-bit value that will be used for a
    TEXT[implementation]:       stateless reset when the associated connection ID is used; see
    TEXT[implementation]:       Section 10.3.
    TEXT[!MUST,exception]:    An endpoint MUST NOT send this frame if it currently requires that
    TEXT[!MUST,exception]:    its peer send packets with a zero-length Destination Connection ID.
    TEXT[!MUST,implementation]:    An endpoint that is sending packets with a zero-length Destination
    TEXT[!MUST,implementation]:    Connection ID MUST treat receipt of a NEW_CONNECTION_ID frame as a
    TEXT[!MUST,implementation]:    connection error of type PROTOCOL_VIOLATION.
    TEXT[!MUST,implementation,test]: Receipt
    TEXT[!MUST,implementation,test]:    of the same frame multiple times MUST NOT be treated as a connection
    TEXT[!MUST,implementation,test]:    error.
    TEXT[!MAY,implementation,test]:    If an endpoint receives a NEW_CONNECTION_ID frame that repeats a
    TEXT[!MAY,implementation,test]:    previously issued connection ID with a different Stateless Reset
    TEXT[!MAY,implementation,test]:    Token field value or a different Sequence Number field value, or if a
    TEXT[!MAY,implementation,test]:    sequence number is used for different connection IDs, the endpoint
    TEXT[!MAY,implementation,test]:    MAY treat that receipt as a connection error of type
    TEXT[!MAY,implementation,test]:    PROTOCOL_VIOLATION.
    TEXT[!MUST,implementation]: The value in the Retire Prior To field
    TEXT[!MUST,implementation]:    MUST be less than or equal to the value in the Sequence Number field.
    TEXT[!MUST,implementation]:    Receiving a value in the Retire Prior To field that is greater than
    TEXT[!MUST,implementation]:    that in the Sequence Number field MUST be treated as a connection
    TEXT[!MUST,implementation]:    error of type FRAME_ENCODING_ERROR.
    TEXT[!MUST,implementation,test]: A receiver
    TEXT[!MUST,implementation,test]:    MUST ignore any Retire Prior To fields that do not increase the
    TEXT[!MUST,implementation,test]:    largest received Retire Prior To value.
    TEXT[!MUST,implementation]:    An endpoint that receives a NEW_CONNECTION_ID frame with a sequence
    TEXT[!MUST,implementation]:    number smaller than the Retire Prior To field of a previously
    TEXT[!MUST,implementation]:    received NEW_CONNECTION_ID frame MUST send a corresponding
    TEXT[!MUST,implementation]:    RETIRE_CONNECTION_ID frame that retires the newly received connection
    TEXT[!MUST,implementation]:    ID, unless it has already done so for that sequence number.

  SECTION: [RETIRE_CONNECTION_ID Frames](#section-19.16)
    TEXT[implementation]:    An endpoint sends a RETIRE_CONNECTION_ID frame (type=0x19) to
    TEXT[implementation]:    indicate that it will no longer use a connection ID that was issued
    TEXT[implementation]:    by its peer.
    TEXT[implementation]:    RETIRE_CONNECTION_ID Frame {
    TEXT[implementation]:      Type (i) = 0x19,
    TEXT[implementation]:      Sequence Number (i),
    TEXT[implementation]:    RETIRE_CONNECTION_ID frames contain the following field:
    TEXT[implementation]:    Sequence Number:  The sequence number of the connection ID being
    TEXT[implementation]:       retired; see Section 5.1.2.
    TEXT[!MUST,implementation,test]:    Receipt of a RETIRE_CONNECTION_ID frame containing a sequence number
    TEXT[!MUST,implementation,test]:    greater than any previously sent to the peer MUST be treated as a
    TEXT[!MUST,implementation,test]:    connection error of type PROTOCOL_VIOLATION.
    TEXT[!MUST,implementation,test]:    The sequence number specified in a RETIRE_CONNECTION_ID frame MUST
    TEXT[!MUST,implementation,test]:    NOT refer to the Destination Connection ID field of the packet in
    TEXT[!MUST,implementation,test]:    which the frame is contained.
    TEXT[!MAY,implementation,test]: The peer MAY treat this as a
    TEXT[!MAY,implementation,test]:    connection error of type PROTOCOL_VIOLATION.
    TEXT[!MUST,exception]: An endpoint that provides a zero-
    TEXT[!MUST,exception]:    length connection ID MUST treat receipt of a RETIRE_CONNECTION_ID
    TEXT[!MUST,exception]:    frame as a connection error of type PROTOCOL_VIOLATION.

  SECTION: [PATH_CHALLENGE Frames](#section-19.17)
    TEXT[implementation]:    Endpoints can use PATH_CHALLENGE frames (type=0x1a) to check
    TEXT[implementation]:    reachability to the peer and for path validation during connection
    TEXT[implementation]:    migration.
    TEXT[implementation]:    PATH_CHALLENGE Frame {
    TEXT[implementation]:      Type (i) = 0x1a,
    TEXT[implementation]:      Data (64),
    TEXT[implementation]:    PATH_CHALLENGE frames contain the following field:
    TEXT[implementation]:    Data:  This 8-byte field contains arbitrary data.
    TEXT[!MUST]:    The recipient of this frame MUST generate a PATH_RESPONSE frame
    TEXT[!MUST]:    (Section 19.18) containing the same Data value.

  SECTION: [PATH_RESPONSE Frames](#section-19.18)
    TEXT[implementation]:    A PATH_RESPONSE frame (type=0x1b) is sent in response to a
    TEXT[implementation]:    PATH_CHALLENGE frame.
    TEXT[implementation]:    PATH_RESPONSE Frame {
    TEXT[implementation]:      Type (i) = 0x1b,
    TEXT[implementation]:      Data (64),
    TEXT[!MAY]:    If the content of a PATH_RESPONSE frame does not match the content of
    TEXT[!MAY]:    a PATH_CHALLENGE frame previously sent by the endpoint, the endpoint
    TEXT[!MAY]:    MAY generate a connection error of type PROTOCOL_VIOLATION.

  SECTION: [CONNECTION_CLOSE Frames](#section-19.19)
    TEXT[implementation]:    An endpoint sends a CONNECTION_CLOSE frame (type=0x1c or 0x1d) to
    TEXT[implementation]:    notify its peer that the connection is being closed.  The
    TEXT[implementation]:    CONNECTION_CLOSE frame with a type of 0x1c is used to signal errors
    TEXT[implementation]:    at only the QUIC layer, or the absence of errors (with the NO_ERROR
    TEXT[implementation]:    code).  The CONNECTION_CLOSE frame with a type of 0x1d is used to
    TEXT[implementation]:    signal an error with the application that uses QUIC.
    TEXT[implementation]:    CONNECTION_CLOSE Frame {
    TEXT[implementation]:      Type (i) = 0x1c..0x1d,
    TEXT[implementation]:      Error Code (i),
    TEXT[implementation]:      [Frame Type (i)],
    TEXT[implementation]:      Reason Phrase Length (i),
    TEXT[implementation]:      Reason Phrase (..),
    TEXT[implementation]:    CONNECTION_CLOSE frames contain the following fields:
    TEXT[implementation]:    Error Code:  A variable-length integer that indicates the reason for
    TEXT[implementation]:       closing this connection.  A CONNECTION_CLOSE frame of type 0x1c
    TEXT[implementation]:       uses codes from the space defined in Section 20.1.  A
    TEXT[implementation]:       CONNECTION_CLOSE frame of type 0x1d uses codes defined by the
    TEXT[implementation]:       application protocol; see Section 20.2.
    TEXT[implementation]:    Frame Type:  A variable-length integer encoding the type of frame
    TEXT[implementation]:       that triggered the error.  A value of 0 (equivalent to the mention
    TEXT[implementation]:       of the PADDING frame) is used when the frame type is unknown.  The
    TEXT[implementation]:       application-specific variant of CONNECTION_CLOSE (type 0x1d) does
    TEXT[implementation]:       not include this field.
    TEXT[implementation]:    Reason Phrase Length:  A variable-length integer specifying the
    TEXT[implementation]:       length of the reason phrase in bytes.  Because a CONNECTION_CLOSE
    TEXT[implementation]:       frame cannot be split between packets, any limits on packet size
    TEXT[implementation]:       will also limit the space available for a reason phrase.
    TEXT[implementation]:    Reason Phrase:  Additional diagnostic information for the closure.
    TEXT[implementation]:       This can be zero length if the sender chooses not to give details
    TEXT[implementation]:       beyond the Error Code value.
    TEXT[!SHOULD,implementation]: This SHOULD be a UTF-8 encoded
    TEXT[!SHOULD,implementation]:       string [RFC3629], though the frame does not carry information,
    TEXT[!SHOULD,implementation]:       such as language tags, that would aid comprehension by any entity
    TEXT[!SHOULD,implementation]:       other than the one that created the text.

  SECTION: [HANDSHAKE_DONE Frames](#section-19.20)
    TEXT[implementation]:    The server uses a HANDSHAKE_DONE frame (type=0x1e) to signal
    TEXT[implementation]:    confirmation of the handshake to the client.
    TEXT[implementation]:    A HANDSHAKE_DONE frame can only be sent by the server.
    TEXT[!MUST]: Servers MUST
    TEXT[!MUST]:    NOT send a HANDSHAKE_DONE frame before completing the handshake.
    TEXT[!MUST,implementation]:    server MUST treat receipt of a HANDSHAKE_DONE frame as a connection
    TEXT[!MUST,implementation]:    error of type PROTOCOL_VIOLATION.

  SECTION: [Extension Frames](#section-19.21)
    TEXT[!MUST]:    An extension to QUIC that wishes to use a new type of frame MUST
    TEXT[!MUST]:    first ensure that a peer is able to understand the frame.
    TEXT[!SHOULD]: Such extensions
    TEXT[!SHOULD]:    SHOULD define their interaction with previously defined extensions
    TEXT[!SHOULD]:    modifying the same protocol components.
    TEXT[!MUST,implementation]:    Extension frames MUST be congestion controlled and MUST cause an ACK
    TEXT[!MUST,implementation]:    frame to be sent.

  SECTION: [Error Codes](#section-20)
    TEXT[implementation]:    QUIC transport error codes and application error codes are 62-bit
    TEXT[implementation]:    unsigned integers.

  SECTION: [Transport Error Codes](#section-20.1)
    TEXT[implementation]:    NO_ERROR (0x00):  An endpoint uses this with CONNECTION_CLOSE to
    TEXT[implementation]:       signal that the connection is being closed abruptly in the absence
    TEXT[implementation]:       of any error.
    TEXT[implementation]:    INTERNAL_ERROR (0x01):  The endpoint encountered an internal error
    TEXT[implementation]:       and cannot continue with the connection.
    TEXT[implementation]:    CONNECTION_REFUSED (0x02):  The server refused to accept a new
    TEXT[implementation]:       connection.
    TEXT[implementation]:    FLOW_CONTROL_ERROR (0x03):  An endpoint received more data than it
    TEXT[implementation]:       permitted in its advertised data limits; see Section 4.
    TEXT[implementation]:    STREAM_LIMIT_ERROR (0x04):  An endpoint received a frame for a stream
    TEXT[implementation]:       identifier that exceeded its advertised stream limit for the
    TEXT[implementation]:       corresponding stream type.
    TEXT[implementation]:    STREAM_STATE_ERROR (0x05):  An endpoint received a frame for a stream
    TEXT[implementation]:       that was not in a state that permitted that frame; see Section 3.
    TEXT[implementation]:    FINAL_SIZE_ERROR (0x06):  (1) An endpoint received a STREAM frame
    TEXT[implementation]:       containing data that exceeded the previously established final
    TEXT[implementation]:       size, (2) an endpoint received a STREAM frame or a RESET_STREAM
    TEXT[implementation]:       frame containing a final size that was lower than the size of
    TEXT[implementation]:       stream data that was already received, or (3) an endpoint received
    TEXT[implementation]:       a STREAM frame or a RESET_STREAM frame containing a different
    TEXT[implementation]:       final size to the one already established.
    TEXT[implementation]:    FRAME_ENCODING_ERROR (0x07):  An endpoint received a frame that was
    TEXT[implementation]:       badly formatted -- for instance, a frame of an unknown type or an
    TEXT[implementation]:       ACK frame that has more acknowledgment ranges than the remainder
    TEXT[implementation]:       of the packet could carry.
    TEXT[implementation]:    TRANSPORT_PARAMETER_ERROR (0x08):  An endpoint received transport
    TEXT[implementation]:       parameters that were badly formatted, included an invalid value,
    TEXT[implementation]:       omitted a mandatory transport parameter, included a forbidden
    TEXT[implementation]:       transport parameter, or were otherwise in error.
    TEXT[implementation]:    CONNECTION_ID_LIMIT_ERROR (0x09):  The number of connection IDs
    TEXT[implementation]:       provided by the peer exceeds the advertised
    TEXT[implementation]:       active_connection_id_limit.
    TEXT[implementation]:    PROTOCOL_VIOLATION (0x0a):  An endpoint detected an error with
    TEXT[implementation]:       protocol compliance that was not covered by more specific error
    TEXT[implementation]:       codes.
    TEXT[implementation]:    INVALID_TOKEN (0x0b):  A server received a client Initial that
    TEXT[implementation]:       contained an invalid Token field.
    TEXT[implementation]:    APPLICATION_ERROR (0x0c):  The application or application protocol
    TEXT[implementation]:       caused the connection to be closed.
    TEXT[implementation]:    CRYPTO_BUFFER_EXCEEDED (0x0d):  An endpoint has received more data in
    TEXT[implementation]:       CRYPTO frames than it can buffer.
    TEXT[implementation]:    CRYPTO_ERROR (0x0100-0x01ff):  The cryptographic handshake failed.  A
    TEXT[implementation]:       range of 256 values is reserved for carrying error codes specific
    TEXT[implementation]:       to the cryptographic handshake that is used.  Codes for errors
    TEXT[implementation]:       occurring when TLS is used for the cryptographic handshake are
    TEXT[implementation]:       described in Section 4.8 of [QUIC-TLS].

  SECTION: [Application Protocol Error Codes](#section-20.2)
    TEXT[implementation]:    The management of application error codes is left to application
    TEXT[implementation]:    protocols.  Application protocol error codes are used for the
    TEXT[implementation]:    RESET_STREAM frame (Section 19.4), the STOP_SENDING frame
    TEXT[implementation]:    (Section 19.5), and the CONNECTION_CLOSE frame with a type of 0x1d
    TEXT[implementation]:    (Section 19.19).

  SECTION: [Handshake Denial of Service](#section-21.2)
    TEXT[implementation]:    Except for Initial and Stateless Resets, an endpoint only accepts
    TEXT[implementation]:    packets that include a Destination Connection ID field that matches a
    TEXT[implementation]:    value the endpoint previously chose.

  SECTION: [Amplification Attack](#section-21.3)
    TEXT[!SHOULD,implementation,test]:    Servers SHOULD provide mitigations for this attack by limiting the
    TEXT[!SHOULD,implementation,test]:    usage and lifetime of address validation tokens; see Section 8.1.3.

  SECTION: [Optimistic ACK Attack](#section-21.4)
    TEXT[implementation]:    An endpoint that acknowledges packets it has not received might cause
    TEXT[implementation]:    a congestion controller to permit sending at rates beyond what the
    TEXT[implementation]:    network supports.
    TEXT[!MAY,implementation]: An endpoint MAY skip packet numbers when sending
    TEXT[!MAY,implementation]:    packets to detect this behavior.
    TEXT[implementation]:   An endpoint can then immediately
    TEXT[implementation]:    close the connection with a connection error of type
    TEXT[implementation]:    PROTOCOL_VIOLATION

  SECTION: [Request Forgery Attacks](#section-21.5)
    TEXT[!SHOULD]: QUIC
    TEXT[!SHOULD]:    servers SHOULD NOT be deployed in networks that do not deploy ingress
    TEXT[!SHOULD]:    filtering [BCP38] and also have inadequately secured UDP endpoints.
    TEXT[!MUST]: Any future extension that allows server migration MUST
    TEXT[!MUST]:    also define countermeasures for forgery attacks.

  SECTION: [Request Forgery with Preferred Addresses](#section-21.5.3)
    TEXT[!MUST]:    A client MUST NOT send non-probing frames to a preferred address
    TEXT[!MUST]:    prior to validating that address; see Section 8.

  SECTION: [Generic Request Forgery Countermeasures](#section-21.5.6)
    TEXT[!MAY,implementation]: Endpoints MAY prevent connection attempts or
    TEXT[!MAY,implementation]:    migration to a loopback address.
    TEXT[!SHOULD,implementation]: Endpoints SHOULD NOT allow
    TEXT[!SHOULD,implementation]:    connections or migration to a loopback address if the same service
    TEXT[!SHOULD,implementation]:    was previously available at a different interface or if the address
    TEXT[!SHOULD,implementation]:    was provided by a service at a non-loopback address.
    TEXT[implementation]:    Similarly, endpoints could regard a change in address to a link-local
    TEXT[implementation]:    address [RFC4291] or an address in a private-use range [RFC1918] from
    TEXT[implementation]:    a global, unique-local [RFC4193], or non-private address as a
    TEXT[implementation]:    potential attempt at request forgery.
    TEXT[!SHOULD]: Endpoints SHOULD NOT refuse to use
    TEXT[!SHOULD]:    an address unless they have specific knowledge about the network
    TEXT[!SHOULD]:    indicating that sending datagrams to unvalidated addresses in a given
    TEXT[!SHOULD]:    range is not safe.
    TEXT[!MAY]:    Endpoints MAY choose to reduce the risk of request forgery by not
    TEXT[!MAY]:    including values from NEW_TOKEN frames in Initial packets or by only
    TEXT[!MAY]:    sending probing frames in packets prior to completing address
    TEXT[!MAY]:    validation.
    TEXT[implementation]: it might be possible over time to identify
    TEXT[implementation]:    specific UDP ports that are common targets of attacks or particular
    TEXT[implementation]:    patterns in datagrams that are used for attacks.
    TEXT[!MAY,implementation]: Endpoints MAY
    TEXT[!MAY,implementation]:    choose to avoid sending datagrams to these ports or not send
    TEXT[!MAY,implementation]:    datagrams that match these patterns prior to validating the
    TEXT[!MAY,implementation]:    destination address.
    TEXT[!MAY]: Endpoints MAY retire connection IDs containing
    TEXT[!MAY]:    patterns known to be problematic without using them.

  SECTION: [Slowloris Attacks](#section-21.6)
    TEXT[!SHOULD,implementation]:    QUIC deployments SHOULD provide mitigations for the Slowloris
    TEXT[!SHOULD,implementation]:    attacks, such as increasing the maximum number of clients the server
    TEXT[!SHOULD,implementation]:    will allow, limiting the number of connections a single IP address is
    TEXT[!SHOULD,implementation]:    allowed to make, imposing restrictions on the minimum transfer speed
    TEXT[!SHOULD,implementation]:    a connection is allowed to have, and restricting the length of time
    TEXT[!SHOULD,implementation]:    an endpoint is allowed to stay connected.

  SECTION: [Stream Fragmentation and Reassembly Attacks](#section-21.7)
    TEXT[!SHOULD]:    QUIC deployments SHOULD provide mitigations for stream fragmentation
    TEXT[!SHOULD]:    attacks.

  SECTION: [Peer Denial of Service](#section-21.9)
    TEXT[!SHOULD,implementation]:    While there are legitimate uses for all messages, implementations
    TEXT[!SHOULD,implementation]:    SHOULD track cost of processing relative to progress and treat
    TEXT[!SHOULD,implementation]:    excessive quantities of any non-productive packets as indicative of
    TEXT[!SHOULD,implementation]:    an attack.
    TEXT[!MAY,implementation]: Endpoints MAY respond to this condition with a connection
    TEXT[!MAY,implementation]:    error or by dropping packets.

  SECTION: [Stateless Reset Oracle](#section-21.11)
    TEXT[!MUST]: To defend
    TEXT[!MUST]:    against this style of denial of service, endpoints that share a
    TEXT[!MUST]:    static key for stateless resets (see Section 10.3.2) MUST be arranged
    TEXT[!MUST]:    so that packets with a given connection ID always arrive at an
    TEXT[!MUST]:    instance that has connection state, unless that connection is no
    TEXT[!MUST]:    longer active.
    TEXT[!MUST]:    More generally, servers MUST NOT generate a stateless reset if a
    TEXT[!MUST]:    connection with the corresponding connection ID could be active on
    TEXT[!MUST]:    any endpoint using the same static key.

  SECTION: [Version Downgrade](#section-21.12)
    TEXT[!MUST]: Future
    TEXT[!MUST]:    versions of QUIC that use Version Negotiation packets MUST define a
    TEXT[!MUST]:    mechanism that is robust against version downgrade attacks.

  SECTION: [Provisional Registrations](#section-22.1.1)
    TEXT[!MAY]:    Provisional registrations MAY omit the Specification and Notes
    TEXT[!MAY]:    fields, plus any additional fields that might be required for a
    TEXT[!MAY]:    permanent registration.

  SECTION: [Selecting Codepoints](#section-22.1.2)
    TEXT[!SHOULD]:    New requests for codepoints from QUIC registries SHOULD use a
    TEXT[!SHOULD]:    randomly selected codepoint that excludes both existing allocations
    TEXT[!SHOULD]:    and the first unallocated codepoint in the selected space.
    TEXT[!MAY]: Requests
    TEXT[!MAY]:    for multiple codepoints MAY use a contiguous range.
    TEXT[!SHOULD]:    For codepoints that are encoded in variable-length integers
    TEXT[!SHOULD]:    (Section 16), such as frame types, codepoints that encode to four or
    TEXT[!SHOULD]:    eight bytes (that is, values 2^14 and above) SHOULD be used unless
    TEXT[!SHOULD]:    the usage is especially sensitive to having a longer encoding.
    TEXT[!MAY]:    Applications to register codepoints in QUIC registries MAY include a
    TEXT[!MAY]:    requested codepoint as part of the registration.
    TEXT[!MUST]: IANA MUST allocate
    TEXT[!MUST]:    the selected codepoint if the codepoint is unassigned and the
    TEXT[!MUST]:    requirements of the registration policy are met.

  SECTION: [Reclaiming Provisional Codepoints](#section-22.1.3)
    TEXT[!SHOULD]: This SHOULD be done only for the
    TEXT[!SHOULD]:    codepoints with the earliest recorded date, and entries that have
    TEXT[!SHOULD]:    been updated less than a year prior SHOULD NOT be reclaimed.
    TEXT[!MUST]:    A request to remove a codepoint MUST be reviewed by the designated
    TEXT[!MUST]:    experts.
    TEXT[!MUST]: The experts MUST attempt to determine whether the codepoint
    TEXT[!MUST]:    is still in use.
    TEXT[!MUST]:    If any use of the codepoints is identified by this search or a
    TEXT[!MUST]:    request to update the registration is made, the codepoint MUST NOT be
    TEXT[!MUST]:    reclaimed.
    TEXT[!MAY]:    If no use of the codepoint was identified and no request was made to
    TEXT[!MAY]:    update the registration, the codepoint MAY be removed from the
    TEXT[!MAY]:    registry.

  SECTION: [Permanent Registrations](#section-22.1.4)
    TEXT[!MAY]: The creation of a registry
    TEXT[!MAY]:    MAY specify additional constraints on permanent registrations.
    TEXT[!MAY]:    The creation of a registry MAY identify a range of codepoints where
    TEXT[!MAY]:    registrations are governed by a different registration policy.
    TEXT[!MUST]:    All registrations made by Standards Track publications MUST be
    TEXT[!MUST]:    permanent.

  SECTION: [QUIC Versions Registry](#section-22.2)
    TEXT[!MUST]:    All codepoints that follow the pattern 0x?a?a?a?a are reserved, MUST
    TEXT[!MUST]:    NOT be assigned by IANA, and MUST NOT appear in the listing of
    TEXT[!MUST]:    assigned values.

  SECTION: [QUIC Transport Parameters Registry](#section-22.3)
    TEXT[!MUST]:    In addition to the fields listed in Section 22.1.1, permanent
    TEXT[!MUST]:    registrations in this registry MUST include the following field:
    TEXT[!MUST]:    Each value of the form "31 * N + 27" for integer values of N (that
    TEXT[!MUST]:    is, 27, 58, 89, ...) are reserved; these values MUST NOT be assigned
    TEXT[!MUST]:    by IANA and MUST NOT appear in the listing of assigned values.

  SECTION: [QUIC Frame Types Registry](#section-22.4)
    TEXT[!MUST]:    In addition to the fields listed in Section 22.1.1, permanent
    TEXT[!MUST]:    registrations in this registry MUST include the following field:
    TEXT[!SHOULD]:    In addition to the advice in Section 22.1, specifications for new
    TEXT[!SHOULD]:    permanent registrations SHOULD describe the means by which an
    TEXT[!SHOULD]:    endpoint might determine that it can send the identified type of
    TEXT[!SHOULD]:    frame.

  SECTION: [QUIC Transport Error Codes Registry](#section-22.5)
    TEXT[!MUST]:    In addition to the fields listed in Section 22.1.1, permanent
    TEXT[!MUST]:    registrations in this registry MUST include the following fields:
    TEXT[!MAY]:    Description:  A brief description of the error code semantics, which
    TEXT[!MAY]:       MAY be a summary if a specification reference is provided.

  SECTION: [Sample Variable-Length Integer Decoding](#appendix-A.1)
    TEXT[implementation]:    For example, the eight-byte sequence 0xc2197c5eff14e88c decodes to
    TEXT[implementation]:    the decimal value 151,288,809,941,952,652; the four-byte sequence
    TEXT[implementation]:    0x9d7f3e7d decodes to 494,878,333; the two-byte sequence 0x7bbd
    TEXT[implementation]:    decodes to 15,293; and the single byte 0x25 decodes to 37 (as does
    TEXT[implementation]:    the two-byte sequence 0x4025).

  SECTION: [Sample Packet Number Encoding Algorithm](#appendix-A.2)
    TEXT[implementation]:    For example, if an endpoint has received an acknowledgment for packet
    TEXT[implementation]:    0xabe8b3 and is sending a packet with a number of 0xac5c02, there are
    TEXT[implementation]:    29,519 (0x734f) outstanding packet numbers.  In order to represent at
    TEXT[implementation]:    least twice this range (59,038 packets, or 0xe69e), 16 bits are
    TEXT[implementation]:    required.
    TEXT[implementation]:    In the same state, sending a packet with a number of 0xace8fe uses
    TEXT[implementation]:    the 24-bit encoding, because at least 18 bits are required to
    TEXT[implementation]:    represent twice the range (131,222 packets, or 0x020096).

  SECTION: [Sample Packet Number Decoding Algorithm](#appendix-A.3)
    TEXT[implementation,test]:    DecodePacketNumber(largest_pn, truncated_pn, pn_nbits):
    TEXT[implementation,test]:       expected_pn  = largest_pn + 1
    TEXT[implementation,test]:       pn_win       = 1 << pn_nbits
    TEXT[implementation,test]:       pn_hwin      = pn_win / 2
    TEXT[implementation,test]:       pn_mask      = pn_win - 1
    TEXT[implementation,test]:       // The incoming packet number should be greater than
    TEXT[implementation,test]:       // expected_pn - pn_hwin and less than or equal to
    TEXT[implementation,test]:       // expected_pn + pn_hwin
    TEXT[implementation,test]:       //
    TEXT[implementation,test]:       // This means we cannot just strip the trailing bits from
    TEXT[implementation,test]:       // expected_pn and add the truncated_pn because that might
    TEXT[implementation,test]:       // yield a value outside the window.
    TEXT[implementation,test]:       //
    TEXT[implementation,test]:       // The following code calculates a candidate value and
    TEXT[implementation,test]:       // makes sure it's within the packet number window.
    TEXT[implementation,test]:       // Note the extra checks to prevent overflow and underflow.
    TEXT[implementation,test]:       candidate_pn = (expected_pn & ~pn_mask) | truncated_pn
    TEXT[implementation,test]:       if candidate_pn <= expected_pn - pn_hwin and
    TEXT[implementation,test]:          candidate_pn < (1 << 62) - pn_win:
    TEXT[implementation,test]:          return candidate_pn + pn_win
    TEXT[implementation,test]:       if candidate_pn > expected_pn + pn_hwin and
    TEXT[implementation,test]:          candidate_pn >= pn_win:
    TEXT[implementation,test]:          return candidate_pn - pn_win
    TEXT[implementation,test]:       return candidate_pn

  SECTION: [Sample ECN Validation Algorithm](#appendix-A.4)
    TEXT[implementation]: On paths with a "testing" or
    TEXT[implementation]:    "capable" state, the endpoint sends packets with an ECT marking --
    TEXT[implementation]:    ECT(0) by default; otherwise, the endpoint sends unmarked packets.
    TEXT[implementation,test]: From the "unknown" state, successful validation of the
    TEXT[implementation,test]:    ECN counts in an ACK frame (see Section 13.4.2.1) causes the ECN
    TEXT[implementation,test]:    state for the path to become "capable", unless no marked packet has
    TEXT[implementation,test]:    been acknowledged.

SPECIFICATION: https://www.rfc-editor.org/rfc/rfc9001
  SECTION: [Carrying TLS Messages](#section-4)
    TEXT[!MUST,implementation]: If QUIC needs to retransmit that data, it MUST use
    TEXT[!MUST,implementation]:    the same keys even if TLS has already updated to newer keys.
    TEXT[!SHOULD,implementation]: When packets of different types need to be sent,
    TEXT[!SHOULD,implementation]:    endpoints SHOULD use coalesced packets to send them in the same UDP
    TEXT[!SHOULD,implementation]:    datagram.

  SECTION: [Handshake Complete](#section-4.1.1)
    TEXT[implementation]: the TLS handshake is considered complete when the
    TEXT[implementation]:    TLS stack has reported that the handshake is complete.  This happens
    TEXT[implementation]:    when the TLS stack has both sent a Finished message and verified the
    TEXT[implementation]:    peer's Finished message.

  SECTION: [Handshake Confirmed](#section-4.1.2)
    TEXT[implementation,test]: the TLS handshake is considered confirmed at the
    TEXT[implementation,test]:    server when the handshake completes.
    TEXT[!MUST,implementation]: The server MUST send a
    TEXT[!MUST,implementation]:    HANDSHAKE_DONE frame as soon as the handshake is complete.
    TEXT[implementation]: At the
    TEXT[implementation]:    client, the handshake is considered confirmed when a HANDSHAKE_DONE
    TEXT[implementation]:    frame is received.
    TEXT[!MAY,exception]:    Additionally, a client MAY consider the handshake to be confirmed
    TEXT[!MAY,exception]:    when it receives an acknowledgment for a 1-RTT packet.

  SECTION: [Sending and Receiving Handshake Messages](#section-4.1.3)
    TEXT[!MUST,implementation]:    *  If the packet is from a previously installed encryption level, it
    TEXT[!MUST,implementation]:       MUST NOT contain data that extends past the end of previously
    TEXT[!MUST,implementation]:       received data in that flow.
    TEXT[!MUST,implementation]: Implementations MUST treat any
    TEXT[!MUST,implementation]:       violations of this requirement as a connection error of type
    TEXT[!MUST,implementation]:       PROTOCOL_VIOLATION.
    TEXT[!MUST,implementation]: When TLS
    TEXT[!MUST,implementation]:       provides keys for a higher encryption level, if there is data from
    TEXT[!MUST,implementation]:       a previous encryption level that TLS has not consumed, this MUST
    TEXT[!MUST,implementation]:       be treated as a connection error of type PROTOCOL_VIOLATION.

  SECTION: [Encryption Level Changes](#section-4.1.4)
    TEXT[!SHOULD,todo]: While waiting for TLS processing to
    TEXT[!SHOULD,todo]:    complete, an endpoint SHOULD buffer received packets if they might be
    TEXT[!SHOULD,todo]:    processed using keys that are not yet available.
    TEXT[!SHOULD,implementation]: An endpoint SHOULD
    TEXT[!SHOULD,implementation]:    continue to respond to packets that can be processed during this
    TEXT[!SHOULD,implementation]:    time.

  SECTION: [TLS Version](#section-4.2)
    TEXT[!MUST,implementation]:    Clients MUST NOT offer TLS versions older than 1.3.
    TEXT[!MUST]: An endpoint MUST terminate the connection if a
    TEXT[!MUST]:    version of TLS older than 1.3 is negotiated.

  SECTION: [ClientHello Size](#section-4.3)
    TEXT[todo]: If the
    TEXT[todo]:    ClientHello spans multiple Initial packets, such servers would need
    TEXT[todo]:    to buffer the first received fragments, which could consume excessive
    TEXT[todo]:    resources if the client's address has not yet been validated.
    TEXT[!MAY,todo]: To
    TEXT[!MAY,todo]:    avoid this, servers MAY use the Retry feature (see Section 8.1 of
    TEXT[!MAY,todo]:    [QUIC-TRANSPORT]) to only buffer partial ClientHello messages from
    TEXT[!MAY,todo]:    clients with a validated address.

  SECTION: [Peer Authentication](#section-4.4)
    TEXT[!MUST,implementation]:    A client MUST authenticate the identity of the server.
    TEXT[!MAY,exception]:    A server MAY request that the client authenticate during the
    TEXT[!MAY,exception]:    handshake.
    TEXT[!MAY,exception]: A server MAY refuse a connection if the client is unable
    TEXT[!MAY,exception]:    to authenticate when requested.
    TEXT[!MUST,exception]:    A server MUST NOT use post-handshake client authentication (as
    TEXT[!MUST,exception]:    defined in Section 4.6.2 of [TLS13]) because the multiplexing offered
    TEXT[!MUST,exception]:    by QUIC prevents clients from correlating the certificate request
    TEXT[!MUST,exception]:    with the application-level event that triggered it (see
    TEXT[!MUST,exception]:    [HTTP2-TLS13]).
    TEXT[!MUST,exception]: More specifically, servers MUST NOT send post-
    TEXT[!MUST,exception]:    handshake TLS CertificateRequest messages, and clients MUST treat
    TEXT[!MUST,exception]:    receipt of such messages as a connection error of type
    TEXT[!MUST,exception]:    PROTOCOL_VIOLATION.

  SECTION: [Session Resumption](#section-4.5)
    TEXT[!SHOULD,exception]: Clients SHOULD NOT reuse tickets as
    TEXT[!SHOULD,exception]:    that allows entities other than the server to correlate connections;
    TEXT[!SHOULD,exception]:    see Appendix C.4 of [TLS13].

  SECTION: [Enabling 0-RTT](#section-4.6.1)
    TEXT[!MUST,todo]:    Servers MUST NOT send the early_data extension with a
    TEXT[!MUST,todo]:    max_early_data_size field set to any value other than 0xffffffff.
    TEXT[!MUST,todo]:    client MUST treat receipt of a NewSessionTicket that contains an
    TEXT[!MUST,todo]:    early_data extension with any other value as a connection error of
    TEXT[!MUST,todo]:    type PROTOCOL_VIOLATION.

  SECTION: [Accepting and Rejecting 0-RTT](#section-4.6.2)
    TEXT[!MUST,todo]: When rejecting 0-RTT, a server MUST NOT
    TEXT[!MUST,todo]:    process any 0-RTT packets, even if it could.
    TEXT[!SHOULD,todo]: When 0-RTT was
    TEXT[!SHOULD,todo]:    rejected, a client SHOULD treat receipt of an acknowledgment for a
    TEXT[!SHOULD,todo]:    0-RTT packet as a connection error of type PROTOCOL_VIOLATION, if it
    TEXT[!SHOULD,todo]:    is able to detect the condition.
    TEXT[!MUST,todo]: The client therefore MUST reset the state of all
    TEXT[!MUST,todo]:    streams, including application state bound to those streams.
    TEXT[!MAY,todo]:    A client MAY reattempt 0-RTT if it receives a Retry or Version
    TEXT[!MAY,todo]:    Negotiation packet.

  SECTION: [HelloRetryRequest](#section-4.7)
    TEXT[!SHOULD,exception]: Although it is in principle possible to use this feature
    TEXT[!SHOULD,exception]:    for address verification, QUIC implementations SHOULD instead use the
    TEXT[!SHOULD,exception]:    Retry feature; see Section 8.1 of [QUIC-TRANSPORT].

  SECTION: [TLS Errors](#section-4.8)
    TEXT[implementation]:    QUIC is only able to convey an alert level of "fatal".  In TLS 1.3,
    TEXT[implementation]:    the only existing uses for the "warning" level are to signal
    TEXT[implementation]:    connection close; see Section 6.1 of [TLS13].
    TEXT[!MUST,implementation]: As QUIC provides
    TEXT[!MUST,implementation]:    alternative mechanisms for connection termination and the TLS
    TEXT[!MUST,implementation]:    connection is only closed if an error is encountered, a QUIC endpoint
    TEXT[!MUST,implementation]:    MUST treat any alert from TLS as if it were at the "fatal" level.
    TEXT[implementation]:    QUIC permits the use of a generic code in place of a specific error
    TEXT[implementation]:    code; see Section 11 of [QUIC-TRANSPORT].  For TLS alerts, this
    TEXT[implementation]:    includes replacing any alert with a generic alert, such as
    TEXT[implementation]:    handshake_failure (0x0128 in QUIC).
    TEXT[!MAY,implementation]: Endpoints MAY use a generic
    TEXT[!MAY,implementation]:    error code to avoid possibly exposing confidential information.

  SECTION: [Discarding Unused Keys](#section-4.9)
    TEXT[!MUST,implementation]: If packets from a lower encryption level contain
    TEXT[!MUST,implementation]:    CRYPTO frames, frames that retransmit that data MUST be sent at the
    TEXT[!MUST,implementation]:    same encryption level.
    TEXT[!MUST,implementation]:    Though an endpoint might retain older keys, new data MUST be sent at
    TEXT[!MUST,implementation]:    the highest currently available encryption level.
    TEXT[!MAY,implementation]: These packets MAY also include PADDING frames.

  SECTION: [Discarding Initial Keys](#section-4.9.1)
    TEXT[!MUST]:    Thus,
    TEXT[!MUST,implementation]: a client MUST discard Initial keys when it first sends a
    TEXT[!MUST,implementation]:    Handshake packet
    TEXT[!MUST]:  and
    TEXT[!MUST,implementation]: a server MUST discard Initial keys when it first
    TEXT[!MUST,implementation]:    successfully processes a Handshake packet.
    TEXT[!MUST,implementation]: Endpoints MUST NOT send
    TEXT[!MUST,implementation]:    Initial packets after this point.

  SECTION: [Discarding Handshake Keys](#section-4.9.2)
    TEXT[!MUST,implementation]:    An endpoint MUST discard its Handshake keys when the TLS handshake is
    TEXT[!MUST,implementation]:    confirmed (Section 4.1.2).

  SECTION: [Discarding 0-RTT Keys](#section-4.9.3)
    TEXT[!SHOULD,implementation]:    Therefore, a client SHOULD discard 0-RTT keys as soon as it installs
    TEXT[!SHOULD,implementation]:    1-RTT keys as they have no use after that moment.
    TEXT[!MAY,todo]:    Additionally, a server MAY discard 0-RTT keys as soon as it receives
    TEXT[!MAY,todo]:    a 1-RTT packet.
    TEXT[!MAY,todo]: Servers MAY temporarily retain
    TEXT[!MAY,todo]:    0-RTT keys to allow decrypting reordered packets without requiring
    TEXT[!MAY,todo]:    their contents to be retransmitted with 1-RTT keys.
    TEXT[!MUST,todo]: After receiving
    TEXT[!MUST,todo]:    a 1-RTT packet, servers MUST discard 0-RTT keys within a short time;
    TEXT[!MUST,todo]:    the RECOMMENDED time period is three times the Probe Timeout (PTO,
    TEXT[!MUST,todo]:    see [QUIC-RECOVERY]).
    TEXT[!MAY,todo]: A server MAY discard 0-RTT keys earlier if it
    TEXT[!MAY,todo]:    determines that it has received all 0-RTT packets, which can be done
    TEXT[!MAY,todo]:    by keeping track of missing packet numbers.

  SECTION: [Packet Protection Keys](#section-5.1)
    TEXT[!MUST,exception]:    Other versions of TLS MUST provide a similar function in order to be
    TEXT[!MUST,exception]:    used with QUIC.
    TEXT[implementation]:    The current encryption level secret and the label "quic key" are
    TEXT[implementation]:    input to the KDF to produce the AEAD key;
    TEXT[implementation]: the label "quic iv" is used
    TEXT[implementation]:    to derive the Initialization Vector (IV); see Section 5.3.
    TEXT[implementation]: The
    TEXT[implementation]:    header protection key uses the "quic hp" label; see Section 5.4.

  SECTION: [Initial Secrets](#section-5.2)
    TEXT[implementation]:    initial_salt = 0x38762cf7f55934b34d179ae6a4c80cadccbb7f0a
    TEXT[implementation]:    client_initial_secret = HKDF-Expand-Label(initial_secret,
    TEXT[implementation]:                                              "client in", "",
    TEXT[implementation]:                                              Hash.length)
    TEXT[implementation]:    server_initial_secret = HKDF-Expand-Label(initial_secret,
    TEXT[implementation]:                                              "server in", "",
    TEXT[implementation]:                                              Hash.length)
    TEXT[!SHOULD,exception]:    Future versions of QUIC SHOULD generate a new salt value, thus
    TEXT[!SHOULD,exception]:    ensuring that the keys are different for each version of QUIC.
    TEXT[!MUST,exception]:    The HKDF-Expand-Label function defined in TLS 1.3 MUST be used for
    TEXT[!MUST,exception]:    Initial packets even where the TLS versions offered do not include
    TEXT[!MUST,exception]:    TLS 1.3.

  SECTION: [AEAD Usage](#section-5.3)
    TEXT[implementation]:    QUIC can use any of the cipher suites defined in [TLS13] with the
    TEXT[implementation]:    exception of TLS_AES_128_CCM_8_SHA256.
    TEXT[!MUST,implementation]: A cipher suite MUST NOT be
    TEXT[!MUST,implementation]:    negotiated unless a header protection scheme is defined for the
    TEXT[!MUST,implementation]:    cipher suite.
    TEXT[!MUST,exception]:    An endpoint MUST NOT reject a ClientHello that offers a cipher suite
    TEXT[!MUST,exception]:    that it does not support, or it would be impossible to deploy a new
    TEXT[!MUST,exception]:    cipher suite.
    TEXT[!MUST,todo]: An endpoint MUST initiate a key update
    TEXT[!MUST,todo]:    (Section 6) prior to exceeding any limit set for the AEAD that is in
    TEXT[!MUST,todo]:    use.

  SECTION: [Header Protection](#section-5.4)
    TEXT[implementation]:    The same header protection key is used for the duration of the
    TEXT[implementation]:    connection, with the value not changing after a key update (see
    TEXT[implementation]:    Section 6).  This allows header protection to be used to protect the
    TEXT[implementation]:    key phase.

  SECTION: [Header Protection Application](#section-5.4.1)
    TEXT[implementation]:    The output of this algorithm is a 5-byte mask that is applied to the
    TEXT[implementation]:    protected header fields using exclusive OR.
    TEXT[implementation]:    Figure 6 shows a sample algorithm for applying header protection.
    TEXT[implementation]:    Removing header protection only differs in the order in which the
    TEXT[implementation]:    packet number length (pn_length) is determined (here "^" is used to
    TEXT[implementation]:    represent exclusive OR).
    TEXT[implementation]:    mask = header_protection(hp_key, sample)
    TEXT[implementation]:    pn_length = (packet[0] & 0x03) + 1
    TEXT[implementation]:    if (packet[0] & 0x80) == 0x80:
    TEXT[implementation]:       # Long header: 4 bits masked
    TEXT[implementation]:       packet[0] ^= mask[0] & 0x0f
    TEXT[implementation]:    else:
    TEXT[implementation]:       # Short header: 5 bits masked
    TEXT[implementation]:       packet[0] ^= mask[0] & 0x1f
    TEXT[implementation]:    # pn_offset is the start of the Packet Number field.
    TEXT[implementation]:    packet[pn_offset:pn_offset+pn_length] ^= mask[1:1+pn_length]
    TEXT[!MUST,exception]:    Before a TLS cipher suite can be used with QUIC, a header protection
    TEXT[!MUST,exception]:    algorithm MUST be specified for the AEAD used with that cipher suite.

  SECTION: [Header Protection Sample](#section-5.4.2)
    TEXT[implementation]: in sampling
    TEXT[implementation]:    packet ciphertext for header protection, the Packet Number field is
    TEXT[implementation]:    assumed to be 4 bytes long
    TEXT[!MUST,implementation]:    An endpoint MUST discard packets that are not long enough to contain
    TEXT[!MUST,implementation]:    a complete sample.

  SECTION: [Receiving Protected Packets](#section-5.5)
    TEXT[!MUST,todo]:    Once an endpoint successfully receives a packet with a given packet
    TEXT[!MUST,todo]:    number, it MUST discard all packets in the same packet number space
    TEXT[!MUST,todo]:    with higher packet numbers if they cannot be successfully unprotected
    TEXT[!MUST,todo]:    with either the same key, or -- if there is a key update -- a
    TEXT[!MUST,todo]:    subsequent packet protection key; see Section 6.
    TEXT[!MUST,todo]: Similarly, a packet
    TEXT[!MUST,todo]:    that appears to trigger a key update but cannot be unprotected
    TEXT[!MUST,todo]:    successfully MUST be discarded.

  SECTION: [Use of 0-RTT Keys](#section-5.6)
    TEXT[!MUST]: A client
    TEXT[!MUST]:    therefore MUST NOT use 0-RTT for application data unless specifically
    TEXT[!MUST]:    requested by the application that is in use.
    TEXT[!MUST]:    An application protocol that uses QUIC MUST include a profile that
    TEXT[!MUST]:    defines acceptable use of 0-RTT; otherwise, 0-RTT can only be used to
    TEXT[!MUST]:    carry QUIC frames that do not carry application data.
    TEXT[!MAY]:    A client MAY wish to apply additional restrictions on what data it
    TEXT[!MAY]:    sends prior to the completion of the TLS handshake.
    TEXT[!SHOULD]: A client SHOULD stop sending 0-RTT data
    TEXT[!SHOULD]:    if it receives an indication that 0-RTT data has been rejected.
    TEXT[!MUST]:    A server MUST NOT use 0-RTT keys to protect packets; it uses 1-RTT
    TEXT[!MUST]:    keys to protect acknowledgments of 0-RTT packets.
    TEXT[!MUST]: A client MUST NOT
    TEXT[!MUST]:    attempt to decrypt 0-RTT packets it receives and instead MUST discard
    TEXT[!MUST]:    them.
    TEXT[!MUST]:    Once a client has installed 1-RTT keys, it MUST NOT send any more
    TEXT[!MUST]:    0-RTT packets.

  SECTION: [Receiving Out-of-Order Protected Packets](#section-5.7)
    TEXT[!MUST,implementation]: Endpoints in either role MUST NOT decrypt 1-RTT packets from
    TEXT[!MUST,implementation]:    their peer prior to completing the handshake.
    TEXT[!MUST,implementation]: A server MUST NOT process
    TEXT[!MUST,implementation]:    incoming 1-RTT protected packets before the TLS handshake is
    TEXT[!MUST,implementation]:    complete.
    TEXT[!MAY]: Received
    TEXT[!MAY]:    packets protected with 1-RTT keys MAY be stored and later decrypted
    TEXT[!MAY]:    and used once the handshake is complete.
    TEXT[!MAY]: The server MAY retain these packets for
    TEXT[!MAY]:    later decryption in anticipation of receiving a ClientHello.
    TEXT[!MUST,implementation]: Even if it has 1-RTT secrets, a client MUST NOT
    TEXT[!MUST,implementation]:    process incoming 1-RTT protected packets before the TLS handshake is
    TEXT[!MUST,implementation]:    complete.

  SECTION: [Retry Packet Integrity](#section-5.8)
    TEXT[implementation]:    Retry packets (see Section 17.2.5 of [QUIC-TRANSPORT]) carry a Retry
    TEXT[implementation]:    Integrity Tag that provides two properties: it allows the discarding
    TEXT[implementation]:    of packets that have accidentally been corrupted by the network, and
    TEXT[implementation]:    only an entity that observes an Initial packet can send a valid Retry
    TEXT[implementation]:    packet.
    TEXT[implementation]:    The Retry Integrity Tag is a 128-bit field that is computed as the
    TEXT[implementation]:    output of AEAD_AES_128_GCM [AEAD] used with the following inputs:
    TEXT[implementation]:    *  The secret key, K, is 128 bits equal to
    TEXT[implementation]:       0xbe0c690b9f66575a1d766b54e368c84e.
    TEXT[implementation]:    *  The nonce, N, is 96 bits equal to 0x461599d35d632bf2239825bb.
    TEXT[implementation]:    Retry Pseudo-Packet {
    TEXT[implementation]:      ODCID Length (8),
    TEXT[implementation]:      Original Destination Connection ID (0..160),
    TEXT[implementation]:      Header Form (1) = 1,
    TEXT[implementation]:      Fixed Bit (1) = 1,
    TEXT[implementation]:      Long Packet Type (2) = 3,
    TEXT[implementation]:      Unused (4),
    TEXT[implementation]:      Version (32),
    TEXT[implementation]:      DCID Len (8),
    TEXT[implementation]:      Destination Connection ID (0..160),
    TEXT[implementation]:      SCID Len (8),
    TEXT[implementation]:      Source Connection ID (0..160),
    TEXT[implementation]:      Retry Token (..),

  SECTION: [Key Update](#section-6)
    TEXT[!MAY,todo]:    Once the handshake is confirmed (see Section 4.1.2), an endpoint MAY
    TEXT[!MAY,todo]:    initiate a key update.
    TEXT[implementation]: The Key Phase bit is initially set to 0 for the
    TEXT[implementation]:    first set of 1-RTT packets and toggled to signal each subsequent key
    TEXT[implementation]:    update.
    TEXT[!MUST,todo]: Endpoints
    TEXT[!MUST,todo]:    MUST NOT send a TLS KeyUpdate message.
    TEXT[!MUST,todo]: Endpoints MUST treat the
    TEXT[!MUST,todo]:    receipt of a TLS KeyUpdate message as a connection error of type
    TEXT[!MUST,todo]:    0x010a, equivalent to a fatal TLS alert of unexpected_message; see
    TEXT[!MUST,todo]:    Section 4.8.

  SECTION: [Initiating a Key Update](#section-6.1)
    TEXT[implementation]:    Endpoints maintain separate read and write secrets for packet
    TEXT[implementation]:    protection.  An endpoint initiates a key update by updating its
    TEXT[implementation]:    packet protection write secret and using that to protect new packets.
    TEXT[implementation]:    The endpoint creates a new write secret from the existing write
    TEXT[implementation]:    secret as performed in Section 7.2 of [TLS13].  This uses the KDF
    TEXT[implementation]:    function provided by TLS with a label of "quic ku".  The
    TEXT[implementation]:    corresponding key and IV are created from that secret as defined in
    TEXT[implementation]:    Section 5.1.  The header protection key is not updated.
    TEXT[!MUST,implementation,todo]:    An endpoint MUST NOT initiate a key update prior to having confirmed
    TEXT[!MUST,implementation,todo]:    the handshake (Section 4.1.2).
    TEXT[!MUST,todo]: An endpoint MUST NOT initiate a
    TEXT[!MUST,todo]:    subsequent key update unless it has received an acknowledgment for a
    TEXT[!MUST,todo]:    packet that was sent protected with keys from the current key phase.
    TEXT[!MUST,todo]:    An endpoint MUST retain old keys until it has successfully
    TEXT[!MUST,todo]:    unprotected a packet sent using the new keys.
    TEXT[!SHOULD,implementation,test,todo]: An endpoint SHOULD
    TEXT[!SHOULD,implementation,test,todo]:    retain old keys for some time after unprotecting a packet sent using
    TEXT[!SHOULD,implementation,test,todo]:    the new keys.

  SECTION: [Responding to a Key Update](#section-6.2)
    TEXT[!MUST,implementation]: The endpoint MUST update its
    TEXT[!MUST,implementation]:    send keys to the corresponding key phase in response, as described in
    TEXT[!MUST,implementation]:    Section 6.1.
    TEXT[!MUST,implementation]: Sending keys MUST be updated before sending an
    TEXT[!MUST,implementation]:    acknowledgment for the packet that was received with updated keys.
    TEXT[!MAY,exception]: An endpoint
    TEXT[!MAY,exception]:    MAY treat such consecutive key updates as a connection error of type
    TEXT[!MAY,exception]:    KEY_UPDATE_ERROR.
    TEXT[!MAY,exception,todo]:    An endpoint that receives an acknowledgment that is carried in a
    TEXT[!MAY,exception,todo]:    packet protected with old keys where any acknowledged packet was
    TEXT[!MAY,exception,todo]:    protected with newer keys MAY treat that as a connection error of
    TEXT[!MAY,exception,todo]:    type KEY_UPDATE_ERROR.

  SECTION: [Timing of Receive Key Generation](#section-6.3)
    TEXT[!MUST,implementation,todo]:    Endpoints responding to an apparent key update MUST NOT generate a
    TEXT[!MUST,implementation,todo]:    timing side-channel signal that might indicate that the Key Phase bit
    TEXT[!MUST,implementation,todo]:    was invalid (see Section 9.5).
    TEXT[!MAY,exception,todo]: An endpoint MAY
    TEXT[!MAY,exception,todo]:    generate new keys as part of packet processing, but this creates a
    TEXT[!MAY,exception,todo]:    timing signal that could be used by an attacker to learn when key
    TEXT[!MAY,exception,todo]:    updates happen and thus leak the value of the Key Phase bit.
    TEXT[!MAY,implementation,todo]: For a short period after a key
    TEXT[!MAY,implementation,todo]:    update completes, up to the PTO, endpoints MAY defer generation of
    TEXT[!MAY,implementation,todo]:    the next set of receive packet protection keys.
    TEXT[implementation,todo]:   This allows
    TEXT[implementation,todo]:    endpoints to retain only two sets of receive keys; see Section 6.5.
    TEXT[!SHOULD,implementation,todo]:    Once generated, the next set of packet protection keys SHOULD be
    TEXT[!SHOULD,implementation,todo]:    retained, even if the packet that was received was subsequently
    TEXT[!SHOULD,implementation,todo]:    discarded.
    TEXT[!MUST,implementation,test]:    For this reason, endpoints MUST be able to retain two sets of packet
    TEXT[!MUST,implementation,test]:    protection keys for receiving packets: the current and the next.

  SECTION: [Sending with Updated Keys](#section-6.4)
    TEXT[!MUST,implementation]:    Packets with higher packet numbers MUST be protected with either the
    TEXT[!MUST,implementation]:    same or newer packet protection keys than packets with lower packet
    TEXT[!MUST,implementation]:    numbers.
    TEXT[!MUST,exception]: An endpoint that successfully removes protection with old
    TEXT[!MUST,exception]:    keys when newer keys were used for packets with lower packet numbers
    TEXT[!MUST,exception]:    MUST treat this as a connection error of type KEY_UPDATE_ERROR.

  SECTION: [Receiving with Different Keys](#section-6.5)
    TEXT[!MAY,implementation,todo]:    An endpoint MAY allow a period of approximately the Probe Timeout
    TEXT[!MAY,implementation,todo]:    (PTO; see [QUIC-RECOVERY]) after promoting the next set of receive
    TEXT[!MAY,implementation,todo]:    keys to be current before it creates the subsequent set of packet
    TEXT[!MAY,implementation,todo]:    protection keys.
    TEXT[!MAY,implementation,todo]: These updated keys MAY replace the previous keys at
    TEXT[!MAY,implementation,todo]:    that time.
    TEXT[!SHOULD,todo]: Endpoints SHOULD wait three times
    TEXT[!SHOULD,todo]:    the PTO before initiating a key update after receiving an
    TEXT[!SHOULD,todo]:    acknowledgment that confirms that the previous key update was
    TEXT[!SHOULD,todo]:    received.
    TEXT[!SHOULD,implementation,todo]:    An endpoint SHOULD retain old read keys for no more than three times
    TEXT[!SHOULD,implementation,todo]:    the PTO after having received a packet protected using the new keys.
    TEXT[!SHOULD,implementation,test,todo]:    After this period, old read keys and their corresponding secrets
    TEXT[!SHOULD,implementation,test,todo]:    SHOULD be discarded.

  SECTION: [Limits on AEAD Usage](#section-6.6)
    TEXT[!MUST,implementation,test]:    Endpoints MUST count the number of encrypted packets for each set of
    TEXT[!MUST,implementation,test]:    keys.
    TEXT[!MUST,implementation,test,todo]: If the total number of encrypted packets with the same key
    TEXT[!MUST,implementation,test,todo]:    exceeds the confidentiality limit for the selected AEAD, the endpoint
    TEXT[!MUST,implementation,test,todo]:    MUST stop using those keys.
    TEXT[!MUST,implementation,test,todo]: Endpoints MUST initiate a key update
    TEXT[!MUST,implementation,test,todo]:    before sending more protected packets than the confidentiality limit
    TEXT[!MUST,implementation,test,todo]:    for the selected AEAD permits.
    TEXT[!MUST,implementation]: If a key update is not possible or
    TEXT[!MUST,implementation]:    integrity limits are reached, the endpoint MUST stop using the
    TEXT[!MUST,implementation]:    connection and only send stateless resets in response to receiving
    TEXT[!MUST,implementation]:    packets.
    TEXT[!SHOULD]: It is RECOMMENDED that endpoints immediately close the
    TEXT[!SHOULD]:    connection with a connection error of type AEAD_LIMIT_REACHED before
    TEXT[!SHOULD]:    reaching a state where key updates are not possible.
    TEXT[implementation]:    For AEAD_AES_128_GCM and AEAD_AES_256_GCM, the confidentiality limit
    TEXT[implementation]:    is 2^23 encrypted packets; see Appendix B.1.
    TEXT[implementation]: For
    TEXT[implementation]:    AEAD_CHACHA20_POLY1305, the confidentiality limit is greater than the
    TEXT[implementation]:    number of possible packets (2^62) and so can be disregarded.
    TEXT[!MUST,implementation,test]:    In addition to counting packets sent, endpoints MUST count the number
    TEXT[!MUST,implementation,test]:    of received packets that fail authentication during the lifetime of a
    TEXT[!MUST,implementation,test]:    connection.
    TEXT[!MUST,implementation,test]: If the total number of received packets that fail
    TEXT[!MUST,implementation,test]:    authentication within the connection, across all keys, exceeds the
    TEXT[!MUST,implementation,test]:    integrity limit for the selected AEAD, the endpoint MUST immediately
    TEXT[!MUST,implementation,test]:    close the connection with a connection error of type
    TEXT[!MUST,implementation,test]:    AEAD_LIMIT_REACHED and not process any more packets.
    TEXT[!MAY]:    Endpoints that limit the size of packets MAY use higher
    TEXT[!MAY]:    confidentiality and integrity limits; see Appendix B for details.
    TEXT[!MAY,exception]:    Future analyses and specifications MAY relax confidentiality or
    TEXT[!MAY,exception]:    integrity limits for an AEAD.
    TEXT[!MUST,implementation,exception]:    Any TLS cipher suite that is specified for use with QUIC MUST define
    TEXT[!MUST,implementation,exception]:    limits on the use of the associated AEAD function that preserves
    TEXT[!MUST,implementation,exception]:    margins for confidentiality and integrity.
    TEXT[!MUST,exception]: That is, limits MUST be
    TEXT[!MUST,exception]:    specified for the number of packets that can be authenticated and for
    TEXT[!MUST,exception]:    the number of packets that can fail authentication.

  SECTION: [Security of Initial Messages](#section-7)
    TEXT[!SHOULD,todo]: Implementations
    TEXT[!SHOULD,todo]:    SHOULD use caution in relying on any data that is contained in
    TEXT[!SHOULD,todo]:    Initial packets that is not otherwise authenticated.

  SECTION: [Protocol Negotiation](#section-8.1)
    TEXT[!MUST,implementation]: Unless another
    TEXT[!MUST,implementation]:    mechanism is used for agreeing on an application protocol, endpoints
    TEXT[!MUST,implementation]:    MUST use ALPN for this purpose.
    TEXT[!MUST,implementation]:    When using ALPN, endpoints MUST immediately close a connection (see
    TEXT[!MUST,implementation]:    Section 10.2 of [QUIC-TRANSPORT]) with a no_application_protocol TLS
    TEXT[!MUST,implementation]:    alert (QUIC error code 0x0178; see Section 4.8) if an application
    TEXT[!MUST,implementation]:    protocol is not negotiated.
    TEXT[!MUST,implementation]: While [ALPN] only specifies that servers
    TEXT[!MUST,implementation]:    use this alert, QUIC clients MUST use error 0x0178 to terminate a
    TEXT[!MUST,implementation]:    connection when ALPN negotiation fails.
    TEXT[!MAY,exception]:    An application protocol MAY restrict the QUIC versions that it can
    TEXT[!MAY,exception]:    operate over.
    TEXT[!MUST,todo]: Servers MUST select an application protocol compatible
    TEXT[!MUST,todo]:    with the QUIC version that the client has selected.
    TEXT[!MUST,todo]: The server MUST
    TEXT[!MUST,todo]:    treat the inability to select a compatible application protocol as a
    TEXT[!MUST,todo]:    connection error of type 0x0178 (no_application_protocol).
    TEXT[!MUST,todo]:    Similarly, a client MUST treat the selection of an incompatible
    TEXT[!MUST,todo]:    application protocol by a server as a connection error of type
    TEXT[!MUST,todo]:    0x0178.

  SECTION: [QUIC Transport Parameters Extension](#section-8.2)
    TEXT[!MUST,implementation]: Endpoints
    TEXT[!MUST,implementation]:    MUST send the quic_transport_parameters extension;
    TEXT[!MUST,implementation]: endpoints that
    TEXT[!MUST,implementation]:    receive ClientHello or EncryptedExtensions messages without the
    TEXT[!MUST,implementation]:    quic_transport_parameters extension MUST close the connection with an
    TEXT[!MUST,implementation]:    error of type 0x016d (equivalent to a fatal TLS missing_extension
    TEXT[!MUST,implementation]:    alert, see Section 4.8).
    TEXT[!MUST,exception]:    Endpoints MUST NOT send this extension in a TLS connection that does
    TEXT[!MUST,exception]:    not use QUIC (such as the use of TLS with TCP defined in [TLS13]).
    TEXT[exception]:   A
    TEXT[!MUST,exception]:    fatal unsupported_extension alert MUST be sent by an implementation
    TEXT[!MUST,exception]:    that supports this extension if the extension is received when the
    TEXT[!MUST,exception]:    transport is not QUIC.

  SECTION: [Removing the EndOfEarlyData Message](#section-8.3)
    TEXT[!MUST,exception]:    Clients MUST NOT send the EndOfEarlyData message.
    TEXT[!MUST,todo]: A server MUST
    TEXT[!MUST,todo]:    treat receipt of a CRYPTO frame in a 0-RTT packet as a connection
    TEXT[!MUST,todo]:    error of type PROTOCOL_VIOLATION.

  SECTION: [Prohibit TLS Middlebox Compatibility Mode](#section-8.4)
    TEXT[!MUST,exception]: A client MUST NOT request the use of the
    TEXT[!MUST,exception]:    TLS 1.3 compatibility mode.
    TEXT[!SHOULD,exception]: A server SHOULD treat the receipt of a
    TEXT[!SHOULD,exception]:    TLS ClientHello with a non-empty legacy_session_id field as a
    TEXT[!SHOULD,exception]:    connection error of type PROTOCOL_VIOLATION.

  SECTION: [Replay Attacks with 0-RTT](#section-9.2)
    TEXT[!MUST,todo]:    Endpoints MUST implement and use the replay protections described in
    TEXT[!MUST,todo]:    [TLS13], however it is recognized that these protections are
    TEXT[!MUST,todo]:    imperfect.
    TEXT[!MUST,exception]: These MUST NOT be
    TEXT[!MUST,exception]:    used to communicate application semantics between endpoints; clients
    TEXT[!MUST,exception]:    MUST treat them as opaque values.
    TEXT[!MUST,todo]: An application
    TEXT[!MUST,todo]:    protocol that uses QUIC MUST describe how the protocol uses 0-RTT and
    TEXT[!MUST,todo]:    the measures that are employed to protect against replay attack.
    TEXT[!MUST,exception]:    QUIC extensions MUST either describe how replay attacks affect their
    TEXT[!MUST,exception]:    operation or prohibit the use of the extension in 0-RTT.
    TEXT[!MUST,exception]: Application
    TEXT[!MUST,exception]:    protocols MUST either prohibit the use of extensions that carry
    TEXT[!MUST,exception]:    application semantics in 0-RTT or provide replay mitigation
    TEXT[!MUST,exception]:    strategies.

  SECTION: [Packet Reflection Attack Mitigation](#section-9.3)
    TEXT[!MUST,implementation]: First, the packet
    TEXT[!MUST,implementation]:    containing a ClientHello MUST be padded to a minimum size.

  SECTION: [Header Protection Analysis](#section-9.4)
    TEXT[!MUST,exception]:    Future header protection variants based on this construction MUST use
    TEXT[!MUST,exception]:    a PRF to ensure equivalent security guarantees.

  SECTION: [Header Protection Timing Side Channels](#section-9.5)
    TEXT[!MUST,implementation,todo]: For authentication to be
    TEXT[!MUST,implementation,todo]:    free from side channels, the entire process of header protection
    TEXT[!MUST,implementation,todo]:    removal, packet number recovery, and packet protection removal MUST
    TEXT[!MUST,implementation,todo]:    be applied together without timing and other side channels.
    TEXT[!MUST,todo]:    For the sending of packets, construction and protection of packet
    TEXT[!MUST,todo]:    payloads and packet numbers MUST be free from side channels that
    TEXT[!MUST,todo]:    would reveal the packet number or its encoded size.
    TEXT[!SHOULD]: After
    TEXT[!SHOULD]:    receiving a key update, an endpoint SHOULD generate and save the next
    TEXT[!SHOULD]:    set of receive packet protection keys, as described in Section 6.3.

  SECTION: [Key Diversity](#section-9.6)
    TEXT[!SHOULD,exception]:    To preserve this separation, a new version of QUIC SHOULD define new
    TEXT[!SHOULD,exception]:    labels for key derivation for packet protection key and IV, plus the
    TEXT[!SHOULD,exception]:    header protection keys.
    TEXT[!SHOULD,exception]: New QUIC versions SHOULD define a new salt value used in
    TEXT[!SHOULD,exception]:    calculating initial secrets.

  SECTION: [Sample Packet Protection](#appendix-A)
    TEXT[implementation]:    These packets use an 8-byte client-chosen Destination Connection ID
    TEXT[implementation]:    of 0x8394c8f03e515708.

  SECTION: [Keys](#appendix-A.1)
    TEXT[implementation]:    The labels generated during the execution of the HKDF-Expand-Label
    TEXT[implementation]:    function (that is, HkdfLabel.label) and part of the value given to
    TEXT[implementation]:    the HKDF-Expand function in order to produce its output are:
    TEXT[implementation]:    client in:  00200f746c73313320636c69656e7420696e00
    TEXT[implementation]:    server in:  00200f746c7331332073657276657220696e00
    TEXT[implementation]:    quic key:  00100e746c7331332071756963206b657900
    TEXT[implementation]:    quic iv:  000c0d746c733133207175696320697600
    TEXT[implementation]:    quic hp:  00100d746c733133207175696320687000
    TEXT[implementation]:    client_initial_secret
    TEXT[implementation]:        = HKDF-Expand-Label(initial_secret, "client in", "", 32)
    TEXT[implementation]:        = c00cf151ca5be075ed0ebfb5c80323c4
    TEXT[implementation]:          2d6b7db67881289af4008f1f6c357aea
    TEXT[implementation]:    server_initial_secret
    TEXT[implementation]:        = HKDF-Expand-Label(initial_secret, "server in", "", 32)
    TEXT[implementation]:        = 3c199828fd139efd216c155ad844cc81
    TEXT[implementation]:          fb82fa8d7446fa7d78be803acdda951b

  SECTION: [Client Initial](#appendix-A.2)
    TEXT[implementation]:    The client sends an Initial packet.  The unprotected payload of this
    TEXT[implementation]:    packet contains the following CRYPTO frame, plus enough PADDING
    TEXT[implementation]:    frames to make a 1162-byte payload:
    TEXT[implementation]:    060040f1010000ed0303ebf8fa56f129 39b9584a3896472ec40bb863cfd3e868
    TEXT[implementation]:    04fe3a47f06a2b69484c000004130113 02010000c000000010000e00000b6578
    TEXT[implementation]:    616d706c652e636f6dff01000100000a 00080006001d00170018001000070005
    TEXT[implementation]:    04616c706e0005000501000000000033 00260024001d00209370b2c9caa47fba
    TEXT[implementation]:    baf4559fedba753de171fa71f50f1ce1 5d43e994ec74d748002b000302030400
    TEXT[implementation]:    0d0010000e0403050306030203080408 050806002d00020101001c0002400100
    TEXT[implementation]:    3900320408ffffffffffffffff050480 00ffff07048000ffff08011001048000
    TEXT[implementation]:    75300901100f088394c8f03e51570806 048000ffff
    TEXT[implementation]:    The unprotected header indicates a length of 1182 bytes: the 4-byte
    TEXT[implementation]:    packet number, 1162 bytes of frames, and the 16-byte authentication
    TEXT[implementation]:    tag.  The header includes the connection ID and a packet number of 2:
    TEXT[implementation]:    c300000001088394c8f03e5157080000449e00000002
    TEXT[implementation]:    Protecting the payload produces output that is sampled for header
    TEXT[implementation]:    protection.  Because the header uses a 4-byte packet number encoding,
    TEXT[implementation]:    the first 16 bytes of the protected payload is sampled and then
    TEXT[implementation]:    applied to the header as follows:
    TEXT[implementation]:    sample = d1b1c98dd7689fb8ec11d242b123dc9b
    TEXT[implementation]:    mask = AES-ECB(hp, sample)[0..4]
    TEXT[implementation]:         = 437b9aec36
    TEXT[implementation]:    header[0] ^= mask[0] & 0x0f
    TEXT[implementation]:         = c0
    TEXT[implementation]:    header[18..21] ^= mask[1..4]
    TEXT[implementation]:         = 7b9aec34
    TEXT[implementation]:    header = c000000001088394c8f03e5157080000449e7b9aec34
    TEXT[implementation]:    The resulting protected packet is:
    TEXT[implementation]:    c000000001088394c8f03e5157080000 449e7b9aec34d1b1c98dd7689fb8ec11
    TEXT[implementation]:    d242b123dc9bd8bab936b47d92ec356c 0bab7df5976d27cd449f63300099f399
    TEXT[implementation]:    1c260ec4c60d17b31f8429157bb35a12 82a643a8d2262cad67500cadb8e7378c
    TEXT[implementation]:    8eb7539ec4d4905fed1bee1fc8aafba1 7c750e2c7ace01e6005f80fcb7df6212
    TEXT[implementation]:    30c83711b39343fa028cea7f7fb5ff89 eac2308249a02252155e2347b63d58c5
    TEXT[implementation]:    457afd84d05dfffdb20392844ae81215 4682e9cf012f9021a6f0be17ddd0c208
    TEXT[implementation]:    4dce25ff9b06cde535d0f920a2db1bf3 62c23e596d11a4f5a6cf3948838a3aec
    TEXT[implementation]:    4e15daf8500a6ef69ec4e3feb6b1d98e 610ac8b7ec3faf6ad760b7bad1db4ba3
    TEXT[implementation]:    485e8a94dc250ae3fdb41ed15fb6a8e5 eba0fc3dd60bc8e30c5c4287e53805db
    TEXT[implementation]:    059ae0648db2f64264ed5e39be2e20d8 2df566da8dd5998ccabdae053060ae6c
    TEXT[implementation]:    7b4378e846d29f37ed7b4ea9ec5d82e7 961b7f25a9323851f681d582363aa5f8
    TEXT[implementation]:    9937f5a67258bf63ad6f1a0b1d96dbd4 faddfcefc5266ba6611722395c906556
    TEXT[implementation]:    be52afe3f565636ad1b17d508b73d874 3eeb524be22b3dcbc2c7468d54119c74
    TEXT[implementation]:    68449a13d8e3b95811a198f3491de3e7 fe942b330407abf82a4ed7c1b311663a
    TEXT[implementation]:    c69890f4157015853d91e923037c227a 33cdd5ec281ca3f79c44546b9d90ca00
    TEXT[implementation]:    f064c99e3dd97911d39fe9c5d0b23a22 9a234cb36186c4819e8b9c5927726632
    TEXT[implementation]:    291d6a418211cc2962e20fe47feb3edf 330f2c603a9d48c0fcb5699dbfe58964
    TEXT[implementation]:    25c5bac4aee82e57a85aaf4e2513e4f0 5796b07ba2ee47d80506f8d2c25e50fd
    TEXT[implementation]:    14de71e6c418559302f939b0e1abd576 f279c4b2e0feb85c1f28ff18f58891ff
    TEXT[implementation]:    ef132eef2fa09346aee33c28eb130ff2 8f5b766953334113211996d20011a198
    TEXT[implementation]:    e3fc433f9f2541010ae17c1bf202580f 6047472fb36857fe843b19f5984009dd
    TEXT[implementation]:    c324044e847a4f4a0ab34f719595de37 252d6235365e9b84392b061085349d73
    TEXT[implementation]:    203a4a13e96f5432ec0fd4a1ee65accd d5e3904df54c1da510b0ff20dcc0c77f
    TEXT[implementation]:    cb2c0e0eb605cb0504db87632cf3d8b4 dae6e705769d1de354270123cb11450e
    TEXT[implementation]:    fc60ac47683d7b8d0f811365565fd98c 4c8eb936bcab8d069fc33bd801b03ade
    TEXT[implementation]:    a2e1fbc5aa463d08ca19896d2bf59a07 1b851e6c239052172f296bfb5e724047
    TEXT[implementation]:    90a2181014f3b94a4e97d117b4381303 68cc39dbb2d198065ae3986547926cd2
    TEXT[implementation]:    162f40a29f0c3c8745c0f50fba3852e5 66d44575c29d39a03f0cda721984b6f4
    TEXT[implementation]:    40591f355e12d439ff150aab7613499d bd49adabc8676eef023b15b65bfc5ca0
    TEXT[implementation]:    6948109f23f350db82123535eb8a7433 bdabcb909271a6ecbcb58b936a88cd4e
    TEXT[implementation]:    8f2e6ff5800175f113253d8fa9ca8885 c2f552e657dc603f252e1a8e308f76f0
    TEXT[implementation]:    be79e2fb8f5d5fbbe2e30ecadd220723 c8c0aea8078cdfcb3868263ff8f09400
    TEXT[implementation]:    54da48781893a7e49ad5aff4af300cd8 04a6b6279ab3ff3afb64491c85194aab
    TEXT[implementation]:    760d58a606654f9f4400e8b38591356f bf6425aca26dc85244259ff2b19c41b9
    TEXT[implementation]:    f96f3ca9ec1dde434da7d2d392b905dd f3d1f9af93d1af5950bd493f5aa731b4
    TEXT[implementation]:    056df31bd267b6b90a079831aaf579be 0a39013137aac6d404f518cfd4684064
    TEXT[implementation]:    7e78bfe706ca4cf5e9c5453e9f7cfd2b 8b4c8d169a44e55c88d4a9a7f9474241
    TEXT[implementation]:    e221af44860018ab0856972e194cd934

  SECTION: [Server Initial](#appendix-A.3)
    TEXT[implementation]:    The server sends the following payload in response, including an ACK
    TEXT[implementation]:    frame, a CRYPTO frame, and no PADDING frames:
    TEXT[implementation]:    02000000000600405a020000560303ee fce7f7b37ba1d1632e96677825ddf739
    TEXT[implementation]:    88cfc79825df566dc5430b9a045a1200 130100002e00330024001d00209d3c94
    TEXT[implementation]:    0d89690b84d08a60993c144eca684d10 81287c834d5311bcf32bb9da1a002b00
    TEXT[implementation]:    020304
    TEXT[implementation]:    The header from the server includes a new connection ID and a 2-byte
    TEXT[implementation]:    packet number encoding for a packet number of 1:
    TEXT[implementation]:    c1000000010008f067a5502a4262b50040750001
    TEXT[implementation]:    As a result, after protection, the header protection sample is taken
    TEXT[implementation]:    starting from the third protected byte:
    TEXT[implementation]:    sample = 2cd0991cd25b0aac406a5816b6394100
    TEXT[implementation]:    mask   = 2ec0d8356a
    TEXT[implementation]:    header = cf000000010008f067a5502a4262b5004075c0d9
    TEXT[implementation]:    The final protected packet is then:
    TEXT[implementation]:    cf000000010008f067a5502a4262b500 4075c0d95a482cd0991cd25b0aac406a
    TEXT[implementation]:    5816b6394100f37a1c69797554780bb3 8cc5a99f5ede4cf73c3ec2493a1839b3
    TEXT[implementation]:    dbcba3f6ea46c5b7684df3548e7ddeb9 c3bf9c73cc3f3bded74b562bfb19fb84
    TEXT[implementation]:    022f8ef4cdd93795d77d06edbb7aaf2f 58891850abbdca3d20398c276456cbc4
    TEXT[implementation]:    2158407dd074ee

  SECTION: [Retry](#appendix-A.4)
    TEXT[implementation]:    This shows a Retry packet that might be sent in response to the
    TEXT[implementation]:    Initial packet in Appendix A.2.  The integrity check includes the
    TEXT[implementation]:    client-chosen connection ID value of 0x8394c8f03e515708, but that
    TEXT[implementation]:    value is not included in the final Retry packet:
    TEXT[implementation]:    ff000000010008f067a5502a4262b574 6f6b656e04a265ba2eff4d829058fb3f
    TEXT[implementation]:    0f2496ba

  SECTION: [ChaCha20-Poly1305 Short Header Packet](#appendix-A.5)
    TEXT[implementation]:    In this example, TLS produces an application write secret from which
    TEXT[implementation]:    a server uses HKDF-Expand-Label to produce four values: a key, an IV,
    TEXT[implementation]:    a header protection key, and the secret that will be used after keys
    TEXT[implementation]:    are updated (this last value is not used further in this example).
    TEXT[implementation]:    secret
    TEXT[implementation]:        = 9ac312a7f877468ebe69422748ad00a1
    TEXT[implementation]:          5443f18203a07d6060f688f30f21632b
    TEXT[implementation]:    key = HKDF-Expand-Label(secret, "quic key", "", 32)
    TEXT[implementation]:        = c6d98ff3441c3fe1b2182094f69caa2e
    TEXT[implementation]:          d4b716b65488960a7a984979fb23e1c8
    TEXT[implementation]:    iv  = HKDF-Expand-Label(secret, "quic iv", "", 12)
    TEXT[implementation]:        = e0459b3474bdd0e44a41c144
    TEXT[implementation]:    hp  = HKDF-Expand-Label(secret, "quic hp", "", 32)
    TEXT[implementation]:        = 25a282b9e82f06f21f488917a4fc8f1b
    TEXT[implementation]:          73573685608597d0efcb076b0ab7a7a4
    TEXT[implementation]:    ku  = HKDF-Expand-Label(secret, "quic ku", "", 32)
    TEXT[implementation]:        = 1223504755036d556342ee9361d25342
    TEXT[implementation]:          1a826c9ecdf3c7148684b36b714881f9

SPECIFICATION: https://www.rfc-editor.org/rfc/rfc9002
  SECTION: [Conventions and Definitions](#section-2)
    TEXT[implementation]:    Ack-eliciting frames:  All frames other than ACK, PADDING, and
    TEXT[implementation]:       CONNECTION_CLOSE are considered ack-eliciting.
    TEXT[implementation]:    Ack-eliciting packets:  Packets that contain ack-eliciting frames
    TEXT[implementation]:       elicit an ACK from the receiver within the maximum acknowledgment
    TEXT[implementation]:       delay and are called ack-eliciting packets.
    TEXT[exception]: Packets are considered in flight when they are
    TEXT[exception]:       ack-eliciting or contain a PADDING frame

  SECTION: [Design of the QUIC Transmission Machinery](#section-3)
    TEXT[implementation]: Packets containing frames besides ACK or CONNECTION_CLOSE frames
    TEXT[implementation]:       count toward congestion control limits and are considered to be in
    TEXT[implementation]:       flight.
    TEXT[exception]: PADDING frames cause packets to contribute toward bytes in flight
    TEXT[exception]:       without directly causing an acknowledgment to be sent.

  SECTION: [Generating RTT Samples](#section-5.1)
    TEXT[implementation]:    An endpoint generates an RTT sample on receiving an ACK frame that
    TEXT[implementation]:    meets the following two conditions:
    TEXT[implementation]:    *  the largest acknowledged packet number is newly acknowledged, and
    TEXT[implementation]:    *  at least one of the newly acknowledged packets was ack-eliciting.
    TEXT[!SHOULD,implementation,test]:    To avoid generating multiple RTT samples for a single packet, an ACK
    TEXT[!SHOULD,implementation,test]:    frame SHOULD NOT be used to update RTT estimates if it does not newly
    TEXT[!SHOULD,implementation,test]:    acknowledge the largest acknowledged packet.
    TEXT[!MUST,implementation,test]:    An RTT sample MUST NOT be generated on receiving an ACK frame that
    TEXT[!MUST,implementation,test]:    does not newly acknowledge at least one ack-eliciting packet.

  SECTION: [Estimating min_rtt](#section-5.2)
    TEXT[!MUST,implementation,test]:    min_rtt MUST be set to the latest_rtt on the first RTT sample.
    TEXT[!MUST,implementation,test]:    min_rtt MUST be set to the lesser of min_rtt and latest_rtt
    TEXT[!MUST,implementation,test]:    (Section 5.1) on all other samples.
    TEXT[!SHOULD,implementation,test]:    Endpoints SHOULD set the min_rtt to the newest RTT sample after
    TEXT[!SHOULD,implementation,test]:    persistent congestion is established.
    TEXT[!MAY,todo]:    Endpoints MAY reestablish the min_rtt at other times in the
    TEXT[!MAY,todo]:    connection, such as when traffic volume is low and an acknowledgment
    TEXT[!MAY,todo]:    is received with a low acknowledgment delay.
    TEXT[!SHOULD,todo]: Implementations SHOULD
    TEXT[!SHOULD,todo]:    NOT refresh the min_rtt value too often since the actual minimum RTT
    TEXT[!SHOULD,todo]:    of the path is not frequently observable.

  SECTION: [Estimating smoothed_rtt and rttvar](#section-5.3)
    TEXT[!SHOULD,implementation,test]: To account for this, the endpoint SHOULD ignore
    TEXT[!SHOULD,implementation,test]:    max_ack_delay until the handshake is confirmed, as defined in
    TEXT[!SHOULD,implementation,test]:    Section 4.1.2 of [QUIC-TLS].
    TEXT[!MAY,implementation,test]: Therefore, prior to handshake confirmation, an endpoint
    TEXT[!MAY,implementation,test]:    MAY ignore RTT samples if adjusting the RTT sample for acknowledgment
    TEXT[!MAY,implementation,test]:    delay causes the sample to be less than the min_rtt.
    TEXT[implementation]: when adjusting an RTT sample using peer-reported
    TEXT[implementation]:    acknowledgment delays, an endpoint:
    TEXT[!MAY,implementation,test]:    *  MAY ignore the acknowledgment delay for Initial packets, since
    TEXT[!MAY,implementation]:       these acknowledgments are not delayed by the peer (Section 13.2.1
    TEXT[!MAY,implementation]:       of [QUIC-TRANSPORT]);
    TEXT[!SHOULD,implementation,test]:    *  SHOULD ignore the peer's max_ack_delay until the handshake is
    TEXT[!SHOULD,implementation,test]:       confirmed;
    TEXT[!MUST,implementation,test]:    *  MUST use the lesser of the acknowledgment delay and the peer's
    TEXT[!MUST,implementation,test]:       max_ack_delay after the handshake is confirmed; and
    TEXT[!MUST,implementation,test]:    *  MUST NOT subtract the acknowledgment delay from the RTT sample if
    TEXT[!MUST,implementation,test]:       the resulting value is smaller than the min_rtt.
    TEXT[!SHOULD,todo]: In such
    TEXT[!SHOULD,todo]:    cases, an endpoint SHOULD subtract such local delays from its RTT
    TEXT[!SHOULD,todo]:    sample until the handshake is confirmed.
    TEXT[implementation]: Before any RTT
    TEXT[implementation]:    samples are available for a new path or when the estimator is reset,
    TEXT[implementation]:    the estimator is initialized using the initial RTT; see
    TEXT[implementation]:    Section 6.2.2.
    TEXT[implementation]:    smoothed_rtt and rttvar are initialized as follows, where kInitialRtt
    TEXT[implementation]:    contains the initial RTT value:
    TEXT[implementation]:    On the first RTT sample after initialization, smoothed_rtt and rttvar
    TEXT[implementation]:    are set as follows:
    TEXT[implementation]:    smoothed_rtt = latest_rtt
    TEXT[implementation]:    rttvar = latest_rtt / 2
    TEXT[implementation]:    On subsequent RTT samples, smoothed_rtt and rttvar evolve as follows:
    TEXT[implementation]:    ack_delay = decoded acknowledgment delay from ACK frame
    TEXT[implementation]:    if (handshake confirmed):
    TEXT[implementation]:      ack_delay = min(ack_delay, max_ack_delay)
    TEXT[implementation]:    adjusted_rtt = latest_rtt
    TEXT[implementation]:    if (latest_rtt >= min_rtt + ack_delay):
    TEXT[implementation]:      adjusted_rtt = latest_rtt - ack_delay
    TEXT[implementation]:    smoothed_rtt = 7/8 * smoothed_rtt + 1/8 * adjusted_rtt
    TEXT[implementation]:    rttvar_sample = abs(smoothed_rtt - adjusted_rtt)
    TEXT[implementation]:    rttvar = 3/4 * rttvar + 1/4 * rttvar_sample

  SECTION: [Acknowledgment-Based Detection](#section-6.1)
    TEXT[implementation]:    A packet is declared lost if it meets all of the following
    TEXT[implementation]:    conditions:
    TEXT[implementation]:    *  The packet is unacknowledged, in flight, and was sent prior to an
    TEXT[implementation]:       acknowledged packet.
    TEXT[implementation]:    *  The packet was sent kPacketThreshold packets before an
    TEXT[implementation]:       acknowledged packet (Section 6.1.1), or it was sent long enough in
    TEXT[implementation]:       the past (Section 6.1.2).
    TEXT[!MAY,todo]: Implementations with adaptive time
    TEXT[!MAY,todo]:    thresholds MAY choose to start with smaller initial reordering
    TEXT[!MAY,todo]:    thresholds to minimize recovery latency.

  SECTION: [Packet Threshold](#section-6.1.1)
    TEXT[!SHOULD,implementation,test]:    The RECOMMENDED initial value for the packet reordering threshold
    TEXT[!SHOULD,implementation,test]:    (kPacketThreshold) is 3, based on best practices for TCP loss
    TEXT[!SHOULD,implementation,test]:    detection [RFC5681] [RFC6675].
    TEXT[!SHOULD,implementation,test]: In order to remain similar to TCP,
    TEXT[!SHOULD,implementation,test]:    implementations SHOULD NOT use a packet threshold less than 3; see
    TEXT[!SHOULD,implementation,test]:    [RFC5681].

  SECTION: [Time Threshold](#section-6.1.2)
    TEXT[!SHOULD,implementation,test]:    Once a later packet within the same packet number space has been
    TEXT[!SHOULD,implementation,test]:    acknowledged, an endpoint SHOULD declare an earlier packet lost if it
    TEXT[!SHOULD,implementation,test]:    was sent a threshold amount of time in the past.
    TEXT[!MUST,implementation,test]: To avoid declaring
    TEXT[!MUST,implementation,test]:    packets as lost too early, this time threshold MUST be set to at
    TEXT[!MUST,implementation,test]:    least the local timer granularity, as indicated by the kGranularity
    TEXT[!MUST,implementation,test]:    constant.
    TEXT[implementation]: The time threshold is:
    TEXT[implementation]:    max(kTimeThreshold * max(smoothed_rtt, latest_rtt), kGranularity)
    TEXT[!SHOULD,implementation,test]:    If packets sent prior to the largest acknowledged packet cannot yet
    TEXT[!SHOULD,implementation,test]:    be declared lost, then a timer SHOULD be set for the remaining time.
    TEXT[!SHOULD,implementation,test]:    The RECOMMENDED time threshold (kTimeThreshold), expressed as an RTT
    TEXT[!SHOULD,implementation,test]:    multiplier, is 9/8.
    TEXT[!SHOULD,implementation,test]: The RECOMMENDED value of the timer granularity
    TEXT[!SHOULD,implementation,test]:    (kGranularity) is 1 millisecond.
    TEXT[!MAY,todo]:    Implementations MAY experiment with absolute thresholds, thresholds
    TEXT[!MAY,todo]:    from previous connections, adaptive thresholds, or the including of
    TEXT[!MAY,todo]:    RTT variation.

  SECTION: [Probe Timeout](#section-6.2)
    TEXT[implementation]:    A Probe Timeout (PTO) triggers the sending of one or two probe
    TEXT[implementation]:    datagrams when ack-eliciting packets are not acknowledged within the
    TEXT[implementation]:    expected period of time or the server may not have validated the
    TEXT[implementation]:    client's address.  A PTO enables a connection to recover from loss of
    TEXT[implementation]:    tail packets or acknowledgments.
    TEXT[!MUST,implementation,test]:    A PTO timer expiration event does not indicate packet loss and MUST
    TEXT[!MUST,implementation,test]:    NOT cause prior unacknowledged packets to be marked as lost.

  SECTION: [Computing PTO](#section-6.2.1)
    TEXT[implementation]:    When an ack-eliciting packet is transmitted, the sender schedules a
    TEXT[implementation]:    timer for the PTO period as follows:
    TEXT[implementation]:    PTO = smoothed_rtt + max(4*rttvar, kGranularity) + max_ack_delay
    TEXT[implementation]:    The PTO period is the amount of time that a sender ought to wait for
    TEXT[implementation]:    an acknowledgment of a sent packet.
    TEXT[implementation]:    When the PTO is armed for Initial or Handshake packet number spaces,
    TEXT[implementation]:    the max_ack_delay in the PTO period computation is set to 0, since
    TEXT[implementation]:    the peer is expected to not delay these packets intentionally; see
    TEXT[implementation]:    Section 13.2.1 of [QUIC-TRANSPORT].
    TEXT[!MUST,implementation,test]:    The PTO period MUST be at least kGranularity to avoid the timer
    TEXT[!MUST,implementation,test]:    expiring immediately.
    TEXT[!MUST,implementation]:    When ack-eliciting packets in multiple packet number spaces are in
    TEXT[!MUST,implementation]:    flight, the timer MUST be set to the earlier value of the Initial and
    TEXT[!MUST,implementation]:    Handshake packet number spaces.
    TEXT[!MUST,implementation,test]:    An endpoint MUST NOT set its PTO timer for the Application Data
    TEXT[!MUST,implementation,test]:    packet number space until the handshake is confirmed.
    TEXT[!SHOULD,implementation,test]:    A sender SHOULD restart its PTO timer every time an ack-eliciting
    TEXT[!SHOULD,implementation,test]:    packet is sent
    TEXT[!SHOULD,implementation]:  or acknowledged, or when Initial or Handshake keys are
    TEXT[!SHOULD,implementation]:    discarded (Section 4.9 of [QUIC-TLS]).
    TEXT[!MUST,implementation,test]:    When a PTO timer expires, the PTO backoff MUST be increased,
    TEXT[!MUST,implementation,test]:    resulting in the PTO period being set to twice its current value.
    TEXT[implementation]:    The PTO backoff factor is reset when an acknowledgment is received,
    TEXT[implementation]:    except in the following case.  A server might take longer to respond
    TEXT[implementation]:    to packets during the handshake than otherwise.  To protect such a
    TEXT[implementation]:    server from repeated client probes, the PTO backoff is not reset at a
    TEXT[implementation]:    client that is not yet certain that the server has finished
    TEXT[implementation]:    validating the client's address.  That is, a client does not reset
    TEXT[implementation]:    the PTO backoff factor on receiving acknowledgments in Initial
    TEXT[implementation]:    packets.
    TEXT[implementation]: Even when there are ack-
    TEXT[implementation]:    eliciting packets in flight in multiple packet number spaces, the
    TEXT[implementation]:    exponential increase in PTO occurs across all spaces to prevent
    TEXT[implementation]:    excess load on the network.  For example, a timeout in the Initial
    TEXT[implementation]:    packet number space doubles the length of the timeout in the
    TEXT[implementation]:    Handshake packet number space.
    TEXT[!MUST,implementation,test]:    The PTO timer MUST NOT be set if a timer is set for time threshold
    TEXT[!MUST,implementation,test]:    loss detection; see Section 6.1.2.
    TEXT[implementation]:   A timer that is set for time
    TEXT[implementation]:    threshold loss detection will expire earlier than the PTO timer in
    TEXT[implementation]:    most cases and is less likely to spuriously retransmit data.

  SECTION: [Handshakes and New Paths](#section-6.2.2)
    TEXT[!MAY,todo]:    Resumed connections over the same network MAY use the previous
    TEXT[!MAY,todo]:    connection's final smoothed RTT value as the resumed connection's
    TEXT[!MAY,todo]:    initial RTT.
    TEXT[!SHOULD,implementation,test]: When no previous RTT is available, the initial RTT
    TEXT[!SHOULD,implementation,test]:    SHOULD be set to 333 milliseconds.
    TEXT[implementation,test]:   This results in handshakes
    TEXT[implementation,test]:    starting with a PTO of 1 second, as recommended for TCP's initial
    TEXT[implementation,test]:    RTO; see Section 2 of [RFC6298].
    TEXT[!SHOULD,exception]:    A connection MAY use the delay between sending a PATH_CHALLENGE and
    TEXT[!SHOULD,exception]:    receiving a PATH_RESPONSE to set the initial RTT (see kInitialRtt in
    TEXT[!SHOULD,exception]:    Appendix A.2) for a new path, but the delay SHOULD NOT be considered
    TEXT[!SHOULD,exception]:    an RTT sample.
    TEXT[!MUST,implementation]: When
    TEXT[!MUST,implementation]:    Initial or Handshake keys are discarded, the PTO and loss detection
    TEXT[!MUST,implementation]:    timers MUST be reset, because discarding keys indicates forward
    TEXT[!MUST,implementation]:    progress and the loss detection timer might have been set for a now-
    TEXT[!MUST,implementation]:    discarded packet number space.

  SECTION: [Before Address Validation](#section-6.2.2.1)
    TEXT[!MUST,implementation,test]: If
    TEXT[!MUST,implementation,test]:    no additional data can be sent, the server's PTO timer MUST NOT be
    TEXT[!MUST,implementation,test]:    armed until datagrams have been received from the client because
    TEXT[!MUST,implementation,test]:    packets sent on PTO count against the anti-amplification limit.
    TEXT[implementation]:    Since the server could be blocked until more datagrams are received
    TEXT[implementation]:    from the client, it is the client's responsibility to send packets to
    TEXT[implementation]:    unblock the server until it is certain that the server has finished
    TEXT[implementation]:    its address validation
    TEXT[!MUST,implementation,test]: That is,
    TEXT[!MUST,implementation,test]:    the client MUST set the PTO timer if the client has not received an
    TEXT[!MUST,implementation,test]:    acknowledgment for any of its Handshake packets and the handshake is
    TEXT[!MUST,implementation,test]:    not confirmed (see Section 4.1.2 of [QUIC-TLS]), even if there are no
    TEXT[!MUST,implementation,test]:    packets in flight.
    TEXT[!MUST,implementation]: When the PTO fires, the client MUST send a
    TEXT[!MUST,implementation]:    Handshake packet if it has Handshake keys, otherwise it MUST send an
    TEXT[!MUST,implementation]:    Initial packet in a UDP datagram with a payload of at least 1200
    TEXT[!MUST,implementation]:    bytes.

  SECTION: [Speeding up Handshake Completion](#section-6.2.3)
    TEXT[!MAY,todo]:    To speed up handshake completion under these conditions, an endpoint
    TEXT[!MAY,todo]:    MAY, for a limited number of times per connection, send a packet
    TEXT[!MAY,todo]:    containing unacknowledged CRYPTO data earlier than the PTO expiry,
    TEXT[!MAY,todo]:    subject to the address validation limits in Section 8.1 of
    TEXT[!MAY,todo]:    [QUIC-TRANSPORT].

  SECTION: [Sending Probe Packets](#section-6.2.4)
    TEXT[!MUST,implementation,test]:    When a PTO timer expires, a sender MUST send at least one ack-
    TEXT[!MUST,implementation,test]:    eliciting packet in the packet number space as a probe.
    TEXT[!MAY,implementation,test]: An endpoint
    TEXT[!MAY,implementation,test]:    MAY send up to two full-sized datagrams containing ack-eliciting
    TEXT[!MAY,implementation,test]:    packets to avoid an expensive consecutive PTO expiration due to a
    TEXT[!MAY,implementation,test]:    single lost datagram or to transmit data from multiple packet number
    TEXT[!MAY,implementation,test]:    spaces.
    TEXT[!MUST,implementation,test]: All probe packets sent on a PTO MUST be ack-eliciting.
    TEXT[!SHOULD,implementation]:    In addition to sending data in the packet number space for which the
    TEXT[!SHOULD,implementation]:    timer expired, the sender SHOULD send ack-eliciting packets from
    TEXT[!SHOULD,implementation]:    other packet number spaces with in-flight data, coalescing packets if
    TEXT[!SHOULD,implementation]:    possible.
    TEXT[implementation]:    If the sender wants to elicit a faster acknowledgment on PTO, it can
    TEXT[implementation]:    skip a packet number to eliminate the acknowledgment delay.
    TEXT[!SHOULD,implementation]:    An endpoint SHOULD include new data in packets that are sent on PTO
    TEXT[!SHOULD,implementation]:    expiration.
    TEXT[!MAY,implementation]: Previously sent data MAY be sent if no new data can be
    TEXT[!MAY,implementation]:    sent.
    TEXT[!MAY,todo]: Implementations MAY use alternative strategies for determining
    TEXT[!MAY,todo]:    the content of probe packets, including sending new or retransmitted
    TEXT[!MAY,todo]:    data based on the application's priorities.
    TEXT[!SHOULD,implementation,test]: When there is no data to send, the sender SHOULD send
    TEXT[!SHOULD,implementation,test]:    a PING or other ack-eliciting frame in a single packet, rearming the
    TEXT[!SHOULD,implementation,test]:    PTO timer.
    TEXT[!MAY,exception]:    Alternatively, instead of sending an ack-eliciting packet, the sender
    TEXT[!MAY,exception]:    MAY mark any packets still in flight as lost.
    TEXT[implementation]: Sending two packets on PTO
    TEXT[implementation]:    expiration increases resilience to packet drops, thus reducing the
    TEXT[implementation]:    probability of consecutive PTO events.

  SECTION: [Handling Retry Packets](#section-6.3)
    TEXT[!MAY,exception]:    The client MAY compute an RTT estimate to the server as the time
    TEXT[!MAY,exception]:    period from when the first Initial packet was sent to when a Retry or
    TEXT[!MAY,exception]:    a Version Negotiation packet is received.
    TEXT[!MAY,exception]: The client MAY use this
    TEXT[!MAY,exception]:    value in place of its default for the initial RTT estimate.

  SECTION: [Discarding Keys and Packet State](#section-6.4)
    TEXT[implementation]:    When Initial and Handshake packet protection keys are discarded (see
    TEXT[implementation]:    Section 4.9 of [QUIC-TLS]), all packets that were sent with those
    TEXT[implementation]:    keys can no longer be acknowledged because their acknowledgments
    TEXT[implementation]:    cannot be processed.
    TEXT[!MUST,implementation,test]: The sender MUST discard all recovery state
    TEXT[!MUST,implementation,test]:    associated with those packets and MUST remove them from the count of
    TEXT[!MUST,implementation,test]:    bytes in flight.

  SECTION: [Congestion Control](#section-7)
    TEXT[!MUST,exception]:    If a sender uses a different controller than that specified in this
    TEXT[!MUST,exception]:    document, the chosen controller MUST conform to the congestion
    TEXT[!MUST,exception]:    control guidelines specified in Section 3.1 of [RFC8085].
    TEXT[implementation]:    Similar to TCP, packets containing only ACK frames do not count
    TEXT[implementation]:    toward bytes in flight and are not congestion controlled.
    TEXT[!MAY,todo]: Unlike
    TEXT[!MAY,todo]:    TCP, QUIC can detect the loss of these packets and MAY use that
    TEXT[!MAY,todo]:    information to adjust the congestion controller or the rate of ACK-
    TEXT[!MAY,todo]:    only packets being sent, but this document does not describe a
    TEXT[!MAY,todo]:    mechanism for doing so.
    TEXT[!MUST,implementation]:    An endpoint MUST NOT send a packet if it would cause bytes_in_flight
    TEXT[!MUST,implementation]:    (see Appendix B.2) to be larger than the congestion window, unless
    TEXT[!MUST,implementation]:    the packet is sent on a PTO timer expiration (see Section 6.2) or
    TEXT[!MUST,implementation]:    when entering recovery (see Section 7.3.2).

  SECTION: [Explicit Congestion Notification](#section-7.1)
    TEXT[implementation]:    If a path has been validated to support Explicit Congestion
    TEXT[implementation]:    Notification (ECN) [RFC3168] [RFC8311], QUIC treats a Congestion
    TEXT[implementation]:    Experienced (CE) codepoint in the IP header as a signal of
    TEXT[implementation]:    congestion.

  SECTION: [Initial and Minimum Congestion Window](#section-7.2)
    TEXT[!SHOULD,implementation,test]: Endpoints SHOULD use an initial congestion
    TEXT[!SHOULD,implementation,test]:    window of ten times the maximum datagram size (max_datagram_size),
    TEXT[!SHOULD,implementation,test]:    while limiting the window to the larger of 14,720 bytes or twice the
    TEXT[!SHOULD,implementation,test]:    maximum datagram size.
    TEXT[!SHOULD,implementation,test]:    If the maximum datagram size changes during the connection, the
    TEXT[!SHOULD,implementation,test]:    initial congestion window SHOULD be recalculated with the new size.
    TEXT[!SHOULD,implementation,test]:    If the maximum datagram size is decreased in order to complete the
    TEXT[!SHOULD,implementation,test]:    handshake, the congestion window SHOULD be set to the new initial
    TEXT[!SHOULD,implementation,test]:    congestion window.
    TEXT[implementation]:    The minimum congestion window is the smallest value the congestion
    TEXT[implementation]:    window can attain in response to loss, an increase in the peer-
    TEXT[implementation]:    reported ECN-CE count, or persistent congestion.
    TEXT[!SHOULD,implementation,test]: The RECOMMENDED
    TEXT[!SHOULD,implementation,test]:    value is 2 * max_datagram_size.

  SECTION: [Congestion Control States](#section-7.3)
    TEXT[implementation]:                     New path or      +------------+
    TEXT[implementation]:                persistent congestion |   Slow     |
    TEXT[implementation]:            (O)---------------------->|   Start    |
    TEXT[implementation]:                                      +------------+
    TEXT[implementation]:                                    Loss or |
    TEXT[implementation]:                            ECN-CE increase |
    TEXT[implementation]:     +------------+     Loss or       +------------+
    TEXT[implementation]:     | Congestion |  ECN-CE increase  |  Recovery  |
    TEXT[implementation]:     | Avoidance  |------------------>|   Period   |
    TEXT[implementation]:     +------------+                   +------------+
    TEXT[implementation]:               ^                            |
    TEXT[implementation]:               |                            |
    TEXT[implementation]:               +----------------------------+
    TEXT[implementation]:                  Acknowledgment of packet
    TEXT[implementation]:                    sent during recovery

  SECTION: [Slow Start](#section-7.3.1)
    TEXT[implementation]: A sender begins in slow start
    TEXT[implementation]:    because the slow start threshold is initialized to an infinite value.
    TEXT[implementation]:    While a sender is in slow start, the congestion window increases by
    TEXT[implementation]:    the number of bytes acknowledged when each acknowledgment is
    TEXT[implementation]:    processed.  This results in exponential growth of the congestion
    TEXT[implementation]:    window.
    TEXT[!MUST,implementation,test]:    The sender MUST exit slow start and enter a recovery period when a
    TEXT[!MUST,implementation,test]:    packet is lost or when the ECN-CE count reported by its peer
    TEXT[!MUST,implementation,test]:    increases.

  SECTION: [Recovery](#section-7.3.2)
    TEXT[!MUST,exception]:    On entering a recovery period, a sender MUST set the slow start
    TEXT[!MUST,exception]:    threshold to half the value of the congestion window when loss is
    TEXT[!MUST,exception]:    detected.
    TEXT[!MUST,exception]: The congestion window MUST be set to the reduced value of
    TEXT[!MUST,exception]:    the slow start threshold before exiting the recovery period.
    TEXT[!MAY,implementation,test]:    Implementations MAY reduce the congestion window immediately upon
    TEXT[!MAY,implementation,test]:    entering a recovery period or use other mechanisms, such as
    TEXT[!MAY,implementation,test]:    Proportional Rate Reduction [PRR], to reduce the congestion window
    TEXT[!MAY,implementation,test]:    more gradually.
    TEXT[implementation]: If the congestion window is reduced immediately, a
    TEXT[implementation]:    single packet can be sent prior to reduction.  This speeds up loss
    TEXT[implementation]:    recovery if the data in the lost packet is retransmitted and is
    TEXT[implementation]:    similar to TCP as described in Section 5 of [RFC6675].
    TEXT[implementation]:    A recovery period ends and the sender enters congestion avoidance
    TEXT[implementation]:    when a packet sent during the recovery period is acknowledged.

  SECTION: [Congestion Avoidance](#section-7.3.3)
    TEXT[!MUST,exception]:    A sender in congestion avoidance uses an Additive Increase
    TEXT[!MUST,exception]:    Multiplicative Decrease (AIMD) approach that MUST limit the increase
    TEXT[!MUST,exception]:    to the congestion window to at most one maximum datagram size for
    TEXT[!MUST,exception]:    each congestion window that is acknowledged.

  SECTION: [Ignoring Loss of Undecryptable Packets](#section-7.4)
    TEXT[!MAY,todo]: Endpoints MAY ignore the
    TEXT[!MAY,todo]:    loss of Handshake, 0-RTT, and 1-RTT packets that might have arrived
    TEXT[!MAY,todo]:    before the peer had packet protection keys to process those packets.
    TEXT[!MUST,todo]:    Endpoints MUST NOT ignore the loss of packets that were sent after
    TEXT[!MUST,todo]:    the earliest acknowledged packet in a given packet number space.

  SECTION: [Probe Timeout](#section-7.5)
    TEXT[!MUST,implementation]:    Probe packets MUST NOT be blocked by the congestion controller.
    TEXT[!MUST,implementation,test]:    sender MUST however count these packets as being additionally in
    TEXT[!MUST,implementation,test]:    flight, since these packets add network load without establishing
    TEXT[!MUST,implementation,test]:    packet loss.

  SECTION: [Duration](#section-7.6.1)
    TEXT[implementation,test]:    The persistent congestion duration is computed as follows:
    TEXT[implementation,test]:    (smoothed_rtt + max(4*rttvar, kGranularity) + max_ack_delay) *
    TEXT[implementation,test]:        kPersistentCongestionThreshold
    TEXT[implementation]:    Unlike the PTO computation in Section 6.2, this duration includes the
    TEXT[implementation]:    max_ack_delay irrespective of the packet number spaces in which
    TEXT[implementation]:    losses are established.
    TEXT[implementation]:    This duration allows a sender to send as many packets before
    TEXT[implementation]:    establishing persistent congestion, including some in response to PTO
    TEXT[implementation]:    expiration, as TCP does with Tail Loss Probes [RFC8985] and an RTO
    TEXT[implementation]:    [RFC5681].
    TEXT[!SHOULD,implementation,test]:    The RECOMMENDED value for kPersistentCongestionThreshold is 3, which
    TEXT[!SHOULD,implementation,test]:    results in behavior that is approximately equivalent to a TCP sender
    TEXT[!SHOULD,implementation,test]:    declaring an RTO after two TLPs.

  SECTION: [Establishing Persistent Congestion](#section-7.6.2)
    TEXT[implementation]:    A sender establishes persistent congestion after the receipt of an
    TEXT[implementation]:    acknowledgment if two packets that are ack-eliciting are declared
    TEXT[implementation]:    lost, and:
    TEXT[implementation]:    *  across all packet number spaces, none of the packets sent between
    TEXT[implementation]:       the send times of these two packets are acknowledged;
    TEXT[!MUST,implementation,test]:    These two packets MUST be ack-eliciting, since a receiver is required
    TEXT[!MUST,implementation,test]:    to acknowledge only ack-eliciting packets within its maximum
    TEXT[!MUST,implementation,test]:    acknowledgment delay; see Section 13.2 of [QUIC-TRANSPORT].
    TEXT[!SHOULD,implementation,test]:    The persistent congestion period SHOULD NOT start until there is at
    TEXT[!SHOULD,implementation,test]:    least one RTT sample.
    TEXT[implementation]:   Before the first RTT sample, a sender arms its
    TEXT[implementation]:    PTO timer based on the initial RTT (Section 6.2.2), which could be
    TEXT[implementation]:    substantially larger than the actual RTT.  Requiring a prior RTT
    TEXT[implementation]:    sample prevents a sender from establishing persistent congestion with
    TEXT[implementation]:    potentially too few probes.
    TEXT[!SHOULD,exception]:    Since network congestion is not affected by packet number spaces,
    TEXT[!SHOULD,exception]:    persistent congestion SHOULD consider packets sent across packet
    TEXT[!SHOULD,exception]:    number spaces.
    TEXT[!MAY,implementation,test]: A sender that does not have state for all packet
    TEXT[!MAY,implementation,test]:    number spaces or an implementation that cannot compare send times
    TEXT[!MAY,implementation,test]:    across packet number spaces MAY use state for just the packet number
    TEXT[!MAY,implementation,test]:    space that was acknowledged.
    TEXT[!MUST,implementation,test]:    When persistent congestion is declared, the sender's congestion
    TEXT[!MUST,implementation,test]:    window MUST be reduced to the minimum congestion window
    TEXT[!MUST,implementation,test]:    (kMinimumWindow), similar to a TCP sender's response on an RTO
    TEXT[!MUST,implementation,test]:    [RFC5681].

  SECTION: [Example](#section-7.6.3)
    TEXT[implementation]:    Packets 2 through 8 are declared lost when the acknowledgment for
    TEXT[implementation]:    packet 9 is received at "t = 12.2".
    TEXT[implementation]:    The congestion period is calculated as the time between the oldest
    TEXT[implementation]:    and newest lost packets: "8 - 1 = 7".

  SECTION: [Pacing](#section-7.7)
    TEXT[!SHOULD,implementation]:    A sender SHOULD pace sending of all in-flight packets based on input
    TEXT[!SHOULD,implementation]:    from the congestion controller.
    TEXT[!MUST,implementation]: Senders MUST either use pacing or limit such bursts.
    TEXT[!SHOULD,implementation]:    Senders SHOULD limit bursts to the initial congestion window; see
    TEXT[!SHOULD,implementation]:    Section 7.2.
    TEXT[!MAY,todo]: A sender with knowledge that the network path to the
    TEXT[!MAY,todo]:    receiver can absorb larger bursts MAY use a higher limit.
    TEXT[!SHOULD,todo]: To avoid delaying their delivery to the peer, packets
    TEXT[!SHOULD,todo]:    containing only ACK frames SHOULD therefore not be paced.
    TEXT[implementation,test]: A perfectly paced
    TEXT[implementation,test]:    sender spreads packets exactly evenly over time.  For a window-based
    TEXT[implementation,test]:    congestion controller, such as the one in this document, that rate
    TEXT[implementation,test]:    can be computed by averaging the congestion window over the RTT.
    TEXT[implementation,test]:    Expressed as a rate in units of bytes per time, where
    TEXT[implementation,test]:    congestion_window is in bytes:
    TEXT[implementation,test]:    rate = N * congestion_window / smoothed_rtt
    TEXT[test]:    Or expressed as an inter-packet interval in units of time:
    TEXT[test]:    interval = ( smoothed_rtt * packet_size / congestion_window ) / N
    TEXT[implementation]:    Using a value for "N" that is small, but at least 1 (for example,
    TEXT[implementation]:    1.25) ensures that variations in RTT do not result in
    TEXT[implementation]:    underutilization of the congestion window.

  SECTION: [Underutilizing the Congestion Window](#section-7.8)
    TEXT[implementation,test]:    When bytes in flight is smaller than the congestion window and
    TEXT[implementation,test]:    sending is not pacing limited, the congestion window is
    TEXT[implementation,test]:    underutilized.  This can happen due to insufficient application data
    TEXT[implementation,test]:    or flow control limits.
    TEXT[!SHOULD,implementation,test]: When this occurs, the congestion window
    TEXT[!SHOULD,implementation,test]:    SHOULD NOT be increased in either slow start or congestion avoidance.
    TEXT[!SHOULD,todo]: A sender SHOULD NOT consider itself application limited if it
    TEXT[!SHOULD,todo]:    would have fully utilized the congestion window without pacing delay.
    TEXT[!MAY,implementation]:    A sender MAY implement alternative mechanisms to update its
    TEXT[!MAY,implementation]:    congestion window after periods of underutilization, such as those
    TEXT[!MAY,implementation]:    proposed for TCP in [RFC7661].

  SECTION: [Misreporting ECN Markings](#section-8.3)
    TEXT[implementation]:    A receiver can misreport ECN markings to alter the congestion
    TEXT[implementation]:    response of a sender.  Suppressing reports of ECN-CE markings could
    TEXT[implementation]:    cause a sender to increase their send rate.  This increase could
    TEXT[implementation]:    result in congestion and loss.
    TEXT[implementation,test]:    A sender can detect suppression of reports by marking occasional
    TEXT[implementation,test]:    packets that it sends with an ECN-CE marking.  If a packet sent with
    TEXT[implementation,test]:    an ECN-CE marking is not reported as having been CE marked when the
    TEXT[implementation,test]:    packet is acknowledged, then the sender can disable ECN for that path
    TEXT[implementation,test]:    by not setting ECN-Capable Transport (ECT) codepoints in subsequent
    TEXT[implementation,test]:    packets sent on that path [RFC3168].

  SECTION: [Variables of Interest](#appendix-A.3)
    TEXT[implementation]: The time the
    TEXT[implementation]:       most recent ack-eliciting packet was sent.
    TEXT[implementation]: The largest packet number
    TEXT[implementation]:       acknowledged in the packet number space so far.
    TEXT[implementation]: An association of packet numbers
    TEXT[implementation]:       in a packet number space to information about them.

  SECTION: [On Sending a Packet](#appendix-A.5)
    TEXT[implementation]:    After a packet is sent, information about the packet is stored.

  SECTION: [On Receiving a Datagram](#appendix-A.6)
    TEXT[implementation]:    When a server is blocked by anti-amplification limits, receiving a
    TEXT[implementation]:    datagram unblocks it, even if none of the packets in the datagram are
    TEXT[implementation]:    successfully processed.  In such a case, the PTO timer will need to
    TEXT[implementation]:    be rearmed.

  SECTION: [On Timeout](#appendix-A.9)
    TEXT[implementation]:        // Client sends an anti-deadlock packet: Initial is padded
    TEXT[implementation]:        // to earn more anti-amplification credit,
    TEXT[implementation]:        // a Handshake packet proves address ownership.

  SECTION: [Detecting Lost Packets](#appendix-A.10)
    TEXT[implementation]:    DetectAndRemoveLostPackets is called every time an ACK is received or
    TEXT[implementation]:    the time threshold loss detection timer expires.  This function
    TEXT[implementation]:    operates on the sent_packets for that packet number space and returns
    TEXT[implementation]:    a list of packets newly detected as lost.

  SECTION: [Variables of Interest](#appendix-B.2)
    TEXT[implementation]: The sum of the size in bytes of all sent packets
    TEXT[implementation]:       that contain at least one ack-eliciting or PADDING frame and have
    TEXT[implementation]:       not been acknowledged or declared lost.  The size does not include
    TEXT[implementation]:       IP or UDP overhead, but does include the QUIC header and
    TEXT[implementation]:       Authenticated Encryption with Associated Data (AEAD) overhead.
    TEXT[implementation]:       Packets only containing ACK frames do not count toward
    TEXT[implementation]:       bytes_in_flight to ensure congestion control does not impede
    TEXT[implementation]:       congestion feedback.

  SECTION: [Removing Discarded Packets from Bytes in Flight](#appendix-B.9)
    TEXT[implementation]:    When Initial or Handshake keys are discarded, packets sent in that
    TEXT[implementation]:    space no longer count toward bytes in flight.

SPECIFICATION: https://www.rfc-editor.org/rfc/rfc919
  SECTION: [Broadcast IP Addressing - Proposed Standards](#section-7)
    TEXT[implementation]:    The address 255.255.255.255 denotes a broadcast on a local hardware
    TEXT[implementation]:    network, which must not be forwarded.

SPECIFICATION: https://www.rfc-editor.org/rfc/rfc9221
  SECTION: [Transport Parameter](#section-3)
    TEXT[implementation]:    Support for receiving the DATAGRAM frame types is advertised by means
    TEXT[implementation]:    of a QUIC transport parameter (name=max_datagram_frame_size,
    TEXT[implementation]:    value=0x20).  The max_datagram_frame_size transport parameter is an
    TEXT[implementation]:    integer value (represented as a variable-length integer) that
    TEXT[implementation]:    represents the maximum size of a DATAGRAM frame (including the frame
    TEXT[implementation]:    type, length, and payload) the endpoint is willing to receive, in
    TEXT[implementation]:    bytes.
    TEXT[implementation]:    The default for this parameter is 0, which indicates that the
    TEXT[implementation]:    endpoint does not support DATAGRAM frames.  A value greater than 0
    TEXT[implementation]:    indicates that the endpoint supports the DATAGRAM frame types and is
    TEXT[implementation]:    willing to receive such frames on this connection.
    TEXT[implementation]:    For most uses of DATAGRAM frames, it is RECOMMENDED to send a value
    TEXT[implementation]:    of 65535 in the max_datagram_frame_size transport parameter to
    TEXT[implementation]:    indicate that this endpoint will accept any DATAGRAM frame that fits
    TEXT[implementation]:    inside a QUIC packet.
    TEXT[implementation]:    When clients use 0-RTT, they MAY store the value of the server's
    TEXT[implementation]:    max_datagram_frame_size transport parameter.  Doing so allows the
    TEXT[implementation]:    client to send DATAGRAM frames in 0-RTT packets.

  SECTION: [Datagram Frame Types](#section-4)
    TEXT[implementation]:    DATAGRAM frames are used to transmit application data in an
    TEXT[implementation]:    unreliable manner.  The Type field in the DATAGRAM frame takes the
    TEXT[implementation]:    form 0b0011000X (or the values 0x30 and 0x31).
    TEXT[implementation]: The least significant
    TEXT[implementation]:    bit of the Type field in the DATAGRAM frame is the LEN bit (0x01),
    TEXT[implementation]:    which indicates whether there is a Length field present: if this bit
    TEXT[implementation]:    is set to 0, the Length field is absent and the Datagram Data field
    TEXT[implementation]:    extends to the end of the packet; if this bit is set to 1, the Length
    TEXT[implementation]:    field is present.
    TEXT[implementation]:    DATAGRAM Frame {
    TEXT[implementation]:      Type (i) = 0x30..0x31,
    TEXT[implementation]:      [Length (i)],
    TEXT[implementation]:      Datagram Data (..),
    TEXT[implementation]:    DATAGRAM frames contain the following fields:
    TEXT[implementation]:    Length:  A variable-length integer specifying the length of the
    TEXT[implementation]:       Datagram Data field in bytes.  This field is present only when the
    TEXT[implementation]:       LEN bit is set to 1.  When the LEN bit is set to 0, the Datagram
    TEXT[implementation]:       Data field extends to the end of the QUIC packet.  Note that empty
    TEXT[implementation]:       (i.e., zero-length) datagrams are allowed.
    TEXT[implementation]:    Datagram Data:  The bytes of the datagram to be delivered.

  SECTION: [Behavior and Usage](#section-5)
    TEXT[implementation]: DATAGRAM frames cannot be fragmented;

  SECTION: [Acknowledgement Handling](#section-5.2)
    TEXT[implementation]:    Although DATAGRAM frames are not retransmitted upon loss detection,
    TEXT[implementation]:    they are ack-eliciting ([RFC9002]).

  SECTION: [Congestion Control](#section-5.4)
    TEXT[implementation]:    DATAGRAM frames employ the QUIC connection's congestion controller.

SPECIFICATION: https://www.rfc-editor.org/rfc/rfc9308
  SECTION: [Source Port Selection](#section-8.1)
    TEXT[implementation]:    Some UDP protocols are vulnerable to reflection attacks, where an
    TEXT[implementation]:    attacker is able to direct traffic to a third party as a denial of
    TEXT[implementation]:    service.  For example, these source ports are associated with
    TEXT[implementation]:    applications known to be vulnerable to reflection attacks, often due
    TEXT[implementation]:    to server misconfiguration:
    TEXT[implementation]:    *  port 53 - DNS [RFC1034]
    TEXT[implementation]:    *  port 123 - NTP [RFC5905]
    TEXT[implementation]:    *  port 1900 - SSDP [SSDP]
    TEXT[implementation]:    *  port 5353 - mDNS [RFC6762]
    TEXT[implementation]:    *  port 11211 - memcache
