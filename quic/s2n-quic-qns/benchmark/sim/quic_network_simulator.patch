diff --git a/sim/scenarios/drop-rate/drop-rate-error-model.cc b/sim/scenarios/drop-rate/drop-rate-error-model.cc
index 62c561c..85bc0eb 100644
--- a/sim/scenarios/drop-rate/drop-rate-error-model.cc
+++ b/sim/scenarios/drop-rate/drop-rate-error-model.cc
@@ -1,4 +1,5 @@
 #include "../helper/quic-packet.h"
+#include "../helper/tcp-packet.h"
 #include "drop-rate-error-model.h"
 
 using namespace std;
@@ -22,18 +23,36 @@ DropRateErrorModel::DropRateErrorModel()
 void DropRateErrorModel::DoReset(void) { }
  
 bool DropRateErrorModel::DoCorrupt(Ptr<Packet> p) {
-    if(!IsUDPPacket(p)) return false;
-
-    QuicPacket qp = QuicPacket(p);
-
-    if (distr(*rng) >= rate) {
-        cout << "Forwarding packet (" << qp.GetUdpPayload().size() << " bytes) from " << qp.GetIpv4Header().GetSource() << endl;
-        qp.ReassemblePacket();
+    if(IsUDPPacket(p)) {
+
+        QuicPacket qp = QuicPacket(p);
+
+        if (distr(*rng) >= rate) {
+            cout << "Forwarding UDP packet (" << qp.GetUdpPayload().size() << " bytes) from "
+                 << qp.GetIpv4Header().GetSource() << endl;
+            qp.ReassemblePacket();
+            return false;
+        }
+
+        cout << "Dropping packet (" << qp.GetUdpPayload().size() << " bytes) from " << qp.GetIpv4Header().GetSource()
+             << endl;
+        return true;
+    } else if(IsTCPPacket(p)) {
+        TcpPacket qp = TcpPacket(p);
+
+        if (distr(*rng) >= rate) {
+            cout << "Forwarding TCP packet (" << qp.GetTcpPayload().size() << " bytes) from "
+                 << qp.GetIpv4Header().GetSource() << endl;
+            qp.ReassemblePacket();
+            return false;
+        }
+
+        cout << "Dropping packet (" << qp.GetTcpPayload().size() << " bytes) from " << qp.GetIpv4Header().GetSource()
+             << endl;
+        return true;
+    } else {
         return false;
     }
-
-    cout << "Dropping packet (" << qp.GetUdpPayload().size() << " bytes) from " << qp.GetIpv4Header().GetSource() << endl;
-    return true;
 }
 
 void DropRateErrorModel::SetDropRate(int rate_in) {
diff --git a/sim/scenarios/helper/quic-packet.cc b/sim/scenarios/helper/quic-packet.cc
index a599cbb..ae46017 100644
--- a/sim/scenarios/helper/quic-packet.cc
+++ b/sim/scenarios/helper/quic-packet.cc
@@ -22,14 +22,16 @@ bool IsUDPPacket(Ptr<Packet> p) {
             {
                 Ipv4Header hdr = Ipv4Header();
                 p->PeekHeader(hdr);
-                is_udp = hdr.GetProtocol() == 17;
+                uint8_t protocol = hdr.GetProtocol();
+                is_udp = protocol == 17;
             }
             break;
         case 0x57: // IPv6
             {
                 Ipv6Header hdr = Ipv6Header();
                 p->PeekHeader(hdr);
-                is_udp = hdr.GetNextHeader() == 17;
+                uint8_t protocol = hdr.GetNextHeader();
+                is_udp = protocol == 17;
             }
             break;
         default:
diff --git a/sim/scenarios/helper/tcp-packet.cc b/sim/scenarios/helper/tcp-packet.cc
new file mode 100644
index 0000000..9fdad50
--- /dev/null
+++ b/sim/scenarios/helper/tcp-packet.cc
@@ -0,0 +1,86 @@
+#include <cstdint>
+#include <vector>
+
+#include "tcp-packet.h"
+
+#include "ns3/packet.h"
+#include "ns3/ppp-header.h"
+#include "ns3/ipv4-header.h"
+#include "ns3/ipv6-header.h"
+#include "ns3/tcp-header.h"
+
+using namespace ns3;
+using namespace std;
+
+
+bool IsTCPPacket(Ptr<Packet> p) {
+    PppHeader ppp_hdr = PppHeader();
+    p->RemoveHeader(ppp_hdr);
+    bool is_tcp = false;
+    switch(ppp_hdr.GetProtocol()) {
+        case 0x21: // IPv4
+            {
+                Ipv4Header hdr = Ipv4Header();
+                p->PeekHeader(hdr);
+                uint8_t protocol = hdr.GetProtocol();
+                is_tcp = protocol == 6;
+            }
+            break;
+        case 0x57: // IPv6
+            {
+                Ipv6Header hdr = Ipv6Header();
+                p->PeekHeader(hdr);
+                uint8_t protocol = hdr.GetNextHeader();
+                is_tcp = protocol == 6;
+            }
+            break;
+        default:
+            cout << "Unknown PPP protocol: " << ppp_hdr.GetProtocol() << endl;
+            break;
+    }
+    p->AddHeader(ppp_hdr);
+    return is_tcp;
+}
+
+
+TcpPacket::TcpPacket(Ptr<Packet> p) : p_(p) {
+    const uint32_t p_len = p->GetSize();
+    uint8_t *buffer= new uint8_t[p_len];
+    p->CopyData(buffer, p_len);
+    ppp_hdr_ = PppHeader();
+    uint32_t ppp_hdr_len = p->RemoveHeader(ppp_hdr_);
+    // TODO: This currently only works for IPv4.
+    ipv4_hdr_ = Ipv4Header();
+    uint32_t ip_hdr_len = p->RemoveHeader(ipv4_hdr_);
+    tcp_hdr_ = TcpHeader();
+    tcp_hdr_len_ = p->RemoveHeader(tcp_hdr_);
+    total_hdr_len_ = ppp_hdr_len + ip_hdr_len + tcp_hdr_len_;
+    tcp_payload_ = vector<uint8_t>(&buffer[total_hdr_len_], &buffer[total_hdr_len_] + p_len - total_hdr_len_);
+}
+
+Ipv4Header& TcpPacket::GetIpv4Header() { return ipv4_hdr_; }
+
+TcpHeader& TcpPacket::GetTcpHeader() { return tcp_hdr_; }
+
+vector<uint8_t>& TcpPacket::GetTcpPayload() { return tcp_payload_; }
+
+bool TcpPacket::IsVersionNegotiationPacket() {
+    if(tcp_payload_.size() <= 5) return false;
+    return tcp_payload_[1] == 0 && tcp_payload_[2] == 0 && tcp_payload_[3] == 0 && tcp_payload_[4] == 0;
+}
+
+void TcpPacket::ReassemblePacket() {
+    // Start with the TCP payload.
+    Packet new_p = Packet(tcp_payload_.data(), tcp_payload_.size());
+    // Add the TCP header and make sure to recalculate the checksum.
+    tcp_hdr_.InitializeChecksum(ipv4_hdr_.GetSource(), ipv4_hdr_.GetDestination(), ipv4_hdr_.GetProtocol());
+    tcp_hdr_.EnableChecksums();
+    new_p.AddHeader(tcp_hdr_);
+    // Add the IP header, again make sure to recalculate the checksum.
+    ipv4_hdr_.EnableChecksum();
+    new_p.AddHeader(ipv4_hdr_);
+    // Add the PPP header.
+    new_p.AddHeader(ppp_hdr_);
+    p_->RemoveAtEnd(p_->GetSize());
+    p_->AddAtEnd(Ptr<Packet>(&new_p));
+}
diff --git a/sim/scenarios/helper/tcp-packet.h b/sim/scenarios/helper/tcp-packet.h
new file mode 100644
index 0000000..9a695a1
--- /dev/null
+++ b/sim/scenarios/helper/tcp-packet.h
@@ -0,0 +1,39 @@
+#ifndef TCP_PACKET_H
+#define TCP_PACKET_H
+
+#include <cstdint>
+
+#include "ns3/header.h"
+#include "ns3/packet.h"
+#include "ns3/ppp-header.h"
+#include "ns3/ipv4-header.h"
+#include "ns3/tcp-header.h"
+
+using namespace ns3;
+using namespace std;
+
+bool IsTCPPacket(Ptr<Packet> p);
+
+class TcpPacket {
+public:
+    TcpPacket(Ptr<Packet> p);
+    // Assemble a new packet.
+    // It uses the PPP, IP and TCP header that it parsed from the original packet,
+    // and recalculates IP and TCP checksums.
+    void ReassemblePacket();
+    Ipv4Header& GetIpv4Header();
+    TcpHeader& GetTcpHeader();
+    vector<uint8_t>& GetTcpPayload();
+    bool IsVersionNegotiationPacket();
+
+private:
+    Ptr<Packet> p_;
+    PppHeader ppp_hdr_;
+    Ipv4Header ipv4_hdr_;
+    TcpHeader tcp_hdr_;
+    uint32_t tcp_hdr_len_;
+    uint32_t total_hdr_len_;
+    vector<uint8_t> tcp_payload_;
+};
+
+#endif /* TCP_PACKET_H */
diff --git a/sim/wscript.patch b/sim/wscript.patch
index aee9f2c..67e0255 100644
--- a/sim/wscript.patch
+++ b/sim/wscript.patch
@@ -1,6 +1,6 @@
 --- wscript.orig
 +++ wscript
-@@ -758,12 +758,15 @@
+@@ -758,12 +758,16 @@
  
      try:
          for filename in os.listdir("scratch"):
@@ -14,6 +14,7 @@
 +                obj.source.append('../helper/quic-network-simulator-helper.cc')
 +                obj.source.append('../helper/quic-point-to-point-helper.cc')
 +                obj.source.append('../helper/quic-packet.cc')
++                obj.source.append('../helper/tcp-packet.cc')
                  obj.target = filename
                  obj.name = obj.target
                  obj.install_path = None
