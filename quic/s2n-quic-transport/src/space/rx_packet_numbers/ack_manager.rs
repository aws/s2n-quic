use crate::{
    contexts::WriteContext,
    processed_packet::ProcessedPacket,
    space::rx_packet_numbers::{
        ack_eliciting_transmission::{AckElicitingTransmission, AckElicitingTransmissionSet},
        ack_ranges::AckRanges,
        ack_transmission_state::AckTransmissionState,
    },
    timer::VirtualTimer,
    transmission,
};
use core::time::Duration;
use s2n_quic_core::{
    ack_set::AckSet,
    frame::{Ack, Ping},
    inet::DatagramInfo,
    packet::number::{PacketNumber, PacketNumberSpace},
    time::Timestamp,
    transport::parameters::AckSettings,
    varint::VarInt,
};

//= https://tools.ietf.org/id/draft-ietf-quic-transport-27.txt#13.2
//# Endpoints acknowledge all packets they receive and process.  However,
//# only ack-eliciting packets cause an ACK frame to be sent within the
//# maximum ack delay.  Packets that are not ack-eliciting are only
//# acknowledged when an ACK frame is sent for other reasons.
//#
//# When sending a packet for any reason, an endpoint should attempt to
//# bundle an ACK frame if one has not been sent recently.  Doing so
//# helps with timely loss detection at the peer.
//#
//# In general, frequent feedback from a receiver improves loss and
//# congestion response, but this has to be balanced against excessive
//# load generated by a receiver that sends an ACK frame in response to
//# every ack-eliciting packet.  The guidance offered below seeks to
//# strike this balance.

#[derive(Clone, Debug)]
pub struct AckManager {
    /// Time at which the AckManager will wake and transmit an ACK
    ack_delay_timer: VirtualTimer,

    /// Used to track the ACK-eliciting transmissions sent from the AckManager
    ack_eliciting_transmissions: AckElicitingTransmissionSet,

    /// All of the processed AckRanges that need to be ACKed
    pub(super) ack_ranges: AckRanges,

    /// Peer's AckSettings from the transport parameters
    pub ack_settings: AckSettings,

    /// The largest packet number that we've acked - used for pn decoding
    largest_received_packet_number_acked: PacketNumber,

    /// The time at which we received the largest pn
    largest_received_packet_number_at: Option<Timestamp>,

    /// The number of processed packets since transmission
    processed_packets_since_transmission: u8,

    /// The number of transmissions since the last ACK-eliciting packet was sent
    transmissions_since_elicitation: u8,

    /// Used to transition through transmission/retransmission states
    transmission_state: AckTransmissionState,
}

//= https://tools.ietf.org/id/draft-ietf-quic-transport-27.txt#13.2.1
//# For Initial and Handshake packets, a max_ack_delay of 0 is used.
pub const EARLY_ACK_SETTINGS: AckSettings = AckSettings {
    max_ack_delay: Duration::from_secs(0),
    ack_delay_exponent: 0,
};

//= https://tools.ietf.org/id/draft-ietf-quic-transport-27.txt#13.2.4
//# When the receiver is only sending non-ack-eliciting packets, it can
//# bundle a PING or other small ack-eliciting frame with a fraction of
//# them, such as once per round trip, to enable dropping unnecessary ACK
//# ranges and any state for previously sent packets.

// Originally, this was using a timer derived from RTT. However,
// there were issues in certain simulations that led to endless looping.
// Instead, we use a simple counter to elicit ACKs at a desired frequency.
//
// After running simulations, this seemed to be a good baseline
// TODO experiment more with this
const ACK_ELICITATION_INTERVAL: u8 = 4;

impl AckManager {
    pub fn new(
        packet_space: PacketNumberSpace,
        ack_settings: AckSettings,
        ack_ranges_limit: usize,
    ) -> Self {
        Self {
            ack_delay_timer: VirtualTimer::default(),
            ack_eliciting_transmissions: AckElicitingTransmissionSet::default(),
            ack_settings,
            ack_ranges: AckRanges::new(ack_ranges_limit),
            largest_received_packet_number_acked: packet_space
                .new_packet_number(VarInt::from_u8(0)),
            largest_received_packet_number_at: None,
            processed_packets_since_transmission: 0,
            transmissions_since_elicitation: 0,
            transmission_state: AckTransmissionState::default(),
        }
    }

    /// Called when an outgoing packet is being assembled
    pub fn on_transmit<W: WriteContext>(&mut self, context: &mut W) -> bool {
        if !self.transmission_state.should_transmit() {
            return false;
        }

        //= https://tools.ietf.org/id/draft-ietf-quic-recovery-32.txt#7
        //# packets containing only ACK frames do not count
        //# towards bytes in flight and are not congestion controlled.
        let _ = context.transmission_constraint(); // ignored

        let ack_delay = self.ack_delay(context.current_time());
        // TODO retrieve ECN counts from current path
        let ecn_counts = Default::default();

        context
            .write_frame(&Ack {
                ack_delay,
                ack_ranges: &self.ack_ranges,
                ecn_counts,
            })
            .is_some()
    }

    /// Called after an outgoing packet is assembled and `on_transmit` returned `true`
    pub fn on_transmit_complete<W: WriteContext>(&mut self, context: &mut W) {
        debug_assert!(
            self.transmission_state.should_transmit(),
            "`on_transmit_complete` was called when `should_transmit` is false"
        );

        let mut is_ack_eliciting = context.ack_elicitation().is_ack_eliciting();

        if !is_ack_eliciting {
            //= https://tools.ietf.org/id/draft-ietf-quic-transport-27.txt#13.2.4
            //# When the receiver is only sending non-ack-eliciting packets, it can
            //# bundle a PING or other small ack-eliciting frame with a fraction of
            //# them, such as once per round trip, to enable dropping unnecessary ACK
            //# ranges and any state for previously sent packets.
            // check the timer and make sure we can still write a Ping frame before removing it
            // We send a ping even when constrained to retransmissions only, as a fast
            // retransmission that is not ack eliciting will not help us recover faster.
            if (context.transmission_constraint().can_transmit()
                || context.transmission_constraint().can_retransmit())
                && self.transmissions_since_elicitation >= ACK_ELICITATION_INTERVAL
                && context.write_frame(&Ping).is_some()
            {
                is_ack_eliciting = true;
            } else {
                self.transmissions_since_elicitation += 1;
            }
        }

        self.largest_received_packet_number_acked = self
            .ack_ranges
            .max_value()
            .expect("transmission_state should be Disabled while ack_ranges is empty");

        if is_ack_eliciting {
            // reset the counter
            self.transmissions_since_elicitation = 0;

            //= https://tools.ietf.org/id/draft-ietf-quic-transport-27.txt#13.2.3
            //# When a packet containing an ACK frame is sent, the largest
            //# acknowledged in that frame may be saved.
            self.ack_eliciting_transmissions
                .on_transmit(AckElicitingTransmission {
                    sent_in_packet: context.packet_number(),
                    largest_received_packet_number_acked: self.largest_received_packet_number_acked,
                });
        }

        // record a transmission
        self.transmission_state.on_transmit();

        // reset the number of packets since transmission
        self.processed_packets_since_transmission = 0;
    }

    /// Called when a set of packets was acknowledged
    pub fn on_packet_ack<A: AckSet>(&mut self, _datagram: &DatagramInfo, ack_set: &A) {
        if let Some(ack_range) = self.ack_eliciting_transmissions.on_update(ack_set) {
            self.ack_ranges
                .remove(ack_range)
                .expect("The range should always shrink the interval length");

            // `self.transmission_state` will be automatically notified in `on_processed_packet`
            // so wait for that instead
        }
    }

    /// Called when a set of packets was reported lost
    pub fn on_packet_loss<A: AckSet>(&mut self, ack_set: &A) {
        if self
            .ack_eliciting_transmissions
            .on_update(ack_set)
            .is_some()
        {
            // transition to active mode when packet is lost
            self.transmission_state.on_update(&self.ack_ranges);
            self.transmission_state.activate();
        }
    }

    /// Called after an RX packet has been processed
    pub fn on_processed_packet(&mut self, processed_packet: &ProcessedPacket) {
        let packet_number = processed_packet.packet_number;
        let now = processed_packet.datagram.timestamp;

        // perform some checks before inserting into the ack_ranges
        let (is_ordered, is_largest) = self
            .ack_ranges
            .max_value()
            .and_then(|max_value| {
                // check to see if the packet number is the next one in the sequence
                let is_ordered = packet_number == max_value.next()?;

                // check to see if the packet number is the largest we've seen
                let is_largest = packet_number > max_value;

                Some((is_ordered, is_largest))
            })
            .unwrap_or((true, true));

        // This will fail if `packet_number` is less than `ack_ranges.min_value()`
        // and `ack_ranges` is at capacity.
        //
        // Most likely, this packet is very old and the contents have already
        // been retransmitted by the peer.
        if !self.ack_ranges.insert_packet_number(packet_number) {
            return;
        }

        // Notify the state that the ack_ranges have changed
        self.transmission_state.on_update(&self.ack_ranges);
        self.processed_packets_since_transmission =
            self.processed_packets_since_transmission.saturating_add(1);

        //= https://tools.ietf.org/id/draft-ietf-quic-transport-27.txt#13.2.5
        //# An endpoint measures the delays intentionally introduced between the
        //# time the packet with the largest packet number is received and the
        //# time an acknowledgment is sent.  The endpoint encodes this delay in
        //# the Ack Delay field of an ACK frame (see Section 19.3).  This allows
        //# the receiver of the ACK to adjust for any intentional delays, which
        //# is important for getting a better estimate of the path RTT when
        //# acknowledgments are delayed.
        if is_largest {
            self.largest_received_packet_number_at = Some(now);
        }

        if processed_packet.is_ack_eliciting() {
            let mut should_activate = false;

            //= https://tools.ietf.org/id/draft-ietf-quic-transport-27.txt#13.2.1
            //# In order to assist loss detection at the sender, an endpoint SHOULD
            //# send an ACK frame immediately on receiving an ack-eliciting packet
            //# that is out of order.
            should_activate |= !is_ordered;

            //= https://tools.ietf.org/id/draft-ietf-quic-transport-27.txt#13.2.1
            //# Similarly, packets marked with the ECN Congestion Experienced (CE)
            //# codepoint in the IP header SHOULD be acknowledged immediately, to
            //# reduce the peer's response time to congestion events.
            should_activate |= processed_packet.datagram.ecn.congestion_experienced();

            // TODO update to draft link after published
            // https://github.com/quicwg/base-drafts/pull/3623
            // An ACK frame SHOULD be generated for at least every 10th ack-eliciting packet

            // TODO support delayed ack proposal
            // https://tools.ietf.org/html/draft-iyengar-quic-delayed-ack-00
            let packet_tolerance = 10;

            should_activate |= self.processed_packets_since_transmission >= packet_tolerance;

            if should_activate {
                self.transmission_state.activate();
            } else if !self.ack_delay_timer.is_armed() {
                //= https://tools.ietf.org/id/draft-ietf-quic-transport-27.txt#13.2
                //# Endpoints acknowledge all packets they receive and process.  However,
                //# only ack-eliciting packets cause an ACK frame to be sent within the
                //# maximum ack delay.  Packets that are not ack-eliciting are only
                //# acknowledged when an ACK frame is sent for other reasons.
                self.ack_delay_timer
                    .set(now + self.ack_settings.max_ack_delay)
            }
        }

        // To save on timer churn, check to see if we've already expired since the
        // last time we sent an ACK frame
        if self.ack_delay_timer.poll_expiration(now).is_ready() {
            self.transmission_state.activate();
        }
    }

    /// Returns all of the component timers
    pub fn timers(&self) -> impl Iterator<Item = &Timestamp> {
        // NOTE: ack_elicitation_timer is not actively polled

        self.ack_delay_timer.iter()
    }

    /// Called when the connection timer expired
    pub fn on_timeout(&mut self, timestamp: Timestamp) {
        // NOTE: ack_elicitation_timer is not actively polled

        if self.ack_delay_timer.poll_expiration(timestamp).is_ready() {
            // transition to active transmission when we exceed the ack_delay
            self.transmission_state.activate();
        }
    }

    /// Returns the largest received packet number that has been ACKed at least once
    pub fn largest_received_packet_number_acked(&self) -> PacketNumber {
        self.largest_received_packet_number_acked
    }

    /// Computes the ack_delay field for the current state
    fn ack_delay(&self, now: Timestamp) -> VarInt {
        //= https://tools.ietf.org/id/draft-ietf-quic-transport-27.txt#19.3
        //# ACK Delay:  A variable-length integer representing the time delta in
        //#    microseconds between when this ACK was sent and when the largest
        //#    acknowledged packet, as indicated in the Largest Acknowledged
        //#    field, was received by this peer.
        let ack_delay = self
            .largest_received_packet_number_at
            .map(|prev| now.saturating_duration_since(prev))
            .unwrap_or_default();
        self.ack_settings.encode_ack_delay(ack_delay)
    }
}

impl transmission::interest::Provider for AckManager {
    fn transmission_interest(&self) -> transmission::Interest {
        self.transmission_state.transmission_interest()
    }
}

#[cfg(test)]
mod tests {
    use super::{super::tests::*, *};
    use crate::{
        contexts::testing::{MockConnectionContext, MockWriteContext, OutgoingFrameBuffer},
        endpoint::EndpointType,
    };
    use core::{
        iter::{empty, once},
        mem::size_of,
        time::Duration,
    };
    use insta::assert_debug_snapshot;
    use s2n_quic_core::{
        frame::{ping, Frame},
        transport::parameters::AckSettings,
    };

    #[test]
    fn on_transmit_complete_transmission_constrained() {
        let mut manager = AckManager::new(
            PacketNumberSpace::ApplicationData,
            AckSettings::default(),
            1,
        );
        let connection_context = MockConnectionContext::new(EndpointType::Server);
        let mut frame_buffer = OutgoingFrameBuffer::new();
        let mut write_context = MockWriteContext::new(
            &connection_context,
            s2n_quic_platform::time::now(),
            &mut frame_buffer,
            transmission::Constraint::None,
        );

        manager.ack_ranges = AckRanges::default();
        manager.ack_ranges.insert_packet_number(
            PacketNumberSpace::ApplicationData.new_packet_number(VarInt::from_u8(1)),
        );
        manager.transmission_state = AckTransmissionState::Active { retransmissions: 0 };
        manager.transmissions_since_elicitation = ACK_ELICITATION_INTERVAL;

        manager.on_transmit_complete(&mut write_context);

        assert_eq!(
            write_context
                .frame_buffer
                .pop_front()
                .expect("Frame is written")
                .as_frame(),
            Frame::Ping(ping::Ping),
            "Ping should be written when transmission is not constrained"
        );

        manager.transmission_state = AckTransmissionState::Active { retransmissions: 0 };
        manager.transmissions_since_elicitation = ACK_ELICITATION_INTERVAL;
        write_context.frame_buffer.clear();
        write_context.transmission_constraint = transmission::Constraint::CongestionLimited;

        manager.on_transmit_complete(&mut write_context);
        assert!(
            write_context.frame_buffer.is_empty(),
            "Ping should not be written when CongestionLimited"
        );

        manager.transmission_state = AckTransmissionState::Active { retransmissions: 0 };
        manager.transmissions_since_elicitation = ACK_ELICITATION_INTERVAL;
        write_context.frame_buffer.clear();
        write_context.transmission_constraint = transmission::Constraint::RetransmissionOnly;

        manager.on_transmit_complete(&mut write_context);
        assert_eq!(
            write_context
                .frame_buffer
                .pop_front()
                .expect("Frame is written")
                .as_frame(),
            Frame::Ping(ping::Ping),
            "Ping should be written when transmission is retransmission only"
        );
    }

    #[test]
    fn size_of_snapshots() {
        assert_debug_snapshot!("AckManager", size_of::<AckManager>());
    }

    #[test]
    fn client_sending_test() {
        assert_debug_snapshot!(
            "client_sending_test",
            Simulation {
                network: Network {
                    client: Application::new(
                        Endpoint::new(AckSettings {
                            max_ack_delay: Duration::from_millis(25),
                            ack_delay_exponent: 1,
                        }),
                        [Duration::from_millis(5)].iter().cycle().take(100).cloned(),
                    )
                    .into(),
                    server: Application::new(
                        Endpoint::new(AckSettings {
                            max_ack_delay: Duration::from_millis(25),
                            ack_delay_exponent: 1,
                        }),
                        empty(),
                    )
                    .into(),
                },
                // pass all packets unchanged
                events: empty().collect(),
                delay: Duration::from_millis(0),
            }
            .run()
        );
    }

    #[test]
    fn delayed_client_sending_test() {
        assert_debug_snapshot!(
            "delayed_client_sending_test",
            Simulation {
                network: Network {
                    client: Application::new(
                        Endpoint::new(AckSettings {
                            max_ack_delay: Duration::from_millis(25),
                            ack_delay_exponent: 1,
                        }),
                        [Duration::from_millis(5)].iter().cycle().take(100).cloned(),
                    )
                    .into(),
                    server: Application::new(
                        Endpoint::new(AckSettings {
                            max_ack_delay: Duration::from_millis(25),
                            ack_delay_exponent: 1,
                        }),
                        empty(),
                    )
                    .into(),
                },
                // pass all packets unchanged
                events: empty().collect(),
                // delay sending each packet by 100ms
                delay: Duration::from_millis(100),
            }
            .run()
        );
    }

    #[test]
    fn high_latency_test() {
        assert_debug_snapshot!(
            "high_latency_test",
            Simulation {
                network: Network {
                    client: Application::new(
                        Endpoint::new(AckSettings {
                            max_ack_delay: Duration::from_millis(25),
                            ack_delay_exponent: 1,
                        }),
                        [Duration::from_millis(5)].iter().cycle().take(100).cloned(),
                    )
                    .into(),
                    server: Application::new(
                        Endpoint::new(AckSettings {
                            max_ack_delay: Duration::from_millis(100),
                            ack_delay_exponent: 1,
                        }),
                        [Duration::from_millis(5)].iter().cycle().take(100).cloned(),
                    )
                    .into(),
                },
                // pass all packets unchanged
                events: empty().collect(),
                // delay sending each packet by 1s
                delay: Duration::from_millis(1000),
            }
            .run()
        );
    }

    #[test]
    fn lossy_network_test() {
        assert_debug_snapshot!(
            "lossy_network_test",
            Simulation {
                network: Network {
                    client: Application::new(
                        Endpoint::new(AckSettings {
                            max_ack_delay: Duration::from_millis(25),
                            ack_delay_exponent: 1,
                        }),
                        [Duration::from_millis(5)].iter().cycle().take(100).cloned(),
                    )
                    .into(),
                    server: Application::new(
                        Endpoint::new(AckSettings {
                            max_ack_delay: Duration::from_millis(100),
                            ack_delay_exponent: 1,
                        }),
                        [Duration::from_millis(5)].iter().cycle().take(100).cloned(),
                    )
                    .into(),
                },
                // drop every 5th packet
                events: once(NetworkEvent::Pass)
                    .cycle()
                    .take(4)
                    .chain(once(NetworkEvent::Drop))
                    .collect(),
                // delay sending each packet by 100ms
                delay: Duration::from_millis(0),
            }
            .run()
        );
    }
}
