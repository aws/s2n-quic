use crate::{
    connection::{
        self,
        id::{ConnectionInfo, Generator as _},
        SynchronizedSharedConnectionState, Trait as _,
    },
    endpoint,
    recovery::congestion_controller::{self, Endpoint as _},
    space::PacketSpaceManager,
};
use alloc::sync::Arc;
use core::{convert::TryInto, time::Duration};
use s2n_codec::DecoderBufferMut;
use s2n_quic_core::{
    crypto::{tls::Endpoint as TLSEndpoint, CryptoSuite, InitialCrypto},
    inet::DatagramInfo,
    packet::initial::ProtectedInitial,
    stateless_reset_token::Generator as _,
    transport::{error::TransportError, parameters::ServerTransportParameters},
};

impl<Config: endpoint::Config> endpoint::Endpoint<Config> {
    pub(super) fn handle_initial_packet(
        &mut self,
        datagram: &DatagramInfo,
        packet: ProtectedInitial,
        remaining: DecoderBufferMut,
        retry_token_dcid: Option<connection::InitialId>,
    ) -> Result<(), TransportError> {
        debug_assert!(
            Config::ENDPOINT_TYPE.is_server(),
            "only servers can accept new initial connections"
        );

        //= https://tools.ietf.org/id/draft-ietf-quic-transport-32.txt#14.1
        //# A client MUST expand the payload of all UDP datagrams carrying
        //# Initial packets to at least the smallest allowed maximum datagram
        //# size of 1200 bytes

        //= https://tools.ietf.org/id/draft-ietf-quic-tls-32.txt#9.3
        //# First, the packet
        //# containing a ClientHello MUST be padded to a minimum size.
        if datagram.payload_len < 1200 {
            return Err(TransportError::PROTOCOL_VIOLATION.with_reason("packet too small"));
        }

        // The first connection ID to persist and use for routing incoming packets
        let initial_connection_id;
        // The randomly generated destination connection ID that was sent from the client
        let original_destination_connection_id;

        if let Some(retry_dcid) = retry_token_dcid {
            original_destination_connection_id = retry_dcid;
            // This initial packet was in response to a Retry, so the destination connection ID
            // on the packet was generated by this server. We can use this destination connection
            // ID as the initial_connection_id.
            initial_connection_id = datagram.destination_connection_id;
        } else {
            //= https://tools.ietf.org/id/draft-ietf-quic-transport-32.txt#7.2
            //# When an Initial packet is sent by a client that has not previously
            //# received an Initial or Retry packet from the server, the client
            //# populates the Destination Connection ID field with an unpredictable
            //# value.  This Destination Connection ID MUST be at least 8 bytes in
            //# length.
            original_destination_connection_id =
                datagram.destination_connection_id.try_into().map_err(|_| {
                    TransportError::PROTOCOL_VIOLATION
                        .with_reason("destination connection id too short")
                })?;
            // The destination connection ID on the packet was randomly generated by the client
            // so we'll generate a new initial_connection_id.
            let connection_info = ConnectionInfo::new(&datagram.remote_address);
            initial_connection_id = self
                .config
                .context()
                .connection_id_format
                .generate(&connection_info);
        }

        //= https://tools.ietf.org/id/draft-ietf-quic-transport-32.txt#17.2
        //# Endpoints that receive a version 1 long header
        //# with a value larger than 20 MUST drop the packet.
        let source_connection_id: connection::PeerId = packet.source_connection_id().try_into()?;

        //= https://tools.ietf.org/id/draft-ietf-quic-transport-32.txt#17.2.5.2
        //# Changing Destination Connection ID also results in a change
        //# to the keys used to protect the Initial packet.
        let initial_crypto =
            <<Config::ConnectionConfig as connection::Config>::TLSSession as CryptoSuite>::InitialCrypto::new_server(
                datagram.destination_connection_id.as_bytes(),
            );

        let largest_packet_number = Default::default();
        let packet = packet.unprotect(&initial_crypto, largest_packet_number)?;
        let packet = packet.decrypt(&initial_crypto)?;

        // TODO handle token with stateless retry

        let internal_connection_id = self.connection_id_generator.generate_id();

        let stateless_reset_token = self
            .config
            .context()
            .stateless_reset_token_generator
            .generate(&initial_connection_id);

        let local_id_registry = self.connection_id_mapper.create_registry(
            internal_connection_id,
            &initial_connection_id,
            stateless_reset_token,
        );

        let timer = self.timer_manager.create_timer(
            internal_connection_id,
            datagram.timestamp + Duration::from_secs(3600),
        ); // TODO: make it so we don't arm for a given time and immediately change it

        let wakeup_handle = self
            .wakeup_queue
            .create_wakeup_handle(internal_connection_id);

        let mut transport_parameters = ServerTransportParameters::default();

        // TODO initialize transport parameters from Limits provider values
        let max = s2n_quic_core::varint::VarInt::from_u32(core::u32::MAX);
        transport_parameters.initial_max_data = max.try_into().unwrap();
        transport_parameters.initial_max_stream_data_bidi_local = max.try_into().unwrap();
        transport_parameters.initial_max_stream_data_bidi_remote = max.try_into().unwrap();
        transport_parameters.initial_max_stream_data_bidi_remote = max.try_into().unwrap();
        transport_parameters.initial_max_stream_data_uni = max.try_into().unwrap();
        transport_parameters.initial_max_streams_bidi = max.try_into().unwrap();
        transport_parameters.initial_max_streams_uni = max.try_into().unwrap();

        //= https://tools.ietf.org/id/draft-ietf-quic-transport-32.txt#7.3
        //# A server includes the Destination Connection ID field from the first
        //# Initial packet it received from the client in the
        //# original_destination_connection_id transport parameter; if the server
        //# sent a Retry packet, this refers to the first Initial packet received
        //# before sending the Retry packet.  If it sends a Retry packet, a
        //# server also includes the Source Connection ID field from the Retry
        //# packet in the retry_source_connection_id transport parameter.
        transport_parameters.original_destination_connection_id = Some(
            original_destination_connection_id
                .try_into()
                .expect("connection ID already validated"),
        );
        if retry_token_dcid.is_some() {
            transport_parameters.retry_source_connection_id = Some(
                datagram
                    .destination_connection_id
                    .try_into()
                    .expect("failed to convert source connection id"),
            );
        }

        //= https://tools.ietf.org/id/draft-ietf-quic-transport-32.txt#7.3
        //# Each endpoint includes the value of the Source Connection ID field
        //# from the first Initial packet it sent in the
        //# initial_source_connection_id transport parameter
        transport_parameters.initial_source_connection_id = Some(
            initial_connection_id
                .as_bytes()
                .try_into()
                .expect("connection ID already validated"),
        );

        //= https://tools.ietf.org/id/draft-ietf-quic-transport-32.txt#18.2
        //# The active connection ID limit is an integer value specifying the
        //# maximum number of connection IDs from the peer that an endpoint is
        //# willing to store. This value includes the connection ID received
        //# during the handshake, that received in the preferred_address transport
        //# parameter, and those received in NEW_CONNECTION_ID frames.
        transport_parameters.active_connection_id_limit = s2n_quic_core::varint::VarInt::from(
            connection::peer_id_registry::ACTIVE_CONNECTION_ID_LIMIT,
        )
        .try_into()
        .unwrap();

        let endpoint_context = self.config.context();

        let tls_session = endpoint_context
            .tls
            .new_server_session(&transport_parameters);

        let path_info = congestion_controller::PathInfo::new(&datagram.remote_address);
        let congestion_controller = endpoint_context
            .congestion_controller
            .new_congestion_controller(path_info);

        let connection_config = self.config.create_connection_config();

        let connection_parameters = connection::Parameters {
            connection_config,
            internal_connection_id,
            local_id_registry,
            timer,
            //= https://tools.ietf.org/id/draft-ietf-quic-transport-32.txt#7.2
            //# A server MUST set the Destination Connection ID it
            //# uses for sending packets based on the first received Initial packet.
            peer_connection_id: source_connection_id,
            local_connection_id: initial_connection_id,
            peer_socket_address: datagram.remote_address,
            congestion_controller,
            timestamp: datagram.timestamp,
            quic_version: packet.version,
        };

        let space_manager =
            PacketSpaceManager::new(tls_session, initial_crypto, datagram.timestamp);

        let shared_state = Arc::new(SynchronizedSharedConnectionState::new(
            space_manager,
            wakeup_handle,
        ));

        let mut connection = <Config as endpoint::Config>::Connection::new(connection_parameters);

        // The scope is needed in order to lock the shared state only for a certain duration.
        // It needs to be unlocked when we insert the connection in our map
        {
            let locked_shared_state = &mut *shared_state.lock();

            let endpoint_context = self.config.context();

            let path_id = connection.on_datagram_received(
                locked_shared_state,
                datagram,
                endpoint_context.congestion_controller,
            )?;

            connection.handle_cleartext_initial_packet(
                locked_shared_state,
                datagram,
                path_id,
                packet,
            )?;

            connection.handle_remaining_packets(
                locked_shared_state,
                datagram,
                path_id,
                endpoint_context.connection_id_format,
                remaining,
            )?;

            //= https://tools.ietf.org/id/draft-ietf-quic-tls-32.txt#4.3
            //= type=TODO
            //= tracking-issue=299
            //# If the
            //# ClientHello spans multiple Initial packets, such servers would need
            //# to buffer the first received fragments, which could consume excessive
            //# resources if the client's address has not yet been validated.  To
            //# avoid this, servers MAY use the Retry feature (see Section 8.1 of
            //# [QUIC-TRANSPORT]) to only buffer partial ClientHello messages from
            //# clients with a validated address.
        }

        // Only persist the connection if everything is good.
        // Otherwise the connection will automatically get dropped. This
        // will also clean up all state which was already allocated for
        // the connection
        self.connections.insert_connection(connection, shared_state);

        Ok(())
    }
}
